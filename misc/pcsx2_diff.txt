diff --git a/pcsx2/cmake/Pcsx2Utils.cmake b/pcsx2/cmake/Pcsx2Utils.cmake
index 84304b6..37fd77f 100644
--- a/pcsx2/cmake/Pcsx2Utils.cmake
+++ b/pcsx2/cmake/Pcsx2Utils.cmake
@@ -152,7 +152,7 @@ endmacro(add_pcsx2_lib)
 macro(add_pcsx2_executable exe srcs libs flags)
     add_definitions(${flags})
     include_directories(.)
-    add_executable(${exe} ${srcs})
+    add_library(${exe} ${srcs})
     target_link_libraries(${exe} ${libs})
     append_flags(${exe} "${flags}")
     if(NOT USER_CMAKE_LD_FLAGS STREQUAL "")
diff --git a/pcsx2/cmake/SearchForStuff.cmake b/pcsx2/cmake/SearchForStuff.cmake
index c6a58e1..be478d0 100644
--- a/pcsx2/cmake/SearchForStuff.cmake
+++ b/pcsx2/cmake/SearchForStuff.cmake
@@ -43,34 +43,6 @@ elseif(NOT APPLE)
     list(APPEND wxWidgets_CONFIG_OPTIONS --toolkit=gtk2)
 endif()
 
-# wx2.8 => /usr/bin/wx-config-2.8
-# lib32-wx2.8 => /usr/bin/wx-config32-2.8
-# wx3.0 => /usr/bin/wx-config-3.0
-# I'm going to take a wild guess and predict this:
-# lib32-wx3.0 => /usr/bin/wx-config32-3.0
-# FindwxWidgets only searches for wx-config.
-if(CMAKE_CROSSCOMPILING)
-    # May need to fix the filenames for lib32-wx3.0.
-    if(${PCSX2_TARGET_ARCHITECTURES} MATCHES "i386")
-        if (Fedora AND EXISTS "/usr/bin/wx-config-3.0")
-            set(wxWidgets_CONFIG_EXECUTABLE "/usr/bin/wx-config-3.0")
-        endif()
-        if (EXISTS "/usr/bin/wx-config32")
-            set(wxWidgets_CONFIG_EXECUTABLE "/usr/bin/wx-config32")
-        endif()
-        if (EXISTS "/usr/bin/wx-config32-3.0")
-            set(wxWidgets_CONFIG_EXECUTABLE "/usr/bin/wx-config32-3.0")
-        endif()
-    endif()
-else()
-    if (${CMAKE_SYSTEM_NAME} MATCHES "FreeBSD")
-        set(wxWidgets_CONFIG_EXECUTABLE "/usr/local/bin/wxgtk3u-3.0-config")
-    endif()
-    if(EXISTS "/usr/bin/wx-config-3.0")
-        set(wxWidgets_CONFIG_EXECUTABLE "/usr/bin/wx-config-3.0")
-    endif()
-endif()
-
 find_package(wxWidgets COMPONENTS base core adv)
 find_package(ZLIB)
 
diff --git a/pcsx2/common/include/PS2Edefs.h b/pcsx2/common/include/PS2Edefs.h
index 8fa7245..74e81ee 100644
--- a/pcsx2/common/include/PS2Edefs.h
+++ b/pcsx2/common/include/PS2Edefs.h
@@ -206,9 +206,6 @@ typedef struct _GSdriverInfo
     void *common;
 } GSdriverInfo;
 
-#ifdef __cplusplus
-extern "C" {
-#endif
 
 /* GS plugin API */
 
@@ -226,27 +223,27 @@ void CALLBACK GSsetSettingsDir(const char *dir);
 void CALLBACK GSsetLogDir(const char *dir);
 
 void CALLBACK GSvsync(int field);
-void CALLBACK GSgifTransfer(const u32 *pMem, u32 addr);
-void CALLBACK GSgifTransfer1(u32 *pMem, u32 addr);
-void CALLBACK GSgifTransfer2(u32 *pMem, u32 size);
-void CALLBACK GSgifTransfer3(u32 *pMem, u32 size);
+//void CALLBACK GSgifTransfer(const u32 *pMem, u32 addr);
+//void CALLBACK GSgifTransfer1(u32 *pMem, u32 addr);
+//void CALLBACK GSgifTransfer2(u32 *pMem, u32 size);
+//void CALLBACK GSgifTransfer3(u32 *pMem, u32 size);
 void CALLBACK GSgetLastTag(u64 *ptag); // returns the last tag processed (64 bits)
 void CALLBACK GSgifSoftReset(u32 mask);
-void CALLBACK GSreadFIFO(u64 *mem);
-void CALLBACK GSinitReadFIFO(u64 *mem);
-void CALLBACK GSreadFIFO2(u64 *mem, int qwc);
+//void CALLBACK GSreadFIFO(u64 *mem);
+//void CALLBACK GSinitReadFIFO(u64 *mem);
+//void CALLBACK GSreadFIFO2(u64 *mem, int qwc);
 void CALLBACK GSinitReadFIFO2(u64 *mem, int qwc);
 
 // extended funcs
 
 // GSkeyEvent gets called when there is a keyEvent from the PAD plugin
-void CALLBACK GSkeyEvent(keyEvent *ev);
+//void CALLBACK GSkeyEvent(keyEvent *ev);
 void CALLBACK GSchangeSaveState(int, const char *filename);
 void CALLBACK GSmakeSnapshot(char *path);
 void CALLBACK GSmakeSnapshot2(char *pathname, int *snapdone, int savejpg);
 void CALLBACK GSirqCallback(void (*callback)());
-void CALLBACK GSsetBaseMem(void *);
-void CALLBACK GSsetGameCRC(int crc, int gameoptions);
+//void CALLBACK GSsetBaseMem(void *);
+//void CALLBACK GSsetGameCRC(int crc, int gameoptions);
 
 // controls frame skipping in the GS, if this routine isn't present, frame skipping won't be done
 void CALLBACK GSsetFrameSkip(int frameskip);
@@ -268,6 +265,11 @@ s32 CALLBACK GStest();
 
 #endif
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
 /* PAD plugin API -=[ OBSOLETE ]=- */
 
 // if this file is included with this define
diff --git a/pcsx2/common/include/Utilities/PageFaultSource.h b/pcsx2/common/include/Utilities/PageFaultSource.h
index 62009bd..ee87700 100644
--- a/pcsx2/common/include/Utilities/PageFaultSource.h
+++ b/pcsx2/common/include/Utilities/PageFaultSource.h
@@ -122,63 +122,16 @@ protected:
     virtual void _DispatchRaw(ListenerIterator iter, const ListenerIterator &iend, const PageFaultInfo &evt);
 };
 
-
-// --------------------------------------------------------------------------------------
-//  VirtualMemoryManager: Manages the allocation of PCSX2 VM
-//    Ensures that all memory is close enough together for rip-relative addressing
-// --------------------------------------------------------------------------------------
-class VirtualMemoryManager
-{
-    DeclareNoncopyableObject(VirtualMemoryManager);
-
-    wxString m_name;
-
-    uptr m_baseptr;
-
-    // An array to track page usage (to trigger asserts if things try to overlap)
-    std::atomic<bool> *m_pageuse;
-
-    // reserved memory (in pages)
-    u32 m_pages_reserved;
-
-public:
-    // If upper_bounds is nonzero and the OS fails to allocate memory that is below it,
-    // calls to IsOk() will return false and Alloc() will always return null pointers
-    // strict indicates that the allocation should quietly fail if the memory can't be mapped at `base`
-    VirtualMemoryManager(const wxString &name, uptr base, size_t size, uptr upper_bounds = 0, bool strict = false);
-    ~VirtualMemoryManager();
-
-    void *GetBase() const { return (void *)m_baseptr; }
-
-    // Request the use of the memory at offsetLocation bytes from the start of the reserved memory area
-    // offsetLocation must be page-aligned
-    void *Alloc(uptr offsetLocation, size_t size) const;
-
-    void *AllocAtAddress(void *address, size_t size) const {
-        return Alloc(size, (uptr)address - m_baseptr);
-    }
-
-    void Free(void *address, size_t size) const;
-
-    // Was this VirtualMemoryManager successfully able to get its memory mapping?
-    // (If not, calls to Alloc will return null pointers)
-    bool IsOk() const { return m_baseptr != 0; }
-};
-
-typedef std::shared_ptr<const VirtualMemoryManager> VirtualMemoryManagerPtr;
-
 // --------------------------------------------------------------------------------------
 //  VirtualMemoryBumpAllocator: Allocates memory for things that don't have explicitly-reserved spots
 // --------------------------------------------------------------------------------------
 class VirtualMemoryBumpAllocator
 {
-    const VirtualMemoryManagerPtr m_allocator;
     std::atomic<uptr> m_baseptr{0};
     const uptr m_endptr = 0;
 public:
-    VirtualMemoryBumpAllocator(VirtualMemoryManagerPtr allocator, size_t size, uptr offsetLocation);
+    VirtualMemoryBumpAllocator(void *mem, size_t size);
     void *Alloc(size_t size);
-    const VirtualMemoryManagerPtr& GetAllocator() { return m_allocator; }
 };
 
 // --------------------------------------------------------------------------------------
@@ -191,9 +144,6 @@ class VirtualMemoryReserve
 protected:
     wxString m_name;
 
-    // Where the memory came from (so we can return it)
-    VirtualMemoryManagerPtr m_allocator;
-
     // Default size of the reserve, in bytes.  Can be specified when the object is constructed.
     // Is used as the reserve size when Reserve() is called, unless an override is specified
     // in the Reserve parameters.
@@ -217,43 +167,28 @@ protected:
     // as well.
     bool m_allow_writes;
 
-    // Allows the implementation to decide how much memory it needs to allocate if someone requests the given size
-    // Should translate requests of size 0 to m_defsize
-    virtual size_t GetSize(size_t requestedSize);
-
 public:
     VirtualMemoryReserve(const wxString &name, size_t size = 0);
     virtual ~VirtualMemoryReserve()
     {
-        Release();
+        Reset();
     }
 
-    // Initialize with the given piece of memory
-    // Note: The memory is already allocated, the allocator is for future use to free the region
-    // It may be null in which case there is no way to free the memory in a way it will be usable again
-    virtual void *Assign(VirtualMemoryManagerPtr allocator, void *baseptr, size_t size);
+    // Initialize with the given piece of (reserved but not committed) memory
+    virtual void *Assign(void *baseptr, size_t size);
 
-    void *Reserve(VirtualMemoryManagerPtr allocator, uptr baseOffset, size_t size = 0)
-    {
-        size = GetSize(size);
-        void *allocation = allocator->Alloc(baseOffset, size);
-        return Assign(std::move(allocator), allocation, size);
-    }
     void *Reserve(VirtualMemoryBumpAllocator& allocator, size_t size = 0)
     {
-        size = GetSize(size);
-        return Assign(allocator.GetAllocator(), allocator.Alloc(size), size);
+        size = size == 0 ? m_defsize : size;
+        return Assign(allocator.Alloc(size), size);
     }
 
     virtual void Reset();
-    virtual void Release();
-    virtual bool TryResize(uint newsize);
     virtual bool Commit();
 
     virtual void ForbidModification();
     virtual void AllowModification();
 
-    bool IsOk() const { return m_baseptr != NULL; }
     const wxString& GetName() const { return m_name; }
 
     uptr GetReserveSizeInBytes() const { return m_pages_reserved * __pagesize; }
@@ -298,7 +233,7 @@ protected:
 #elif defined(_WIN32)
 
 struct _EXCEPTION_POINTERS;
-extern long __stdcall SysPageFaultExceptionFilter(struct _EXCEPTION_POINTERS *eps);
+extern int SysPageFaultExceptionFilter(struct _EXCEPTION_POINTERS *eps);
 
 #define PCSX2_PAGEFAULT_PROTECT __try
 #define PCSX2_PAGEFAULT_EXCEPT \
diff --git a/pcsx2/common/include/x86emitter/implement/jmpcall.h b/pcsx2/common/include/x86emitter/implement/jmpcall.h
index 94eda18..b2277bd 100644
--- a/pcsx2/common/include/x86emitter/implement/jmpcall.h
+++ b/pcsx2/common/include/x86emitter/implement/jmpcall.h
@@ -29,6 +29,10 @@ struct xImpl_JmpCall
 
     void operator()(const xAddressReg &absreg) const;
     void operator()(const xIndirectNative &src) const;
+#ifdef __M_X86_64
+    [[deprecated]] // Should move to xIndirectNative
+    void operator()(const xIndirect32 &absreg) const;
+#endif
 
     // Special form for calling functions.  This form automatically resolves the
     // correct displacement based on the size of the instruction being generated.
@@ -87,6 +91,11 @@ struct xImpl_FastCall
         (*this)((void*)func, a1, a2);
     }
 
+#ifdef __M_X86_64
+    [[deprecated]] // Switch to xIndirectNative
+    void operator()(const xIndirect32 &f, const xRegisterLong &a1 = xEmptyReg, const xRegisterLong &a2 = xEmptyReg) const;
+#endif
+
     void operator()(const xIndirectNative &f, const xRegisterLong &a1 = xEmptyReg, const xRegisterLong &a2 = xEmptyReg) const;
 };
 
diff --git a/pcsx2/common/include/x86emitter/instructions.h b/pcsx2/common/include/x86emitter/instructions.h
index 3d142e2..e43dff0 100644
--- a/pcsx2/common/include/x86emitter/instructions.h
+++ b/pcsx2/common/include/x86emitter/instructions.h
@@ -89,7 +89,13 @@ extern const xImpl_Group8 xBTC;
 extern const xImpl_BitScan xBSF, xBSR;
 
 extern const xImpl_JmpCall xJMP;
+#ifdef __M_X86_64
+// 32 bits Call won't be compatible in 64 bits (different ABI)
+// Just a reminder to port the code
+[[deprecated]] extern const xImpl_JmpCall xCALL;
+#else
 extern const xImpl_JmpCall xCALL;
+#endif
 extern const xImpl_FastCall xFastCall;
 
 // ------------------------------------------------------------------------
@@ -139,6 +145,8 @@ extern void xBSWAP(const xRegister32or64 &to);
 extern void xLEA(xRegister64 to, const xIndirectVoid &src, bool preserve_flags = false);
 extern void xLEA(xRegister32 to, const xIndirectVoid &src, bool preserve_flags = false);
 extern void xLEA(xRegister16 to, const xIndirectVoid &src, bool preserve_flags = false);
+/// LEA with a target that will be decided later, guarantees that no optimizations are performed that could change what needs to be written in
+extern u32* xLEA_Writeback(xAddressReg to);
 
 // ----- Push / Pop Instructions  -----
 // Note: pushad/popad implementations are intentionally left out.  The instructions are
diff --git a/pcsx2/common/include/x86emitter/x86types.h b/pcsx2/common/include/x86emitter/x86types.h
index e27a999..8260fde 100644
--- a/pcsx2/common/include/x86emitter/x86types.h
+++ b/pcsx2/common/include/x86emitter/x86types.h
@@ -773,9 +773,14 @@ extern const xAddressReg
     r8, r9, r10, r11,
     r12, r13, r14, r15;
 
+extern const xAddressReg
+    eax, ebx, ecx, edx,
+    esi, edi, ebp, esp;
+
+// Temporary registers to aid the move to x86-64
 extern const xRegister32
-     eax,  ebx,  ecx,  edx,
-     esi,  edi,  ebp,  esp,
+    eaxd, ebxd, ecxd, edxd,
+    esid, edid, ebpd, espd,
      r8d,  r9d, r10d, r11d,
     r12d, r13d, r14d, r15d;
 
diff --git a/pcsx2/common/src/Utilities/VirtualMemory.cpp b/pcsx2/common/src/Utilities/VirtualMemory.cpp
index f6cb61c..9381587 100644
--- a/pcsx2/common/src/Utilities/VirtualMemory.cpp
+++ b/pcsx2/common/src/Utilities/VirtualMemory.cpp
@@ -72,129 +72,11 @@ static size_t pageAlign(size_t size)
     return (size + __pagesize - 1) / __pagesize * __pagesize;
 }
 
-// --------------------------------------------------------------------------------------
-//  VirtualMemoryManager  (implementations)
-// --------------------------------------------------------------------------------------
-
-VirtualMemoryManager::VirtualMemoryManager(const wxString &name, uptr base, size_t size, uptr upper_bounds, bool strict)
-    : m_name(name), m_baseptr(0), m_pageuse(nullptr), m_pages_reserved(0)
-{
-    if (!size) return;
-
-    uptr reserved_bytes = pageAlign(size);
-    m_pages_reserved = reserved_bytes / __pagesize;
-
-    m_baseptr = (uptr)HostSys::MmapReserve(base, reserved_bytes);
-
-    if (!m_baseptr || (upper_bounds != 0 && (((uptr)m_baseptr + reserved_bytes) > upper_bounds))) {
-        DevCon.Warning(L"%s: host memory @ %ls -> %ls is unavailable; attempting to map elsewhere...",
-                       WX_STR(m_name), pxsPtr(base), pxsPtr(base + size));
-
-        SafeSysMunmap(m_baseptr, reserved_bytes);
-
-        if (base) {
-            // Let's try again at an OS-picked memory area, and then hope it meets needed
-            // boundschecking criteria below.
-            m_baseptr = (uptr)HostSys::MmapReserve(0, reserved_bytes);
-        }
-    }
-
-    bool fulfillsRequirements = true;
-    if (strict && m_baseptr != base)
-        fulfillsRequirements = false;
-    if ((upper_bounds != 0) && ((m_baseptr + reserved_bytes) > upper_bounds))
-        fulfillsRequirements = false;
-    if (!fulfillsRequirements) {
-        SafeSysMunmap(m_baseptr, reserved_bytes);
-    }
-
-    if (!m_baseptr) return;
-
-    m_pageuse = new std::atomic<bool>[m_pages_reserved]();
-
-    FastFormatUnicode mbkb;
-    uint mbytes = reserved_bytes / _1mb;
-    if (mbytes)
-        mbkb.Write("[%umb]", mbytes);
-    else
-        mbkb.Write("[%ukb]", reserved_bytes / 1024);
-
-    DevCon.WriteLn(Color_Gray, L"%-32s @ %ls -> %ls %ls", WX_STR(m_name),
-                   pxsPtr(m_baseptr), pxsPtr((uptr)m_baseptr + reserved_bytes), mbkb.c_str());
-}
-
-VirtualMemoryManager::~VirtualMemoryManager()
-{
-    if (m_pageuse) delete[] m_pageuse;
-    if (m_baseptr) HostSys::Munmap(m_baseptr, m_pages_reserved * __pagesize);
-}
-
-static bool VMMMarkPagesAsInUse(std::atomic<bool> *begin, std::atomic<bool> *end) {
-    for (auto current = begin; current < end; current++) {
-        bool expected = false;
-        if (!current->compare_exchange_strong(expected, true), std::memory_order_relaxed) {
-            // This was already allocated!  Undo the things we've set until this point
-            while (--current >= begin) {
-                if (!current->compare_exchange_strong(expected, false, std::memory_order_relaxed)) {
-                    // In the time we were doing this, someone set one of the things we just set to true back to false
-                    // This should never happen, but if it does we'll just stop and hope nothing bad happens
-                    pxAssert(0);
-                    return false;
-                }
-            }
-            return false;
-        }
-    }
-    return true;
-}
-
-void *VirtualMemoryManager::Alloc(uptr offsetLocation, size_t size) const
-{
-    size = pageAlign(size);
-    if (!pxAssertDev(offsetLocation % __pagesize == 0, "(VirtualMemoryManager) alloc at unaligned offsetLocation"))
-        return nullptr;
-    if (!pxAssertDev(size + offsetLocation <= m_pages_reserved * __pagesize, "(VirtualMemoryManager) alloc outside reserved area"))
-        return nullptr;
-    if (m_baseptr == 0)
-        return nullptr;
-    auto puStart = &m_pageuse[offsetLocation / __pagesize];
-    auto puEnd = &m_pageuse[(offsetLocation+size) / __pagesize];
-    if (!pxAssertDev(VMMMarkPagesAsInUse(puStart, puEnd), "(VirtualMemoryManager) allocation requests overlapped"))
-        return nullptr;
-    return (void *)(m_baseptr + offsetLocation);
-}
-
-void VirtualMemoryManager::Free(void *address, size_t size) const
-{
-    uptr offsetLocation = (uptr)address - m_baseptr;
-    if (!pxAssertDev(offsetLocation % __pagesize == 0, "(VirtualMemoryManager) free at unaligned address")) {
-        uptr newLoc = pageAlign(offsetLocation);
-        size -= (offsetLocation - newLoc);
-        offsetLocation = newLoc;
-    }
-    if (!pxAssertDev(size % __pagesize == 0, "(VirtualMemoryManager) free with unaligned size"))
-        size -= size % __pagesize;
-    if (!pxAssertDev(size + offsetLocation <= m_pages_reserved * __pagesize, "(VirtualMemoryManager) free outside reserved area"))
-        return;
-    auto puStart = &m_pageuse[offsetLocation / __pagesize];
-    auto puEnd = &m_pageuse[(offsetLocation+size) / __pagesize];
-    for (; puStart < puEnd; puStart++) {
-        bool expected = true;
-        if (!puStart->compare_exchange_strong(expected, false, std::memory_order_relaxed)) {
-            pxAssertDev(0, "(VirtaulMemoryManager) double-free");
-        }
-    }
-}
-
 // --------------------------------------------------------------------------------------
 //  VirtualMemoryBumpAllocator  (implementations)
 // --------------------------------------------------------------------------------------
-VirtualMemoryBumpAllocator::VirtualMemoryBumpAllocator(VirtualMemoryManagerPtr allocator, uptr offsetLocation, size_t size)
-    : m_allocator(std::move(allocator)), m_baseptr((uptr)m_allocator->Alloc(offsetLocation, size)), m_endptr(m_baseptr + size)
-{
-    if (m_baseptr.load() == 0)
-        pxAssertDev(0, "(VirtualMemoryBumpAllocator) tried to construct from bad VirtualMemoryManager");
-}
+VirtualMemoryBumpAllocator::VirtualMemoryBumpAllocator(void *mem, size_t size)
+    : m_baseptr((uptr)mem), m_endptr(m_baseptr + size) {}
 
 void *VirtualMemoryBumpAllocator::Alloc(size_t size)
 {
@@ -219,7 +101,6 @@ VirtualMemoryReserve::VirtualMemoryReserve(const wxString &name, size_t size)
 {
     m_defsize = size;
 
-    m_allocator = nullptr;
     m_pages_commited = 0;
     m_pages_reserved = 0;
     m_baseptr = nullptr;
@@ -233,13 +114,6 @@ VirtualMemoryReserve &VirtualMemoryReserve::SetPageAccessOnCommit(const PageProt
     return *this;
 }
 
-size_t VirtualMemoryReserve::GetSize(size_t requestedSize)
-{
-    if (!requestedSize)
-        return pageAlign(m_defsize);
-    return pageAlign(requestedSize);
-}
-
 // Notes:
 //  * This method should be called if the object is already in an released (unreserved) state.
 //    Subsequent calls will be ignored, and the existing reserve will be returned.
@@ -248,7 +122,7 @@ size_t VirtualMemoryReserve::GetSize(size_t requestedSize)
 //   baseptr - the new base pointer that's about to be assigned
 //   size - size of the region pointed to by baseptr
 //
-void *VirtualMemoryReserve::Assign(VirtualMemoryManagerPtr allocator, void * baseptr, size_t size)
+void *VirtualMemoryReserve::Assign(void * baseptr, size_t size)
 {
     if (!pxAssertDev(m_baseptr == NULL, "(VirtualMemoryReserve) Invalid object state; object has already been reserved."))
         return m_baseptr;
@@ -256,8 +130,6 @@ void *VirtualMemoryReserve::Assign(VirtualMemoryManagerPtr allocator, void * bas
     if (!size)
         return nullptr;
 
-    m_allocator = std::move(allocator);
-
     m_baseptr = baseptr;
 
     uptr reserved_bytes = pageAlign(size);
@@ -297,14 +169,6 @@ void VirtualMemoryReserve::Reset()
     m_pages_commited = 0;
 }
 
-void VirtualMemoryReserve::Release()
-{
-    if (!m_baseptr) return;
-    Reset();
-    m_allocator->Free(m_baseptr, m_pages_reserved * __pagesize);
-    m_baseptr = nullptr;
-}
-
 bool VirtualMemoryReserve::Commit()
 {
     if (!m_pages_reserved)
@@ -312,8 +176,9 @@ bool VirtualMemoryReserve::Commit()
     if (!pxAssert(!m_pages_commited))
         return true;
 
-    m_pages_commited = m_pages_reserved;
-    return HostSys::MmapCommitPtr(m_baseptr, m_pages_reserved * __pagesize, m_prot_mode);
+    bool ok = HostSys::MmapCommitPtr(m_baseptr, m_pages_reserved * __pagesize, m_prot_mode);
+    if (ok) { m_pages_commited = m_pages_reserved; }
+    return ok;
 }
 
 void VirtualMemoryReserve::AllowModification()
@@ -328,53 +193,6 @@ void VirtualMemoryReserve::ForbidModification()
     HostSys::MemProtect(m_baseptr, m_pages_commited * __pagesize, PageProtectionMode(m_prot_mode).Write(false));
 }
 
-
-// If growing the array, or if shrinking the array to some point that's still *greater* than the
-// committed memory range, then attempt a passive "on-the-fly" resize that maps/unmaps some portion
-// of the reserve.
-//
-// If the above conditions are not met, or if the map/unmap fails, this method returns false.
-// The caller will be responsible for manually resetting the reserve.
-//
-// Parameters:
-//  newsize - new size of the reserved buffer, in bytes.
-bool VirtualMemoryReserve::TryResize(uint newsize)
-{
-    uint newPages = pageAlign(newsize) / __pagesize;
-
-    if (newPages > m_pages_reserved) {
-        uint toReservePages = newPages - m_pages_reserved;
-        uint toReserveBytes = toReservePages * __pagesize;
-
-        DevCon.WriteLn(L"%-32s is being expanded by %u pages.", WX_STR(m_name), toReservePages);
-
-        if (!m_allocator->AllocAtAddress(GetPtrEnd(), toReserveBytes)) {
-            Console.Warning("%-32s could not be passively resized due to virtual memory conflict!", WX_STR(m_name));
-            Console.Indent().Warning("(attempted to map memory @ %08p -> %08p)", m_baseptr, (uptr)m_baseptr + toReserveBytes);
-            return false;
-        }
-
-        DevCon.WriteLn(Color_Gray, L"%-32s @ %08p -> %08p [%umb]", WX_STR(m_name),
-                       m_baseptr, (uptr)m_baseptr + toReserveBytes, toReserveBytes / _1mb);
-    } else if (newPages < m_pages_reserved) {
-        if (m_pages_commited > newsize)
-            return false;
-
-        uint toRemovePages = m_pages_reserved - newPages;
-        uint toRemoveBytes = toRemovePages * __pagesize;
-
-        DevCon.WriteLn(L"%-32s is being shrunk by %u pages.", WX_STR(m_name), toRemovePages);
-
-        m_allocator->Free(GetPtrEnd() - toRemoveBytes, toRemoveBytes);
-
-        DevCon.WriteLn(Color_Gray, L"%-32s @ %08p -> %08p [%umb]", WX_STR(m_name),
-                       m_baseptr, GetPtrEnd(), GetReserveSizeInBytes() / _1mb);
-    }
-
-    m_pages_reserved = newPages;
-    return true;
-}
-
 // --------------------------------------------------------------------------------------
 //  PageProtectionMode  (implementations)
 // --------------------------------------------------------------------------------------
diff --git a/pcsx2/common/src/Utilities/Windows/WinHostSys.cpp b/pcsx2/common/src/Utilities/Windows/WinHostSys.cpp
index 3121f24..6b6059e 100644
--- a/pcsx2/common/src/Utilities/Windows/WinHostSys.cpp
+++ b/pcsx2/common/src/Utilities/Windows/WinHostSys.cpp
@@ -19,7 +19,7 @@
 
 #include <winnt.h>
 
-static long DoSysPageFaultExceptionFilter(EXCEPTION_POINTERS *eps)
+static int DoSysPageFaultExceptionFilter(EXCEPTION_POINTERS *eps)
 {
     if (eps->ExceptionRecord->ExceptionCode != EXCEPTION_ACCESS_VIOLATION)
         return EXCEPTION_CONTINUE_SEARCH;
@@ -32,7 +32,7 @@ static long DoSysPageFaultExceptionFilter(EXCEPTION_POINTERS *eps)
     return Source_PageFault->WasHandled() ? EXCEPTION_CONTINUE_EXECUTION : EXCEPTION_CONTINUE_SEARCH;
 }
 
-long __stdcall SysPageFaultExceptionFilter(EXCEPTION_POINTERS *eps)
+int SysPageFaultExceptionFilter(EXCEPTION_POINTERS *eps)
 {
     // Prevent recursive exception filtering by catching the exception from the filter here.
     // In the event that the filter causes an access violation (happened during shutdown
@@ -49,9 +49,7 @@ long __stdcall SysPageFaultExceptionFilter(EXCEPTION_POINTERS *eps)
 
 void _platform_InstallSignalHandler()
 {
-#ifdef _WIN64 // We don't handle SEH properly on Win64 so use a vectored exception handler instead
-    AddVectoredExceptionHandler(true, SysPageFaultExceptionFilter);
-#endif
+    // NOP on Win32 systems -- we use __try{} __except{} instead.
 }
 
 
diff --git a/pcsx2/common/src/x86emitter/cpudetect.cpp b/pcsx2/common/src/x86emitter/cpudetect.cpp
index 79bbe72..6e701f1 100644
--- a/pcsx2/common/src/x86emitter/cpudetect.cpp
+++ b/pcsx2/common/src/x86emitter/cpudetect.cpp
@@ -95,7 +95,7 @@ s64 x86capabilities::_CPUSpeedHz(u64 time) const
         timeStart = GetCPUTicks();
 #ifdef _MSC_VER
         startCycle = __rdtsc();
-#elif defined(__M_X86_64)
+#elif defined(_M_X86_64)
         unsigned long long low, high;
         __asm__ __volatile__("rdtsc"
                              : "=a"(low), "=d"(high));
@@ -110,7 +110,7 @@ s64 x86capabilities::_CPUSpeedHz(u64 time) const
         timeStop = GetCPUTicks();
 #ifdef _MSC_VER
         endCycle = __rdtsc();
-#elif defined(__M_X86_64)
+#elif defined(_M_X86_64)
         unsigned long long low, high;
         __asm__ __volatile__("rdtsc"
                              : "=a"(low), "=d"(high));
@@ -297,7 +297,7 @@ void x86capabilities::Identify()
 
     if ((Flags2 >> 27) & 1) // OSXSAVE
     {
-        if ((xgetbv(0) & 6) == 6) // XFEATURE_ENABLED_MASK[2:1] = '11b' (XMM state and YMM state are enabled by OS).
+        //if ((xgetbv(0) & 6) == 6) // XFEATURE_ENABLED_MASK[2:1] = '11b' (XMM state and YMM state are enabled by OS).
         {
             hasAVX = (Flags2 >> 28) & 1; //avx
             hasFMA = (Flags2 >> 12) & 1; //fma
diff --git a/pcsx2/common/src/x86emitter/groups.cpp b/pcsx2/common/src/x86emitter/groups.cpp
index 2e912c1..4106f78 100644
--- a/pcsx2/common/src/x86emitter/groups.cpp
+++ b/pcsx2/common/src/x86emitter/groups.cpp
@@ -156,7 +156,7 @@ void xImpl_Group2::operator()(const xIndirect64orLess &sibdest, u8 imm) const
         // special encoding of 1's
         xOpWrite(sibdest.GetPrefix16(), sibdest.Is8BitOp() ? x86_Opcode_NB2_Eb1 : x86_Opcode_NB2_Ev1, InstType, sibdest);
     } else {
-        xOpWrite(sibdest.GetPrefix16(), sibdest.Is8BitOp() ? x86_Opcode_NB2_Eb_Ib : x86_Opcode_NB2_Ev_Ib, InstType, sibdest, 1);
+        xOpWrite(sibdest.GetPrefix16(), sibdest.Is8BitOp() ? x86_Opcode_NB2_Eb_Ib : x86_Opcode_NB2_Ev_Ib, InstType, sibdest,1);
         xWrite8(imm);
     }
 }
diff --git a/pcsx2/common/src/x86emitter/jmp.cpp b/pcsx2/common/src/x86emitter/jmp.cpp
index 48d3632..0f06d65 100644
--- a/pcsx2/common/src/x86emitter/jmp.cpp
+++ b/pcsx2/common/src/x86emitter/jmp.cpp
@@ -44,6 +44,11 @@ void xImpl_JmpCall::operator()(const xIndirectNative &src) const {
     xWrite8(0xff);
     EmitSibMagic(isJmp ? 4 : 2, src);
 }
+#ifdef __M_X86_64
+void xImpl_JmpCall::operator()(const xIndirect32 &absreg) const {
+    xOpWrite(0, 0xff, isJmp ? 4 : 2, absreg);
+}
+#endif
 
 const xImpl_JmpCall xJMP = {true};
 const xImpl_JmpCall xCALL = {false};
@@ -121,6 +126,13 @@ void xImpl_FastCall::operator()(void *f, u32 a1, u32 a2) const {
     (*this)(f, arg1regd, arg2regd);
 }
 
+#ifdef __M_X86_64
+void xImpl_FastCall::operator()(const xIndirect32 &f, const xRegisterLong &a1, const xRegisterLong &a2) const {
+    prepareRegsForFastcall(a1, a2);
+    xCALL(f);
+}
+#endif
+
 void xImpl_FastCall::operator()(const xIndirectNative &f, const xRegisterLong &a1, const xRegisterLong &a2) const {
     prepareRegsForFastcall(a1, a2);
     xCALL(f);
diff --git a/pcsx2/common/src/x86emitter/x86emitter.cpp b/pcsx2/common/src/x86emitter/x86emitter.cpp
index 161693b..5c81ef2 100644
--- a/pcsx2/common/src/x86emitter/x86emitter.cpp
+++ b/pcsx2/common/src/x86emitter/x86emitter.cpp
@@ -130,11 +130,17 @@ const xAddressReg
     r12(12), r13(13),
     r14(14), r15(15);
 
-const xRegister32
+const xAddressReg
     eax(0), ebx(3),
     ecx(1), edx(2),
     esp(4), ebp(5),
-    esi(6), edi(7),
+    esi(6), edi(7);
+
+const xRegister32
+    eaxd(0), ebxd(3),
+    ecxd(1), edxd(2),
+    espd(4), ebpd(5),
+    esid(6), edid(7),
     r8d(8), r9d(9),
     r10d(10), r11d(11),
     r12d(12), r13d(13),
@@ -158,7 +164,7 @@ const xAddressReg
     arg2reg = rdx,
 #ifdef __M_X86_64
     arg3reg = r8,
-    arg4reg = r9,
+    arg4reg = r9
 #else
     arg3reg = xRegisterEmpty(),
     arg4reg = xRegisterEmpty(),
@@ -167,10 +173,10 @@ const xAddressReg
     calleeSavedReg2 = rsi;
 
 const xRegister32
-    arg1regd = ecx,
-    arg2regd = edx,
-    calleeSavedReg1d = edi,
-    calleeSavedReg2d = esi;
+    arg1regd = ecxd,
+    arg2regd = edxd,
+    calleeSavedReg1d = edid,
+    calleeSavedReg2d = esid;
 #else
 const xAddressReg
     arg1reg = rdi,
@@ -181,8 +187,8 @@ const xAddressReg
     calleeSavedReg2 = r13;
 
 const xRegister32
-    arg1regd = edi,
-    arg2regd = esi,
+    arg1regd = edid,
+    arg2regd = esid,
     calleeSavedReg1d = r12d,
     calleeSavedReg2d = r13d;
 #endif
@@ -361,7 +367,7 @@ void EmitSibMagic(uint regfield, const xIndirectVoid &info, int extraRIPOffset)
             EmitSibMagic(regfield, (void *)info.Displacement, extraRIPOffset);
             return;
         } else {
-            if (info.Index == rbp && displacement_size == 0)
+            if (info.Index == ebp && displacement_size == 0)
                 displacement_size = 1; // forces [ebp] to be encoded as [ebp+0]!
 
             ModRM(displacement_size, regfield, info.Index.Id & 7);
@@ -379,7 +385,7 @@ void EmitSibMagic(uint regfield, const xIndirectVoid &info, int extraRIPOffset)
             xWrite<s32>(info.Displacement);
             return;
         } else {
-            if (info.Base == rbp && displacement_size == 0)
+            if (info.Base == ebp && displacement_size == 0)
                 displacement_size = 1; // forces [ebp] to be encoded as [ebp+0]!
 
             ModRM(displacement_size, regfield, ModRm_UseSib);
@@ -890,7 +896,7 @@ static void EmitLeaMagic(const xRegisterInt &to, const xIndirectVoid &src, bool
         } else {
             if (src.Scale == 0) {
                 if (!preserve_flags) {
-                    if (src.Index == rsp) {
+                    if (src.Index == esp) {
                         // ESP is not encodable as an index (ix86 ignores it), thus:
                         _xMovRtoR(to, sizeMatchedBase); // will do the trick!
                         if (src.Displacement)
@@ -901,7 +907,7 @@ static void EmitLeaMagic(const xRegisterInt &to, const xIndirectVoid &src, bool
                         _g1_EmitOp(G1Type_ADD, to, sizeMatchedIndex);
                         return;
                     }
-                } else if ((src.Index == rsp) && (src.Displacement == 0)) {
+                } else if ((src.Index == esp) && (src.Displacement == 0)) {
                     // special case handling of ESP as Index, which is replaceable with
                     // a single MOV even when preserve_flags is set! :D
 
@@ -931,6 +937,17 @@ __emitinline void xLEA(xRegister16 to, const xIndirectVoid &src, bool preserve_f
     EmitLeaMagic(to, src, preserve_flags);
 }
 
+__emitinline u32* xLEA_Writeback(xAddressReg to)
+{
+#ifdef __M_X86_64
+    xOpWrite(0, 0x8d, to, ptr[(void*)(0xdcdcdcd + (uptr)xGetPtr() + 7)]);
+#else
+    xOpAccWrite(0, 0xb8 | to.Id, 0, to);
+    xWrite32(0xcdcdcdcd);
+#endif
+    return (u32*)xGetPtr() - 1;
+}
+
 // =====================================================================================================
 //  TEST / INC / DEC
 // =====================================================================================================
@@ -1118,18 +1135,17 @@ __emitinline void xRestoreReg(const xRegisterSSE &dest)
 
 //////////////////////////////////////////////////////////////////////////////////////////
 // Helper object to handle ABI frame
-#ifdef __M_X86_64
+#ifdef __GNUC__
 
-// All x86-64 calling conventions ensure/require stack to be 16 bytes aligned
-// I couldn't find documentation on when, but compilers would indicate it's before the call: https://gcc.godbolt.org/z/KzTfsz
+#ifdef __M_X86_64
+// GCC ensures/requires stack to be 16 bytes aligned (but when?)
 #define ALIGN_STACK(v) xADD(rsp, v)
-
-#elif defined(__GNUC__)
-
+#else
 // GCC ensures/requires stack to be 16 bytes aligned before the call
 // Call will store 4 bytes. EDI/ESI/EBX will take another 12 bytes.
 // EBP will take 4 bytes if m_base_frame is enabled
 #define ALIGN_STACK(v) xADD(esp, v)
+#endif
 
 #else
 
@@ -1151,35 +1167,41 @@ xScopedStackFrame::xScopedStackFrame(bool base_frame, bool save_base_pointer, in
     m_save_base_pointer = save_base_pointer;
     m_offset = offset;
 
-    m_offset += sizeof(void*); // Call stores the return address (4 bytes)
+#ifdef __M_X86_64
+
+    m_offset += 8; // Call stores the return address (4 bytes)
 
     // Note rbp can surely be optimized in 64 bits
     if (m_base_frame) {
         xPUSH(rbp);
         xMOV(rbp, rsp);
-        m_offset += sizeof(void*);
+        m_offset += 8;
     } else if (m_save_base_pointer) {
         xPUSH(rbp);
-        m_offset += sizeof(void*);
+        m_offset += 8;
     }
 
-#ifdef __M_X86_64
-
     xPUSH(rbx);
     xPUSH(r12);
     xPUSH(r13);
     xPUSH(r14);
     xPUSH(r15);
     m_offset += 40;
-#ifdef _WIN32
-    xPUSH(rdi);
-    xPUSH(rsi);
-    xSUB(rsp, 32); // Windows calling convention specifies additional space for the callee to spill registers
-    m_offset += 48;
-#endif
 
 #else
 
+    m_offset += 4; // Call stores the return address (4 bytes)
+
+    // Create a new frame
+    if (m_base_frame) {
+        xPUSH(ebp);
+        xMOV(ebp, esp);
+        m_offset += 4;
+    } else if (m_save_base_pointer) {
+        xPUSH(ebp);
+        m_offset += 4;
+    }
+
     // Save the register context
     xPUSH(edi);
     xPUSH(esi);
@@ -1198,17 +1220,19 @@ xScopedStackFrame::~xScopedStackFrame()
 #ifdef __M_X86_64
 
     // Restore the register context
-#ifdef _WIN32
-    xADD(rsp, 32);
-    xPOP(rsi);
-    xPOP(rdi);
-#endif
     xPOP(r15);
     xPOP(r14);
     xPOP(r13);
     xPOP(r12);
     xPOP(rbx);
 
+    // Destroy the frame
+    if (m_base_frame) {
+        xLEAVE();
+    } else if (m_save_base_pointer) {
+        xPOP(rbp);
+    }
+
 #else
 
     // Restore the register context
@@ -1216,14 +1240,14 @@ xScopedStackFrame::~xScopedStackFrame()
     xPOP(esi);
     xPOP(edi);
 
-#endif
-
     // Destroy the frame
     if (m_base_frame) {
         xLEAVE();
     } else if (m_save_base_pointer) {
-        xPOP(rbp);
+        xPOP(ebp);
     }
+
+#endif
 }
 
 xScopedSavedRegisters::xScopedSavedRegisters(std::initializer_list<std::reference_wrapper<const xAddressReg>> regs) {
diff --git a/pcsx2/common/vsprops/CommonLibrary.props b/pcsx2/common/vsprops/CommonLibrary.props
index 0ec2c66..40da9b1 100644
--- a/pcsx2/common/vsprops/CommonLibrary.props
+++ b/pcsx2/common/vsprops/CommonLibrary.props
@@ -13,8 +13,6 @@
     <ClCompile>
       <AdditionalIncludeDirectories>$(SvnRootDir)\common\include\$(ProjectName);$(SvnRootDir)\common\include;$(SvnRootDir)\3rdparty\wxwidgets3.0\include;$(SvnRootDir)\3rdparty;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
       <PreprocessorDefinitions>__WIN32__;WIN32;_WINDOWS;_CRT_SECURE_NO_WARNINGS;_CRT_SECURE_NO_DEPRECATE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <PreprocessorDefinitions Condition="'$(Platform)'=='x64'">_ARCH_64=1;_M_X86_64;__M_X86_64;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <PreprocessorDefinitions Condition="'$(Platform)'=='Win32'">_ARCH_32=1;_M_X86_32;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <StructMemberAlignment>16Bytes</StructMemberAlignment>
       <FunctionLevelLinking>true</FunctionLevelLinking>
       <RuntimeTypeInfo>false</RuntimeTypeInfo>
diff --git a/pcsx2/pcsx2/COP0.cpp b/pcsx2/pcsx2/COP0.cpp
index 2fce7af..e8f6763 100644
--- a/pcsx2/pcsx2/COP0.cpp
+++ b/pcsx2/pcsx2/COP0.cpp
@@ -21,6 +21,13 @@
 u32 s_iLastCOP0Cycle = 0;
 u32 s_iLastPERFCycle[2] = { 0, 0 };
 
+void initCOP0()
+{
+    s_iLastCOP0Cycle = 0;
+    s_iLastPERFCycle[0] = 0;
+    s_iLastPERFCycle[1] = 0;
+}
+
 // Updates the CPU's mode of operation (either, Kernel, Supervisor, or User modes).
 // Currently the different modes are not implemented.
 // Given this function is called so much, it's commented out for now. (rama)
diff --git a/pcsx2/pcsx2/Counters.cpp b/pcsx2/pcsx2/Counters.cpp
index 3107707..a44a8d7 100644
--- a/pcsx2/pcsx2/Counters.cpp
+++ b/pcsx2/pcsx2/Counters.cpp
@@ -53,6 +53,12 @@ SyncCounter vsyncCounter;
 u32 nextsCounter;	// records the cpuRegs.cycle value of the last call to rcntUpdate()
 s32 nextCounter;	// delta from nextsCounter, in cycles, until the next rcntUpdate()
 
+void initCounters()
+{
+    gates = 0;
+    g_FrameCount = 0;
+}
+
 // Forward declarations needed because C/C++ both are wimpy single-pass compilers.
 
 static void rcntStartGate(bool mode, u32 sCycle);
diff --git a/pcsx2/pcsx2/DebugTools/Breakpoints.cpp b/pcsx2/pcsx2/DebugTools/Breakpoints.cpp
index 8ac1984..3533ae0 100644
--- a/pcsx2/pcsx2/DebugTools/Breakpoints.cpp
+++ b/pcsx2/pcsx2/DebugTools/Breakpoints.cpp
@@ -21,12 +21,12 @@
 #include "../R5900.h"
 #include "../System.h"
 
-std::vector<BreakPoint> CBreakPoints::breakPoints_;
-u32 CBreakPoints::breakSkipFirstAt_ = 0;
-u64 CBreakPoints::breakSkipFirstTicks_ = 0;
-std::vector<MemCheck> CBreakPoints::memChecks_;
-std::vector<MemCheck *> CBreakPoints::cleanupMemChecks_;
-bool CBreakPoints::breakpointTriggered_ = false;
+std::vector<BreakPoint> PCBreakPoints::breakPoints_;
+u32 PCBreakPoints::breakSkipFirstAt_ = 0;
+u64 PCBreakPoints::breakSkipFirstTicks_ = 0;
+std::vector<PMemCheck> PCBreakPoints::memChecks_;
+std::vector<PMemCheck *> PCBreakPoints::cleanupMemChecks_;
+bool PCBreakPoints::breakpointTriggered_ = false;
 
 // called from the dynarec
 u32 __fastcall standardizeBreakpointAddress(u32 addr)
@@ -45,7 +45,7 @@ u32 __fastcall standardizeBreakpointAddress(u32 addr)
 	return addr;
 }
 
-MemCheck::MemCheck() :
+PMemCheck::PMemCheck() :
 	start(0),
 	end(0),
 	cond(MEMCHECK_READWRITE),
@@ -57,11 +57,11 @@ MemCheck::MemCheck() :
 	numHits = 0;
 }
 
-void MemCheck::Log(u32 addr, bool write, int size, u32 pc)
+void PMemCheck::Log(u32 addr, bool write, int size, u32 pc)
 {
 }
 
-void MemCheck::Action(u32 addr, bool write, int size, u32 pc)
+void PMemCheck::Action(u32 addr, bool write, int size, u32 pc)
 {
 	int mask = write ? MEMCHECK_WRITE : MEMCHECK_READ;
 	if (cond & mask)
@@ -77,7 +77,7 @@ void MemCheck::Action(u32 addr, bool write, int size, u32 pc)
 	}
 }
 
-void MemCheck::JitBefore(u32 addr, bool write, int size, u32 pc)
+void PMemCheck::JitBefore(u32 addr, bool write, int size, u32 pc)
 {
 	int mask = MEMCHECK_WRITE | MEMCHECK_WRITE_ONCHANGE;
 	if (write && (cond & mask) == mask)
@@ -96,14 +96,14 @@ void MemCheck::JitBefore(u32 addr, bool write, int size, u32 pc)
 	}
 }
 
-void MemCheck::JitCleanup()
+void PMemCheck::JitCleanup()
 {
 	if (lastAddr == 0 || lastPC == 0)
 		return;
 	/*
 	// Here's the tricky part: would this have changed memory?
 	// Note that it did not actually get written.
-	bool changed = MIPSAnalyst::OpWouldChangeMemory(lastPC, lastAddr);
+	bool changed = PMIPSAnalyst::OpWouldChangeMemory(lastPC, lastAddr);
 	if (changed)
 	{
 		++numHits;
@@ -113,14 +113,14 @@ void MemCheck::JitCleanup()
 	// Resume if it should not have gone to stepping, or if it did not change.
 	if ((!(result & MEMCHECK_BREAK) || !changed) && coreState == CORE_STEPPING)
 	{
-		CBreakPoints::SetSkipFirst(lastPC);
+		PCBreakPoints::SetSkipFirst(lastPC);
 		Core_EnableStepping(false);
 	}
 	else
 		host->SetDebugMode(true);*/
 }
 
-size_t CBreakPoints::FindBreakpoint(u32 addr, bool matchTemp, bool temp)
+size_t PCBreakPoints::FindBreakpoint(u32 addr, bool matchTemp, bool temp)
 {
 	addr = standardizeBreakpointAddress(addr);
 
@@ -134,7 +134,7 @@ size_t CBreakPoints::FindBreakpoint(u32 addr, bool matchTemp, bool temp)
 	return INVALID_BREAKPOINT;
 }
 
-size_t CBreakPoints::FindMemCheck(u32 start, u32 end)
+size_t PCBreakPoints::FindMemCheck(u32 start, u32 end)
 {
 	start = standardizeBreakpointAddress(start);
 	end = standardizeBreakpointAddress(end);
@@ -150,7 +150,7 @@ size_t CBreakPoints::FindMemCheck(u32 start, u32 end)
 	return INVALID_MEMCHECK;
 }
 
-bool CBreakPoints::IsAddressBreakPoint(u32 addr)
+bool PCBreakPoints::IsAddressBreakPoint(u32 addr)
 {
 	size_t bp = FindBreakpoint(addr);
 	if (bp != INVALID_BREAKPOINT && breakPoints_[bp].enabled)
@@ -160,7 +160,7 @@ bool CBreakPoints::IsAddressBreakPoint(u32 addr)
 	return bp != INVALID_BREAKPOINT && breakPoints_[bp].enabled;
 }
 
-bool CBreakPoints::IsAddressBreakPoint(u32 addr, bool* enabled)
+bool PCBreakPoints::IsAddressBreakPoint(u32 addr, bool* enabled)
 {
 	size_t bp = FindBreakpoint(addr);
 	if (bp == INVALID_BREAKPOINT) return false;
@@ -168,13 +168,13 @@ bool CBreakPoints::IsAddressBreakPoint(u32 addr, bool* enabled)
 	return true;
 }
 
-bool CBreakPoints::IsTempBreakPoint(u32 addr)
+bool PCBreakPoints::IsTempBreakPoint(u32 addr)
 {
 	size_t bp = FindBreakpoint(addr, true, true);
 	return bp != INVALID_BREAKPOINT;
 }
 
-void CBreakPoints::AddBreakPoint(u32 addr, bool temp)
+void PCBreakPoints::AddBreakPoint(u32 addr, bool temp)
 {
 	size_t bp = FindBreakpoint(addr, true, temp);
 	if (bp == INVALID_BREAKPOINT)
@@ -195,7 +195,7 @@ void CBreakPoints::AddBreakPoint(u32 addr, bool temp)
 	}
 }
 
-void CBreakPoints::RemoveBreakPoint(u32 addr)
+void PCBreakPoints::RemoveBreakPoint(u32 addr)
 {
 	size_t bp = FindBreakpoint(addr);
 	if (bp != INVALID_BREAKPOINT)
@@ -211,7 +211,7 @@ void CBreakPoints::RemoveBreakPoint(u32 addr)
 	}
 }
 
-void CBreakPoints::ChangeBreakPoint(u32 addr, bool status)
+void PCBreakPoints::ChangeBreakPoint(u32 addr, bool status)
 {
 	size_t bp = FindBreakpoint(addr);
 	if (bp != INVALID_BREAKPOINT)
@@ -221,7 +221,7 @@ void CBreakPoints::ChangeBreakPoint(u32 addr, bool status)
 	}
 }
 
-void CBreakPoints::ClearAllBreakPoints()
+void PCBreakPoints::ClearAllBreakPoints()
 {
 	if (!breakPoints_.empty())
 	{
@@ -230,7 +230,7 @@ void CBreakPoints::ClearAllBreakPoints()
 	}
 }
 
-void CBreakPoints::ClearTemporaryBreakPoints()
+void PCBreakPoints::ClearTemporaryBreakPoints()
 {
 	if (breakPoints_.empty())
 		return;
@@ -245,7 +245,7 @@ void CBreakPoints::ClearTemporaryBreakPoints()
 	}
 }
 
-void CBreakPoints::ChangeBreakPointAddCond(u32 addr, const BreakPointCond &cond)
+void PCBreakPoints::ChangeBreakPointAddCond(u32 addr, const BreakPointCond &cond)
 {
 	size_t bp = FindBreakpoint(addr, true, false);
 	if (bp != INVALID_BREAKPOINT)
@@ -256,7 +256,7 @@ void CBreakPoints::ChangeBreakPointAddCond(u32 addr, const BreakPointCond &cond)
 	}
 }
 
-void CBreakPoints::ChangeBreakPointRemoveCond(u32 addr)
+void PCBreakPoints::ChangeBreakPointRemoveCond(u32 addr)
 {
 	size_t bp = FindBreakpoint(addr, true, false);
 	if (bp != INVALID_BREAKPOINT)
@@ -266,7 +266,7 @@ void CBreakPoints::ChangeBreakPointRemoveCond(u32 addr)
 	}
 }
 
-BreakPointCond *CBreakPoints::GetBreakPointCondition(u32 addr)
+BreakPointCond *PCBreakPoints::GetBreakPointCondition(u32 addr)
 {
 	size_t bp = FindBreakpoint(addr, true, true);
 	//temp breakpoints are unconditional
@@ -279,7 +279,7 @@ BreakPointCond *CBreakPoints::GetBreakPointCondition(u32 addr)
 	return NULL;
 }
 
-void CBreakPoints::AddMemCheck(u32 start, u32 end, MemCheckCondition cond, MemCheckResult result)
+void PCBreakPoints::AddMemCheck(u32 start, u32 end, MemCheckCondition cond, MemCheckResult result)
 {
 	// This will ruin any pending memchecks.
 	cleanupMemChecks_.clear();
@@ -287,7 +287,7 @@ void CBreakPoints::AddMemCheck(u32 start, u32 end, MemCheckCondition cond, MemCh
 	size_t mc = FindMemCheck(start, end);
 	if (mc == INVALID_MEMCHECK)
 	{
-		MemCheck check;
+		PMemCheck check;
 		check.start = start;
 		check.end = end;
 		check.cond = cond;
@@ -304,7 +304,7 @@ void CBreakPoints::AddMemCheck(u32 start, u32 end, MemCheckCondition cond, MemCh
 	}
 }
 
-void CBreakPoints::RemoveMemCheck(u32 start, u32 end)
+void PCBreakPoints::RemoveMemCheck(u32 start, u32 end)
 {
 	// This will ruin any pending memchecks.
 	cleanupMemChecks_.clear();
@@ -317,7 +317,7 @@ void CBreakPoints::RemoveMemCheck(u32 start, u32 end)
 	}
 }
 
-void CBreakPoints::ChangeMemCheck(u32 start, u32 end, MemCheckCondition cond, MemCheckResult result)
+void PCBreakPoints::ChangeMemCheck(u32 start, u32 end, MemCheckCondition cond, MemCheckResult result)
 {
 	size_t mc = FindMemCheck(start, end);
 	if (mc != INVALID_MEMCHECK)
@@ -328,7 +328,7 @@ void CBreakPoints::ChangeMemCheck(u32 start, u32 end, MemCheckCondition cond, Me
 	}
 }
 
-void CBreakPoints::ClearAllMemChecks()
+void PCBreakPoints::ClearAllMemChecks()
 {
 	// This will ruin any pending memchecks.
 	cleanupMemChecks_.clear();
@@ -340,13 +340,13 @@ void CBreakPoints::ClearAllMemChecks()
 	}
 }
 
-void CBreakPoints::SetSkipFirst(u32 pc)
+void PCBreakPoints::SetSkipFirst(u32 pc)
 {
 	breakSkipFirstAt_ = standardizeBreakpointAddress(pc);
 	breakSkipFirstTicks_ = r5900Debug.getCycles();
 }
 
-u32 CBreakPoints::CheckSkipFirst(u32 cmpPc)
+u32 PCBreakPoints::CheckSkipFirst(u32 cmpPc)
 {
 	cmpPc = standardizeBreakpointAddress(cmpPc);
 	u32 pc = breakSkipFirstAt_;
@@ -355,12 +355,12 @@ u32 CBreakPoints::CheckSkipFirst(u32 cmpPc)
 	return 0;
 }
 
-const std::vector<MemCheck> CBreakPoints::GetMemCheckRanges()
+const std::vector<PMemCheck> PCBreakPoints::GetMemCheckRanges()
 {
-	std::vector<MemCheck> ranges = memChecks_;
+	std::vector<PMemCheck> ranges = memChecks_;
 	for (auto it = memChecks_.begin(), end = memChecks_.end(); it != end; ++it)
 	{
-		MemCheck check = *it;
+		PMemCheck check = *it;
 		// Toggle the cached part of the address.
 		check.start ^= 0x40000000;
 		if (check.end != 0)
@@ -371,12 +371,12 @@ const std::vector<MemCheck> CBreakPoints::GetMemCheckRanges()
 	return ranges;
 }
 
-const std::vector<MemCheck> CBreakPoints::GetMemChecks()
+const std::vector<PMemCheck> PCBreakPoints::GetMemChecks()
 {
 	return memChecks_;
 }
 
-const std::vector<BreakPoint> CBreakPoints::GetBreakpoints()
+const std::vector<BreakPoint> PCBreakPoints::GetBreakpoints()
 {
 	return breakPoints_;
 }
@@ -385,7 +385,7 @@ const std::vector<BreakPoint> CBreakPoints::GetBreakpoints()
 #include "App.h"
 #include "Debugger/DisassemblyDialog.h"
 
-void CBreakPoints::Update(u32 addr)
+void PCBreakPoints::Update(u32 addr)
 {
 	bool resume = false;
 	if (!r5900Debug.isCpuPaused())
diff --git a/pcsx2/pcsx2/DebugTools/Breakpoints.h b/pcsx2/pcsx2/DebugTools/Breakpoints.h
index 1da2045..57e9a42 100644
--- a/pcsx2/pcsx2/DebugTools/Breakpoints.h
+++ b/pcsx2/pcsx2/DebugTools/Breakpoints.h
@@ -79,9 +79,9 @@ enum MemCheckResult
 	MEMCHECK_BOTH = 0x03,
 };
 
-struct MemCheck
+struct PMemCheck
 {
-	MemCheck();
+	PMemCheck();
 	u32 start;
 	u32 end;
 
@@ -100,7 +100,7 @@ struct MemCheck
 
 	void Log(u32 addr, bool write, int size, u32 pc);
 
-	bool operator == (const MemCheck &other) const {
+	bool operator == (const PMemCheck &other) const {
 		return start == other.start && end == other.end;
 	}
 };
@@ -108,7 +108,7 @@ struct MemCheck
 // BreakPoints cannot overlap, only one is allowed per address.
 // MemChecks can overlap, as long as their ends are different.
 // WARNING: MemChecks are not used in the interpreter or HLE currently.
-class CBreakPoints
+class PCBreakPoints
 {
 public:
 	static const size_t INVALID_BREAKPOINT = -1;
@@ -137,9 +137,9 @@ public:
 	static u32 CheckSkipFirst(u32 pc);
 
 	// Includes uncached addresses.
-	static const std::vector<MemCheck> GetMemCheckRanges();
+	static const std::vector<PMemCheck> GetMemCheckRanges();
 
-	static const std::vector<MemCheck> GetMemChecks();
+	static const std::vector<PMemCheck> GetMemChecks();
 	static const std::vector<BreakPoint> GetBreakpoints();
 	static size_t GetNumMemchecks() { return memChecks_.size(); }
 
@@ -158,8 +158,8 @@ private:
 	static u64 breakSkipFirstTicks_;
 	static bool breakpointTriggered_;
 
-	static std::vector<MemCheck> memChecks_;
-	static std::vector<MemCheck *> cleanupMemChecks_;
+	static std::vector<PMemCheck> memChecks_;
+	static std::vector<PMemCheck *> cleanupMemChecks_;
 };
 
 
diff --git a/pcsx2/pcsx2/DebugTools/DisassemblyManager.cpp b/pcsx2/pcsx2/DebugTools/DisassemblyManager.cpp
index d20f55a..7128a89 100644
--- a/pcsx2/pcsx2/DebugTools/DisassemblyManager.cpp
+++ b/pcsx2/pcsx2/DebugTools/DisassemblyManager.cpp
@@ -24,9 +24,9 @@
 #include "Debug.h"
 #include "MIPSAnalyst.h"
 
-int DisassemblyManager::maxParamChars = 29;
+int PDisassemblyManager::maxParamChars = 29;
 
-bool isInInterval(u32 start, u32 size, u32 value)
+bool PisInInterval(u32 start, u32 size, u32 value)
 {
 	return start <= value && value <= (start+size-1);
 }
@@ -44,7 +44,7 @@ static u32 computeHash(u32 address, u32 size)
 }
 
 
-void parseDisasm(const char* disasm, char* opcode, char* arguments, bool insertSymbols)
+void PparseDisasm(const char* disasm, char* opcode, char* arguments, bool insertSymbols)
 {
 	if (*disasm == '(')
 	{
@@ -103,7 +103,7 @@ void parseDisasm(const char* disasm, char* opcode, char* arguments, bool insertS
 	*arguments = 0;
 }
 
-std::map<u32,DisassemblyEntry*>::iterator findDisassemblyEntry(std::map<u32,DisassemblyEntry*>& entries, u32 address, bool exact)
+std::map<u32,DisassemblyEntry*>::iterator PfindDisassemblyEntry(std::map<u32,DisassemblyEntry*>& entries, u32 address, bool exact)
 {
 	if (exact)
 		return entries.find(address);
@@ -116,21 +116,21 @@ std::map<u32,DisassemblyEntry*>::iterator findDisassemblyEntry(std::map<u32,Disa
 	if (it != entries.end())
 	{
 		// it may be an exact match
-		if (isInInterval(it->second->getLineAddress(0),it->second->getTotalSize(),address))
+		if (PisInInterval(it->second->getLineAddress(0),it->second->getTotalSize(),address))
 			return it;
 
 		// otherwise it may point to the next
 		if (it != entries.begin())
 		{
 			it--;
-			if (isInInterval(it->second->getLineAddress(0),it->second->getTotalSize(),address))
+			if (PisInInterval(it->second->getLineAddress(0),it->second->getTotalSize(),address))
 				return it;
 		}
 	}
 
 	// check last entry manually
 	auto rit = entries.rbegin();
-	if (isInInterval(rit->second->getLineAddress(0),rit->second->getTotalSize(),address))
+	if (PisInInterval(rit->second->getLineAddress(0),rit->second->getTotalSize(),address))
 	{
 		return (++rit).base();
 	}
@@ -139,7 +139,7 @@ std::map<u32,DisassemblyEntry*>::iterator findDisassemblyEntry(std::map<u32,Disa
 	return entries.end();
 }
 
-void DisassemblyManager::analyze(u32 address, u32 size = 1024)
+void PDisassemblyManager::analyze(u32 address, u32 size = 1024)
 {
 	if (!cpu->isAlive())
 		return;
@@ -151,7 +151,7 @@ void DisassemblyManager::analyze(u32 address, u32 size = 1024)
 
 	while (address < end && start <= address)
 	{
-		auto it = findDisassemblyEntry(entries,address,false);
+		auto it = PfindDisassemblyEntry(entries,address,false);
 		if (it != entries.end())
 		{
 			DisassemblyEntry* entry = it->second;
@@ -166,7 +166,7 @@ void DisassemblyManager::analyze(u32 address, u32 size = 1024)
 			if (address % 4)
 			{
 				u32 next = std::min<u32>((address+3) & ~3,symbolMap.GetNextSymbolAddress(address,ST_ALL));
-				DisassemblyData* data = new DisassemblyData(cpu,address,next-address,DATATYPE_BYTE);
+				PDisassemblyData* data = new PDisassemblyData(cpu,address,next-address,DATATYPE_BYTE);
 				entries[address] = data;
 				address = next;
 				continue;
@@ -180,14 +180,14 @@ void DisassemblyManager::analyze(u32 address, u32 size = 1024)
 
 				if (alignedNext != address)
 				{
-					DisassemblyOpcode* opcode = new DisassemblyOpcode(cpu,address,(alignedNext-address)/4);
+					PDisassemblyOpcode* opcode = new PDisassemblyOpcode(cpu,address,(alignedNext-address)/4);
 					entries[address] = opcode;
 				}
 
-				DisassemblyData* data = new DisassemblyData(cpu,address,next-alignedNext,DATATYPE_BYTE);
+				PDisassemblyData* data = new PDisassemblyData(cpu,address,next-alignedNext,DATATYPE_BYTE);
 				entries[alignedNext] = data;
 			} else {
-				DisassemblyOpcode* opcode = new DisassemblyOpcode(cpu,address,(next-address)/4);
+				PDisassemblyOpcode* opcode = new PDisassemblyOpcode(cpu,address,(next-address)/4);
 				entries[address] = opcode;
 			}
 
@@ -199,14 +199,14 @@ void DisassemblyManager::analyze(u32 address, u32 size = 1024)
 		{
 		case ST_FUNCTION:
 			{
-				DisassemblyFunction* function = new DisassemblyFunction(cpu,info.address,info.size);
+				PDisassemblyFunction* function = new PDisassemblyFunction(cpu,info.address,info.size);
 				entries[info.address] = function;
 				address = info.address+info.size;
 			}
 			break;
 		case ST_DATA:
 			{
-				DisassemblyData* data = new DisassemblyData(cpu,info.address,info.size,symbolMap.GetDataType(info.address));
+				PDisassemblyData* data = new PDisassemblyData(cpu,info.address,info.size,symbolMap.GetDataType(info.address));
 				entries[info.address] = data;
 				address = info.address+info.size;
 			}
@@ -218,11 +218,11 @@ void DisassemblyManager::analyze(u32 address, u32 size = 1024)
 
 }
 
-std::vector<BranchLine> DisassemblyManager::getBranchLines(u32 start, u32 size)
+std::vector<BranchLine> PDisassemblyManager::getBranchLines(u32 start, u32 size)
 {
 	std::vector<BranchLine> result;
 	
-	auto it = findDisassemblyEntry(entries,start,false);
+	auto it = PfindDisassemblyEntry(entries,start,false);
 	if (it != entries.end())
 	{
 		do 
@@ -235,13 +235,13 @@ std::vector<BranchLine> DisassemblyManager::getBranchLines(u32 start, u32 size)
 	return result;
 }
 
-void DisassemblyManager::getLine(u32 address, bool insertSymbols, DisassemblyLineInfo& dest)
+void PDisassemblyManager::getLine(u32 address, bool insertSymbols, DisassemblyLineInfo& dest)
 {
-	auto it = findDisassemblyEntry(entries,address,false);
+	auto it = PfindDisassemblyEntry(entries,address,false);
 	if (it == entries.end())
 	{
 		analyze(address);
-		it = findDisassemblyEntry(entries,address,false);
+		it = PfindDisassemblyEntry(entries,address,false);
 
 		if (it == entries.end())
 		{
@@ -267,13 +267,13 @@ void DisassemblyManager::getLine(u32 address, bool insertSymbols, DisassemblyLin
 	dest.params = "Disassembly failure";
 }
 
-u32 DisassemblyManager::getStartAddress(u32 address)
+u32 PDisassemblyManager::getStartAddress(u32 address)
 {
-	auto it = findDisassemblyEntry(entries,address,false);
+	auto it = PfindDisassemblyEntry(entries,address,false);
 	if (it == entries.end())
 	{
 		analyze(address);
-		it = findDisassemblyEntry(entries,address,false);
+		it = PfindDisassemblyEntry(entries,address,false);
 		if (it == entries.end())
 			return address;
 	}
@@ -283,11 +283,11 @@ u32 DisassemblyManager::getStartAddress(u32 address)
 	return entry->getLineAddress(line);
 }
 
-u32 DisassemblyManager::getNthPreviousAddress(u32 address, int n)
+u32 PDisassemblyManager::getNthPreviousAddress(u32 address, int n)
 {
 	while (cpu->isValidAddress(address))
 	{
-		auto it = findDisassemblyEntry(entries,address,false);
+		auto it = PfindDisassemblyEntry(entries,address,false);
 	
 		while (it != entries.end())
 		{
@@ -300,7 +300,7 @@ u32 DisassemblyManager::getNthPreviousAddress(u32 address, int n)
 
 			address = entry->getLineAddress(0)-1;
 			n -= oldLineNum+1;
-			it = findDisassemblyEntry(entries,address,false);
+			it = PfindDisassemblyEntry(entries,address,false);
 		}
 	
 		analyze(address-127,128);
@@ -309,11 +309,11 @@ u32 DisassemblyManager::getNthPreviousAddress(u32 address, int n)
 	return address-n*4;
 }
 
-u32 DisassemblyManager::getNthNextAddress(u32 address, int n)
+u32 PDisassemblyManager::getNthNextAddress(u32 address, int n)
 {
 	while (cpu->isValidAddress(address))
 	{
-		auto it = findDisassemblyEntry(entries,address,false);
+		auto it = PfindDisassemblyEntry(entries,address,false);
 	
 		while (it != entries.end())
 		{
@@ -327,7 +327,7 @@ u32 DisassemblyManager::getNthNextAddress(u32 address, int n)
 
 			address = entry->getLineAddress(0)+entry->getTotalSize();
 			n -= (oldNumLines-oldLineNum);
-			it = findDisassemblyEntry(entries,address,false);
+			it = PfindDisassemblyEntry(entries,address,false);
 		}
 
 		analyze(address);
@@ -336,7 +336,7 @@ u32 DisassemblyManager::getNthNextAddress(u32 address, int n)
 	return address+n*4;
 }
 
-void DisassemblyManager::clear()
+void PDisassemblyManager::clear()
 {
 	for (auto it = entries.begin(); it != entries.end(); it++)
 	{
@@ -345,14 +345,14 @@ void DisassemblyManager::clear()
 	entries.clear();
 }
 
-DisassemblyFunction::DisassemblyFunction(DebugInterface* _cpu, u32 _address, u32 _size): address(_address), size(_size)
+PDisassemblyFunction::PDisassemblyFunction(DebugInterface* _cpu, u32 _address, u32 _size): address(_address), size(_size)
 {
 	cpu = _cpu;
 	hash = computeHash(address,size);
 	load();
 }
 
-void DisassemblyFunction::recheck()
+void PDisassemblyFunction::recheck()
 {
 	u32 newHash = computeHash(address,size);
 	if (hash != newHash)
@@ -363,12 +363,12 @@ void DisassemblyFunction::recheck()
 	}
 }
 
-int DisassemblyFunction::getNumLines()
+int PDisassemblyFunction::getNumLines()
 {
 	return (int) lineAddresses.size();
 }
 
-int DisassemblyFunction::getLineNum(u32 address, bool findStart)
+int PDisassemblyFunction::getLineNum(u32 address, bool findStart)
 {
 	if (findStart)
 	{
@@ -397,21 +397,21 @@ int DisassemblyFunction::getLineNum(u32 address, bool findStart)
 	return 0;
 }
 
-u32 DisassemblyFunction::getLineAddress(int line)
+u32 PDisassemblyFunction::getLineAddress(int line)
 {
 	return lineAddresses[line];
 }
 
-bool DisassemblyFunction::disassemble(u32 address, DisassemblyLineInfo& dest, bool insertSymbols)
+bool PDisassemblyFunction::disassemble(u32 address, DisassemblyLineInfo& dest, bool insertSymbols)
 {
-	auto it = findDisassemblyEntry(entries,address,false);
+	auto it = PfindDisassemblyEntry(entries,address,false);
 	if (it == entries.end())
 		return false;
 
 	return it->second->disassemble(address,dest,insertSymbols);
 }
 
-void DisassemblyFunction::getBranchLines(u32 start, u32 size, std::vector<BranchLine>& dest)
+void PDisassemblyFunction::getBranchLines(u32 start, u32 size, std::vector<BranchLine>& dest)
 {
 	u32 end = start+size;
 
@@ -433,7 +433,7 @@ void DisassemblyFunction::getBranchLines(u32 start, u32 size, std::vector<Branch
 
 #define NUM_LANES 16
 
-void DisassemblyFunction::generateBranchLines()
+void PDisassemblyFunction::generateBranchLines()
 {
 	struct LaneInfo
 	{
@@ -451,7 +451,7 @@ void DisassemblyFunction::generateBranchLines()
 
 	for (u32 funcPos = address; funcPos < end; funcPos += 4)
 	{
-		MIPSAnalyst::MipsOpcodeInfo opInfo = MIPSAnalyst::GetOpcodeInfo(cpu,funcPos);
+		PMIPSAnalyst::MipsOpcodeInfo opInfo = PMIPSAnalyst::GetOpcodeInfo(cpu,funcPos);
 
 		bool inFunction = (opInfo.branchTarget >= address && opInfo.branchTarget < end);
 		if (opInfo.isBranch && !opInfo.isBranchToRegister && !opInfo.isLinkedBranch && inFunction)
@@ -503,9 +503,9 @@ void DisassemblyFunction::generateBranchLines()
 	}
 }
 
-void DisassemblyFunction::addOpcodeSequence(u32 start, u32 end)
+void PDisassemblyFunction::addOpcodeSequence(u32 start, u32 end)
 {
-	DisassemblyOpcode* opcode = new DisassemblyOpcode(cpu,start,(end-start)/4);
+	PDisassemblyOpcode* opcode = new PDisassemblyOpcode(cpu,start,(end-start)/4);
 	entries[start] = opcode;
 	for (u32 pos = start; pos < end; pos += 4)
 	{
@@ -513,7 +513,7 @@ void DisassemblyFunction::addOpcodeSequence(u32 start, u32 end)
 	}
 }
 
-void DisassemblyFunction::load()
+void PDisassemblyFunction::load()
 {
 	generateBranchLines();
 
@@ -544,7 +544,7 @@ void DisassemblyFunction::load()
 			if (opcodeSequenceStart != funcPos)
 				addOpcodeSequence(opcodeSequenceStart,funcPos);
 
-			DisassemblyData* data = new DisassemblyData(cpu,funcPos,symbolMap.GetDataSize(funcPos),symbolMap.GetDataType(funcPos));
+			PDisassemblyData* data = new PDisassemblyData(cpu,funcPos,symbolMap.GetDataSize(funcPos),symbolMap.GetDataType(funcPos));
 			entries[funcPos] = data;
 			lineAddresses.push_back(funcPos);
 			funcPos += data->getTotalSize();
@@ -568,7 +568,7 @@ void DisassemblyFunction::load()
 			continue;
 		}
 
-		MIPSAnalyst::MipsOpcodeInfo opInfo = MIPSAnalyst::GetOpcodeInfo(cpu,funcPos);
+		PMIPSAnalyst::MipsOpcodeInfo opInfo = PMIPSAnalyst::GetOpcodeInfo(cpu,funcPos);
 		u32 opAddress = funcPos;
 		funcPos += 4;
 		
@@ -596,56 +596,56 @@ void DisassemblyFunction::load()
 			// also, don't create a macro if something branches into the middle of it
 			if (nextRs == rt && nextRt == rt && branchTargets.find(funcPos) == branchTargets.end())
 			{
-				DisassemblyMacro* macro = NULL;
+				PDisassemblyMacro* macro = NULL;
 				switch (MIPS_GET_OP(next))
 				{
 				case 0x09:	// addiu
-					macro = new DisassemblyMacro(cpu,opAddress);
+					macro = new PDisassemblyMacro(cpu,opAddress);
 					macro->setMacroLi(immediate,rt);
 					funcPos += 4;
 					break;
 				case 0x0D:	// ori
-					macro = new DisassemblyMacro(cpu,opAddress);
+					macro = new PDisassemblyMacro(cpu,opAddress);
 					macro->setMacroLi(immediateOr,rt);
 					funcPos += 4;
 					break;
 				case 0x20:	// lb
-					macro = new DisassemblyMacro(cpu,opAddress);
+					macro = new PDisassemblyMacro(cpu,opAddress);
 					macro->setMacroMemory("lb",immediate,rt,1);
 					funcPos += 4;
 					break;
 				case 0x21:	// lh
-					macro = new DisassemblyMacro(cpu,opAddress);
+					macro = new PDisassemblyMacro(cpu,opAddress);
 					macro->setMacroMemory("lh",immediate,rt,2);
 					funcPos += 4;
 					break;
 				case 0x23:	// lw
-					macro = new DisassemblyMacro(cpu,opAddress);
+					macro = new PDisassemblyMacro(cpu,opAddress);
 					macro->setMacroMemory("lw",immediate,rt,4);
 					funcPos += 4;
 					break;
 				case 0x24:	// lbu
-					macro = new DisassemblyMacro(cpu,opAddress);
+					macro = new PDisassemblyMacro(cpu,opAddress);
 					macro->setMacroMemory("lbu",immediate,rt,1);
 					funcPos += 4;
 					break;
 				case 0x25:	// lhu
-					macro = new DisassemblyMacro(cpu,opAddress);
+					macro = new PDisassemblyMacro(cpu,opAddress);
 					macro->setMacroMemory("lhu",immediate,rt,2);
 					funcPos += 4;
 					break;
 				case 0x28:	// sb
-					macro = new DisassemblyMacro(cpu,opAddress);
+					macro = new PDisassemblyMacro(cpu,opAddress);
 					macro->setMacroMemory("sb",immediate,rt,1);
 					funcPos += 4;
 					break;
 				case 0x29:	// sh
-					macro = new DisassemblyMacro(cpu,opAddress);
+					macro = new PDisassemblyMacro(cpu,opAddress);
 					macro->setMacroMemory("sh",immediate,rt,2);
 					funcPos += 4;
 					break;
 				case 0x2B:	// sw
-					macro = new DisassemblyMacro(cpu,opAddress);
+					macro = new PDisassemblyMacro(cpu,opAddress);
 					macro->setMacroMemory("sw",immediate,rt,4);
 					funcPos += 4;
 					break;
@@ -675,7 +675,7 @@ void DisassemblyFunction::load()
 		addOpcodeSequence(opcodeSequenceStart,funcPos);
 }
 
-void DisassemblyFunction::clear()
+void PDisassemblyFunction::clear()
 {
 	for (auto it = entries.begin(); it != entries.end(); it++)
 	{
@@ -688,21 +688,21 @@ void DisassemblyFunction::clear()
 	hash = 0;
 }
 
-bool DisassemblyOpcode::disassemble(u32 address, DisassemblyLineInfo& dest, bool insertSymbols)
+bool PDisassemblyOpcode::disassemble(u32 address, DisassemblyLineInfo& dest, bool insertSymbols)
 {
 	char opcode[64],arguments[256];
 	
 	std::string dis = cpu->disasm(address,insertSymbols);
-	parseDisasm(dis.c_str(),opcode,arguments,insertSymbols);
+	PparseDisasm(dis.c_str(),opcode,arguments,insertSymbols);
 	dest.type = DISTYPE_OPCODE;
 	dest.name = opcode;
 	dest.params = arguments;
 	dest.totalSize = 4;
-	dest.info = MIPSAnalyst::GetOpcodeInfo(cpu,address);
+	dest.info = PMIPSAnalyst::GetOpcodeInfo(cpu,address);
 	return true;
 }
 
-void DisassemblyOpcode::getBranchLines(u32 start, u32 size, std::vector<BranchLine>& dest)
+void PDisassemblyOpcode::getBranchLines(u32 start, u32 size, std::vector<BranchLine>& dest)
 {
 	if (start < address)
 	{
@@ -716,7 +716,7 @@ void DisassemblyOpcode::getBranchLines(u32 start, u32 size, std::vector<BranchLi
 	int lane = 0;
 	for (u32 pos = start; pos < start+size; pos += 4)
 	{
-		MIPSAnalyst::MipsOpcodeInfo info = MIPSAnalyst::GetOpcodeInfo(cpu,pos);
+		PMIPSAnalyst::MipsOpcodeInfo info = PMIPSAnalyst::GetOpcodeInfo(cpu,pos);
 		if (info.isBranch && !info.isBranchToRegister && !info.isLinkedBranch)
 		{
 			BranchLine line;
@@ -739,7 +739,7 @@ void DisassemblyOpcode::getBranchLines(u32 start, u32 size, std::vector<BranchLi
 }
 
 
-void DisassemblyMacro::setMacroLi(u32 _immediate, u8 _rt)
+void PDisassemblyMacro::setMacroLi(u32 _immediate, u8 _rt)
 {
 	type = MACRO_LI;
 	name = "li";
@@ -748,7 +748,7 @@ void DisassemblyMacro::setMacroLi(u32 _immediate, u8 _rt)
 	numOpcodes = 2;
 }
 
-void DisassemblyMacro::setMacroMemory(std::string _name, u32 _immediate, u8 _rt, int _dataSize)
+void PDisassemblyMacro::setMacroMemory(std::string _name, u32 _immediate, u8 _rt, int _dataSize)
 {
 	type = MACRO_MEMORYIMM;
 	name = _name;
@@ -758,11 +758,11 @@ void DisassemblyMacro::setMacroMemory(std::string _name, u32 _immediate, u8 _rt,
 	numOpcodes = 2;
 }
 
-bool DisassemblyMacro::disassemble(u32 address, DisassemblyLineInfo& dest, bool insertSymbols)
+bool PDisassemblyMacro::disassemble(u32 address, DisassemblyLineInfo& dest, bool insertSymbols)
 {
 	char buffer[64];
 	dest.type = DISTYPE_MACRO;
-	dest.info = MIPSAnalyst::GetOpcodeInfo(cpu,address);
+	dest.info = PMIPSAnalyst::GetOpcodeInfo(cpu,address);
 
 	std::string addressSymbol;
 	switch (type)
@@ -812,14 +812,14 @@ bool DisassemblyMacro::disassemble(u32 address, DisassemblyLineInfo& dest, bool
 }
 
 
-DisassemblyData::DisassemblyData(DebugInterface* _cpu, u32 _address, u32 _size, DataType _type): address(_address), size(_size), type(_type)
+PDisassemblyData::PDisassemblyData(DebugInterface* _cpu, u32 _address, u32 _size, DataType _type): address(_address), size(_size), type(_type)
 {
 	cpu = _cpu;
 	hash = computeHash(address,size);
 	createLines();
 }
 
-void DisassemblyData::recheck()
+void PDisassemblyData::recheck()
 {
 	u32 newHash = computeHash(address,size);
 	if (newHash != hash)
@@ -829,7 +829,7 @@ void DisassemblyData::recheck()
 	}
 }
 
-bool DisassemblyData::disassemble(u32 address, DisassemblyLineInfo& dest, bool insertSymbols)
+bool PDisassemblyData::disassemble(u32 address, DisassemblyLineInfo& dest, bool insertSymbols)
 {
 	dest.type = DISTYPE_DATA;
 
@@ -860,7 +860,7 @@ bool DisassemblyData::disassemble(u32 address, DisassemblyLineInfo& dest, bool i
 	return true;
 }
 
-int DisassemblyData::getLineNum(u32 address, bool findStart)
+int PDisassemblyData::getLineNum(u32 address, bool findStart)
 {
 	auto it = lines.upper_bound(address);
 	if (it != lines.end())
@@ -874,14 +874,14 @@ int DisassemblyData::getLineNum(u32 address, bool findStart)
 	return lines.rbegin()->second.lineNum;
 }
 
-void DisassemblyData::createLines()
+void PDisassemblyData::createLines()
 {
 	lines.clear();
 	lineAddresses.clear();
 
 	u32 pos = address;
 	u32 end = address+size;
-	u32 maxChars = DisassemblyManager::getMaxParamChars();
+	u32 maxChars = PDisassemblyManager::getMaxParamChars();
 	
 	std::string currentLine;
 	u32 currentLineStart = pos;
diff --git a/pcsx2/pcsx2/DebugTools/DisassemblyManager.h b/pcsx2/pcsx2/DebugTools/DisassemblyManager.h
index c4d5cf2..6140be5 100644
--- a/pcsx2/pcsx2/DebugTools/DisassemblyManager.h
+++ b/pcsx2/pcsx2/DebugTools/DisassemblyManager.h
@@ -26,7 +26,7 @@ enum DisassemblyLineType { DISTYPE_OPCODE, DISTYPE_MACRO, DISTYPE_DATA, DISTYPE_
 struct DisassemblyLineInfo
 {
 	DisassemblyLineType type;
-	MIPSAnalyst::MipsOpcodeInfo info;
+	PMIPSAnalyst::MipsOpcodeInfo info;
 	std::string name;
 	std::string params;
 	u32 totalSize;
@@ -62,10 +62,10 @@ public:
 	virtual void getBranchLines(u32 start, u32 size, std::vector<BranchLine>& dest) { };
 };
 
-class DisassemblyFunction: public DisassemblyEntry
+class PDisassemblyFunction: public DisassemblyEntry
 {
 public:
-	DisassemblyFunction(DebugInterface* _cpu, u32 _address, u32 _size);
+	PDisassemblyFunction(DebugInterface* _cpu, u32 _address, u32 _size);
 	virtual void recheck();
 	virtual int getNumLines();
 	virtual int getLineNum(u32 address, bool findStart);
@@ -88,11 +88,11 @@ private:
 	std::vector<u32> lineAddresses;
 };
 
-class DisassemblyOpcode: public DisassemblyEntry
+class PDisassemblyOpcode: public DisassemblyEntry
 {
 public:
-	DisassemblyOpcode(DebugInterface* _cpu, u32 _address, int _num): cpu(_cpu), address(_address), num(_num) { };
-	virtual ~DisassemblyOpcode() { };
+	PDisassemblyOpcode(DebugInterface* _cpu, u32 _address, int _num): cpu(_cpu), address(_address), num(_num) { };
+	virtual ~PDisassemblyOpcode() { };
 	virtual void recheck() { };
 	virtual int getNumLines() { return num; };
 	virtual int getLineNum(u32 address, bool findStart) { return (address-this->address)/4; };
@@ -107,12 +107,12 @@ private:
 };
 
 
-class DisassemblyMacro: public DisassemblyEntry
+class PDisassemblyMacro: public DisassemblyEntry
 {
 public:
-	DisassemblyMacro(DebugInterface* _cpu, u32 _address):
+	PDisassemblyMacro(DebugInterface* _cpu, u32 _address):
 		cpu(_cpu), type(MACRO_LI), name(), immediate(0), address(_address), numOpcodes(0), rt(0), dataSize(0) { };
-	virtual ~DisassemblyMacro() { };
+	virtual ~PDisassemblyMacro() { };
 
 	void setMacroLi(u32 _immediate, u8 _rt);
 	void setMacroMemory(std::string _name, u32 _immediate, u8 _rt, int _dataSize);
@@ -137,11 +137,11 @@ private:
 };
 
 
-class DisassemblyData: public DisassemblyEntry
+class PDisassemblyData: public DisassemblyEntry
 {
 public:
-	DisassemblyData(DebugInterface* _cpu, u32 _address, u32 _size, DataType _type);
-	virtual ~DisassemblyData() { };
+	PDisassemblyData(DebugInterface* _cpu, u32 _address, u32 _size, DataType _type);
+	virtual ~PDisassemblyData() { };
 
 	virtual void recheck();
 	virtual int getNumLines() { return (int)lines.size(); };
@@ -190,7 +190,7 @@ private:
 
 class DebugInterface;
 
-class DisassemblyManager
+class PDisassemblyManager
 {
 public:
 	void clear();
@@ -213,4 +213,4 @@ private:
 	static int maxParamChars;
 };
 
-bool isInInterval(u32 start, u32 size, u32 value);
+bool PisInInterval(u32 start, u32 size, u32 value);
diff --git a/pcsx2/pcsx2/DebugTools/ExpressionParser.cpp b/pcsx2/pcsx2/DebugTools/ExpressionParser.cpp
index 9312754..c8f0ae8 100644
--- a/pcsx2/pcsx2/DebugTools/ExpressionParser.cpp
+++ b/pcsx2/pcsx2/DebugTools/ExpressionParser.cpp
@@ -186,7 +186,7 @@ static bool parseFloat(const char *str, int len, u64 &result)
 	return foundDecimal;
 }
 
-ExpressionOpcodeType getExpressionOpcode(const char* str, int& ReturnLen, ExpressionOpcodeType LastOpcode)
+ExpressionOpcodeType PgetExpressionOpcode(const char* str, int& ReturnLen, ExpressionOpcodeType LastOpcode)
 {
 	int longestlen = 0;
 	ExpressionOpcodeType result = EXOP_NONE;
@@ -211,7 +211,7 @@ ExpressionOpcodeType getExpressionOpcode(const char* str, int& ReturnLen, Expres
 	return result;
 }
 
-bool isAlphaNum(char c)
+bool PisAlphaNum(char c)
 {
 	return ((c >= '0' && c <= '9') ||
 		(c >= 'A' && c <= 'Z') ||
@@ -243,7 +243,7 @@ bool initPostfixExpression(const char* infix, IExpressionFunctions* funcs, Postf
 
 		if (first >= '0' && first <= '9')
 		{
-			while (isAlphaNum(infix[infixPos]))
+			while (PisAlphaNum(infix[infixPos]))
 			{
 				subStr[subPos++] = infix[infixPos++];
 			}
@@ -263,7 +263,7 @@ bool initPostfixExpression(const char* infix, IExpressionFunctions* funcs, Postf
 			lastOpcode = EXOP_NUMBER;
 		} else if ((first >= 'a' && first <= 'z') || first == '@')
 		{
-			while (isAlphaNum(infix[infixPos]))
+			while (PisAlphaNum(infix[infixPos]))
 			{
 				subStr[subPos++] = infix[infixPos++];
 			}
@@ -288,7 +288,7 @@ bool initPostfixExpression(const char* infix, IExpressionFunctions* funcs, Postf
 			return false;
 		} else {
 			int len;
-			ExpressionOpcodeType type = getExpressionOpcode(&infix[infixPos],len,lastOpcode);
+			ExpressionOpcodeType type = PgetExpressionOpcode(&infix[infixPos],len,lastOpcode);
 			if (type == EXOP_NONE)
 			{
 				sprintf(expressionError,"Invalid operator at \"%s\"",&infix[infixPos]);
@@ -597,7 +597,7 @@ bool parseExpression(char* exp, IExpressionFunctions* funcs, u64& dest)
 	return parsePostfixExpression(postfix,funcs,dest);
 }
 
-const char* getExpressionError()
+const char* PgetExpressionError()
 {
 	if (expressionError[0] == 0) strcpy(expressionError,"Invalid expression");
 	return expressionError;
diff --git a/pcsx2/pcsx2/DebugTools/ExpressionParser.h b/pcsx2/pcsx2/DebugTools/ExpressionParser.h
index ce43906..04fd253 100644
--- a/pcsx2/pcsx2/DebugTools/ExpressionParser.h
+++ b/pcsx2/pcsx2/DebugTools/ExpressionParser.h
@@ -40,4 +40,4 @@ public:
 bool initPostfixExpression(const char* infix, IExpressionFunctions* funcs, PostfixExpression& dest);
 bool parsePostfixExpression(PostfixExpression& exp, IExpressionFunctions* funcs, u64& dest);
 bool parseExpression(const char* exp, IExpressionFunctions* funcs, u64& dest);
-const char* getExpressionError();
+const char* PgetExpressionError();
diff --git a/pcsx2/pcsx2/DebugTools/MIPSAnalyst.cpp b/pcsx2/pcsx2/DebugTools/MIPSAnalyst.cpp
index fadd8d3..856f2ad 100644
--- a/pcsx2/pcsx2/DebugTools/MIPSAnalyst.cpp
+++ b/pcsx2/pcsx2/DebugTools/MIPSAnalyst.cpp
@@ -22,7 +22,7 @@
 #include "../R5900.h"
 #include "../R5900OpcodeTables.h"
 
-static std::vector<MIPSAnalyst::AnalyzedFunction> functions;
+static std::vector<PMIPSAnalyst::AnalyzedFunction> functions;
 
 #define MIPS_MAKE_J(addr)   (0x08000000 | ((addr)>>2))
 #define MIPS_MAKE_JAL(addr) (0x0C000000 | ((addr)>>2))
@@ -37,7 +37,7 @@ static std::vector<MIPSAnalyst::AnalyzedFunction> functions;
 #define _RS   ((op>>21) & 0x1F)
 #define _RT   ((op>>16) & 0x1F)
 
-namespace MIPSAnalyst
+namespace PMIPSAnalyst
 {
 	u32 GetJumpTarget(u32 addr)
 	{
diff --git a/pcsx2/pcsx2/DebugTools/MIPSAnalyst.h b/pcsx2/pcsx2/DebugTools/MIPSAnalyst.h
index 65fab05..96eb4a9 100644
--- a/pcsx2/pcsx2/DebugTools/MIPSAnalyst.h
+++ b/pcsx2/pcsx2/DebugTools/MIPSAnalyst.h
@@ -26,7 +26,7 @@ class DebugInterface;
 #define MIPS_GET_RT(op) ((op>>16) & 0x1F)
 #define MIPS_GET_RD(op) ((op>>11) & 0x1F)
 
-namespace MIPSAnalyst
+namespace PMIPSAnalyst
 {
 	struct AnalyzedFunction {
 		u32 start;
diff --git a/pcsx2/pcsx2/DebugTools/MipsAssembler.cpp b/pcsx2/pcsx2/DebugTools/MipsAssembler.cpp
index c83ef2a..e8e81f4 100644
--- a/pcsx2/pcsx2/DebugTools/MipsAssembler.cpp
+++ b/pcsx2/pcsx2/DebugTools/MipsAssembler.cpp
@@ -182,7 +182,7 @@ bool MipsAssembleOpcode(const char* line, DebugInterface* cpu, u32 address, u32&
 	char name[64],args[256];
 	SplitLine(line,name,args);
 
-	CMipsInstruction opcode(cpu);
+	PCMipsInstruction opcode(cpu);
 	if (cpu == NULL || !opcode.Load(name,args,(int)address))
 	{
 		errorText = opcode.getErrorMessage();
@@ -367,7 +367,7 @@ bool MipsCheckImmediate(const char* Source, DebugInterface* cpu, int& dest, int&
 	return true;
 }
 
-CMipsInstruction::CMipsInstruction(DebugInterface* cpu) :
+PCMipsInstruction::PCMipsInstruction(DebugInterface* cpu) :
 	Opcode(), NoCheckError(false), Loaded(false), RamPos(0),
 	registers(), immediateType(MIPS_NOIMMEDIATE), immediate(),
 	vfpuSize(0), encoding(0), error()
@@ -375,28 +375,28 @@ CMipsInstruction::CMipsInstruction(DebugInterface* cpu) :
 	this->cpu = cpu;
 }
 
-bool CMipsInstruction::Load(const char* Name, const char* Params, int RamPos)
+bool PCMipsInstruction::Load(const char* Name, const char* Params, int RamPos)
 {
 	bool paramfail = false;
 	NoCheckError = false;
 	this->RamPos = RamPos;
 
-	const MipsArchDefinition& arch = mipsArchs[MARCH_PS2];
-	for (int z = 0; MipsOpcodes[z].name != NULL; z++)
+	const MipsArchDefinition& arch = PmipsArchs[MARCH_PS2];
+	for (int z = 0; PMipsOpcodes[z].name != NULL; z++)
 	{
-		if ((MipsOpcodes[z].archs & arch.supportSets) == 0)
+		if ((PMipsOpcodes[z].archs & arch.supportSets) == 0)
 			continue;
-		if ((MipsOpcodes[z].archs & arch.excludeMask) != 0)
+		if ((PMipsOpcodes[z].archs & arch.excludeMask) != 0)
 			continue;
 
-		if ((MipsOpcodes[z].flags & MO_64BIT) && !(arch.flags & MO_64BIT))
+		if ((PMipsOpcodes[z].flags & MO_64BIT) && !(arch.flags & MO_64BIT))
 			continue;
-		if ((MipsOpcodes[z].flags & MO_FPU) && !(arch.flags & MO_FPU))
+		if ((PMipsOpcodes[z].flags & MO_FPU) && !(arch.flags & MO_FPU))
 			continue;
 
-		if (parseOpcode(MipsOpcodes[z],Name))
+		if (parseOpcode(PMipsOpcodes[z],Name))
 		{
-			if (LoadEncoding(MipsOpcodes[z],Params))
+			if (LoadEncoding(PMipsOpcodes[z],Params))
 			{
 				Loaded = true;
 				return true;
@@ -418,7 +418,7 @@ bool CMipsInstruction::Load(const char* Name, const char* Params, int RamPos)
 }
 
 
-bool CMipsInstruction::parseOpcode(const tMipsOpcode& SourceOpcode, const char* Line)
+bool PCMipsInstruction::parseOpcode(const tMipsOpcode& SourceOpcode, const char* Line)
 {
 	vfpuSize = -1;
 
@@ -460,7 +460,7 @@ bool CMipsInstruction::parseOpcode(const tMipsOpcode& SourceOpcode, const char*
 	return (*Line == 0);
 }
 
-bool CMipsInstruction::LoadEncoding(const tMipsOpcode& SourceOpcode, const char* Line)
+bool PCMipsInstruction::LoadEncoding(const tMipsOpcode& SourceOpcode, const char* Line)
 {
 	int RetLen;
 
@@ -587,7 +587,7 @@ bool CMipsInstruction::LoadEncoding(const tMipsOpcode& SourceOpcode, const char*
 	return true;
 }
 
-void CMipsInstruction::setOmittedRegisters()
+void PCMipsInstruction::setOmittedRegisters()
 {
 	// copy over omitted registers
 	if (Opcode.flags & MO_RSD)
@@ -603,7 +603,7 @@ void CMipsInstruction::setOmittedRegisters()
 		registers.frd = registers.frs;
 }
 
-int getImmediateBits(MipsImmediateType type)
+int PgetImmediateBits(MipsImmediateType type)
 {
 	switch (type)
 	{
@@ -620,7 +620,7 @@ int getImmediateBits(MipsImmediateType type)
 	}
 }
 
-bool CMipsInstruction::Validate()
+bool PCMipsInstruction::Validate()
 {
 	if (RamPos % 4)
 	{
@@ -657,7 +657,7 @@ bool CMipsInstruction::Validate()
 			immediate.value = num >> 2;
 		}
 		
-		int immediateBits = getImmediateBits(immediateType);
+		int immediateBits = PgetImmediateBits(immediateType);
 		unsigned int mask = (0xFFFFFFFF << (32-immediateBits)) >> (32-immediateBits);
 		int digits = (immediateBits+3) / 4;
 
@@ -673,7 +673,7 @@ bool CMipsInstruction::Validate()
 	return true;
 }
 
-void CMipsInstruction::encodeNormal()
+void PCMipsInstruction::encodeNormal()
 {
 	encoding = Opcode.destencoding;
 
@@ -704,7 +704,7 @@ void CMipsInstruction::encodeNormal()
 	}
 }
 
-void CMipsInstruction::Encode()
+void PCMipsInstruction::Encode()
 {
 	encodeNormal();
 }
diff --git a/pcsx2/pcsx2/DebugTools/MipsAssembler.h b/pcsx2/pcsx2/DebugTools/MipsAssembler.h
index b9230c5..5ea1ce0 100644
--- a/pcsx2/pcsx2/DebugTools/MipsAssembler.h
+++ b/pcsx2/pcsx2/DebugTools/MipsAssembler.h
@@ -61,10 +61,10 @@ struct MipsOpcodeRegisters {
 };
 
 
-class CMipsInstruction
+class PCMipsInstruction
 {
 public:
-	CMipsInstruction(DebugInterface* cpu);
+	PCMipsInstruction(DebugInterface* cpu);
 	bool Load(const char* Name, const char* Params, int RamPos);
 	virtual bool Validate();
 	virtual void Encode();
diff --git a/pcsx2/pcsx2/DebugTools/MipsAssemblerTables.cpp b/pcsx2/pcsx2/DebugTools/MipsAssemblerTables.cpp
index 6ae0c3b..73be536 100644
--- a/pcsx2/pcsx2/DebugTools/MipsAssemblerTables.cpp
+++ b/pcsx2/pcsx2/DebugTools/MipsAssemblerTables.cpp
@@ -36,7 +36,7 @@
 // because it's shared between multiple projects, and manually removing the opcodes every
 // time is error prone and makes it harder to maintain. They aren't accessible, so they
 // cause no harm besides appearing here.
-const tMipsOpcode MipsOpcodes[] = {
+const tMipsOpcode PMipsOpcodes[] = {
 //     31---------26---------------------------------------------------0
 //     |  opcode   |                                                   |
 //     ------6----------------------------------------------------------
@@ -442,7 +442,7 @@ const tMipsOpcode MipsOpcodes[] = {
 };
 
 
-const MipsArchDefinition mipsArchs[] = {
+const MipsArchDefinition PmipsArchs[] = {
 	// MARCH_PSX
 	{ "PSX",		MA_MIPS1,							MA_EXPSX,	0 },
 	// MARCH_N64
diff --git a/pcsx2/pcsx2/DebugTools/MipsAssemblerTables.h b/pcsx2/pcsx2/DebugTools/MipsAssemblerTables.h
index 25e50c8..149e608 100644
--- a/pcsx2/pcsx2/DebugTools/MipsAssemblerTables.h
+++ b/pcsx2/pcsx2/DebugTools/MipsAssemblerTables.h
@@ -80,7 +80,7 @@ struct MipsArchDefinition
 	int flags;
 };
 
-extern const MipsArchDefinition mipsArchs[];
+extern const MipsArchDefinition PmipsArchs[];
 
 typedef struct {
 	const char* name;
@@ -90,4 +90,4 @@ typedef struct {
 	int flags;
 } tMipsOpcode;
 
-extern const tMipsOpcode MipsOpcodes[];
+extern const tMipsOpcode PMipsOpcodes[];
diff --git a/pcsx2/pcsx2/DebugTools/SymbolMap.cpp b/pcsx2/pcsx2/DebugTools/SymbolMap.cpp
index e37bdc7..cfaf8e6 100644
--- a/pcsx2/pcsx2/DebugTools/SymbolMap.cpp
+++ b/pcsx2/pcsx2/DebugTools/SymbolMap.cpp
@@ -18,7 +18,7 @@
 #include "SymbolMap.h"
 #include <algorithm>
 
-SymbolMap symbolMap;
+PSymbolMap symbolMap;
 
 #ifdef _WIN32
 #define strcasecmp stricmp
@@ -26,12 +26,12 @@ SymbolMap symbolMap;
 
 #define ARRAY_SIZE(x) (sizeof((x))/sizeof(*(x)))
 
-void SymbolMap::SortSymbols() {
+void PSymbolMap::SortSymbols() {
 	std::lock_guard<std::recursive_mutex> guard(m_lock);
 	AssignFunctionIndices();
 }
 
-void SymbolMap::Clear() {
+void PSymbolMap::Clear() {
 	std::lock_guard<std::recursive_mutex> guard(m_lock);
 	functions.clear();
 	labels.clear();
@@ -44,7 +44,7 @@ void SymbolMap::Clear() {
 }
 
 
-bool SymbolMap::LoadNocashSym(const char *filename) {
+bool PSymbolMap::LoadNocashSym(const char *filename) {
 	std::lock_guard<std::recursive_mutex> guard(m_lock);
 	FILE *f = wxFopen(filename, "r");
 	if (!f)
@@ -102,7 +102,7 @@ bool SymbolMap::LoadNocashSym(const char *filename) {
 	return true;
 }
 
-SymbolType SymbolMap::GetSymbolType(u32 address) const {
+SymbolType PSymbolMap::GetSymbolType(u32 address) const {
 	std::lock_guard<std::recursive_mutex> guard(m_lock);
 	if (activeFunctions.find(address) != activeFunctions.end())
 		return ST_FUNCTION;
@@ -111,7 +111,7 @@ SymbolType SymbolMap::GetSymbolType(u32 address) const {
 	return ST_NONE;
 }
 
-bool SymbolMap::GetSymbolInfo(SymbolInfo *info, u32 address, SymbolType symmask) const {
+bool PSymbolMap::GetSymbolInfo(SymbolInfo *info, u32 address, SymbolType symmask) const {
 	u32 functionAddress = INVALID_ADDRESS;
 	u32 dataAddress = INVALID_ADDRESS;
 
@@ -155,7 +155,7 @@ bool SymbolMap::GetSymbolInfo(SymbolInfo *info, u32 address, SymbolType symmask)
 	return true;
 }
 
-u32 SymbolMap::GetNextSymbolAddress(u32 address, SymbolType symmask) {
+u32 PSymbolMap::GetNextSymbolAddress(u32 address, SymbolType symmask) {
 	std::lock_guard<std::recursive_mutex> guard(m_lock);
 	const auto functionEntry = symmask & ST_FUNCTION ? activeFunctions.upper_bound(address) : activeFunctions.end();
 	const auto dataEntry = symmask & ST_DATA ? activeData.upper_bound(address) : activeData.end();
@@ -172,7 +172,7 @@ u32 SymbolMap::GetNextSymbolAddress(u32 address, SymbolType symmask) {
 		return dataAddress;
 }
 
-std::string SymbolMap::GetDescription(unsigned int address) const {
+std::string PSymbolMap::GetDescription(unsigned int address) const {
 	std::lock_guard<std::recursive_mutex> guard(m_lock);
 	const char* labelName = NULL;
 
@@ -193,7 +193,7 @@ std::string SymbolMap::GetDescription(unsigned int address) const {
 	return descriptionTemp;
 }
 
-std::vector<SymbolEntry> SymbolMap::GetAllSymbols(SymbolType symmask) {
+std::vector<SymbolEntry> PSymbolMap::GetAllSymbols(SymbolType symmask) {
 	std::vector<SymbolEntry> result;
 
 	if (symmask & ST_FUNCTION) {
@@ -225,7 +225,7 @@ std::vector<SymbolEntry> SymbolMap::GetAllSymbols(SymbolType symmask) {
 	return result;
 }
 
-void SymbolMap::AddModule(const char *name, u32 address, u32 size) {
+void PSymbolMap::AddModule(const char *name, u32 address, u32 size) {
 	std::lock_guard<std::recursive_mutex> guard(m_lock);
 
 	for (auto it = modules.begin(), end = modules.end(); it != end; ++it) {
@@ -251,13 +251,13 @@ void SymbolMap::AddModule(const char *name, u32 address, u32 size) {
 	UpdateActiveSymbols();
 }
 
-void SymbolMap::UnloadModule(u32 address, u32 size) {
+void PSymbolMap::UnloadModule(u32 address, u32 size) {
 	std::lock_guard<std::recursive_mutex> guard(m_lock);
 	activeModuleEnds.erase(address + size);
 	UpdateActiveSymbols();
 }
 
-u32 SymbolMap::GetModuleRelativeAddr(u32 address, int moduleIndex) const {
+u32 PSymbolMap::GetModuleRelativeAddr(u32 address, int moduleIndex) const {
 	std::lock_guard<std::recursive_mutex> guard(m_lock);
 	if (moduleIndex == -1) {
 		moduleIndex = GetModuleIndex(address);
@@ -271,7 +271,7 @@ u32 SymbolMap::GetModuleRelativeAddr(u32 address, int moduleIndex) const {
 	return address;
 }
 
-u32 SymbolMap::GetModuleAbsoluteAddr(u32 relative, int moduleIndex) const {
+u32 PSymbolMap::GetModuleAbsoluteAddr(u32 relative, int moduleIndex) const {
 	std::lock_guard<std::recursive_mutex> guard(m_lock);
 	for (auto it = modules.begin(), end = modules.end(); it != end; ++it) {
 		if (it->index == moduleIndex) {
@@ -281,7 +281,7 @@ u32 SymbolMap::GetModuleAbsoluteAddr(u32 relative, int moduleIndex) const {
 	return relative;
 }
 
-int SymbolMap::GetModuleIndex(u32 address) const {
+int PSymbolMap::GetModuleIndex(u32 address) const {
 	std::lock_guard<std::recursive_mutex> guard(m_lock);
 	auto iter = activeModuleEnds.upper_bound(address);
 	if (iter == activeModuleEnds.end())
@@ -289,7 +289,7 @@ int SymbolMap::GetModuleIndex(u32 address) const {
 	return iter->second.index;
 }
 
-bool SymbolMap::IsModuleActive(int moduleIndex) const {
+bool PSymbolMap::IsModuleActive(int moduleIndex) const {
 	if (moduleIndex == 0) {
 		return true;
 	}
@@ -303,7 +303,7 @@ bool SymbolMap::IsModuleActive(int moduleIndex) const {
 	return false;
 }
 
-std::vector<LoadedModuleInfo> SymbolMap::getAllModules() const {
+std::vector<LoadedModuleInfo> PSymbolMap::getAllModules() const {
 	std::lock_guard<std::recursive_mutex> guard(m_lock);
 
 	std::vector<LoadedModuleInfo> result;
@@ -322,7 +322,7 @@ std::vector<LoadedModuleInfo> SymbolMap::getAllModules() const {
 	return result;
 }
 
-void SymbolMap::AddFunction(const char* name, u32 address, u32 size, int moduleIndex) {
+void PSymbolMap::AddFunction(const char* name, u32 address, u32 size, int moduleIndex) {
 	std::lock_guard<std::recursive_mutex> guard(m_lock);
 
 	if (moduleIndex == -1) {
@@ -367,7 +367,7 @@ void SymbolMap::AddFunction(const char* name, u32 address, u32 size, int moduleI
 	AddLabel(name, address, moduleIndex);
 }
 
-u32 SymbolMap::GetFunctionStart(u32 address) const {
+u32 PSymbolMap::GetFunctionStart(u32 address) const {
 	std::lock_guard<std::recursive_mutex> guard(m_lock);
 	auto it = activeFunctions.upper_bound(address);
 	if (it == activeFunctions.end()) {
@@ -394,7 +394,7 @@ u32 SymbolMap::GetFunctionStart(u32 address) const {
 	return INVALID_ADDRESS;
 }
 
-u32 SymbolMap::GetFunctionSize(u32 startAddress) const {
+u32 PSymbolMap::GetFunctionSize(u32 startAddress) const {
 	std::lock_guard<std::recursive_mutex> guard(m_lock);
 	auto it = activeFunctions.find(startAddress);
 	if (it == activeFunctions.end())
@@ -403,7 +403,7 @@ u32 SymbolMap::GetFunctionSize(u32 startAddress) const {
 	return it->second.size;
 }
 
-int SymbolMap::GetFunctionNum(u32 address) const {
+int PSymbolMap::GetFunctionNum(u32 address) const {
 	std::lock_guard<std::recursive_mutex> guard(m_lock);
 	u32 start = GetFunctionStart(address);
 	if (start == INVALID_ADDRESS)
@@ -416,7 +416,7 @@ int SymbolMap::GetFunctionNum(u32 address) const {
 	return it->second.index;
 }
 
-void SymbolMap::AssignFunctionIndices() {
+void PSymbolMap::AssignFunctionIndices() {
 	std::lock_guard<std::recursive_mutex> guard(m_lock);
 	int index = 0;
 	for (auto mod = activeModuleEnds.begin(), modend = activeModuleEnds.end(); mod != modend; ++mod) {
@@ -429,7 +429,7 @@ void SymbolMap::AssignFunctionIndices() {
 	}
 }
 
-void SymbolMap::UpdateActiveSymbols() {
+void PSymbolMap::UpdateActiveSymbols() {
 	// return;   (slow in debug mode)
 	std::lock_guard<std::recursive_mutex> guard(m_lock);
 	std::map<int, u32> activeModuleIndexes;
@@ -471,7 +471,7 @@ void SymbolMap::UpdateActiveSymbols() {
 	AssignFunctionIndices();
 }
 
-bool SymbolMap::SetFunctionSize(u32 startAddress, u32 newSize) {
+bool PSymbolMap::SetFunctionSize(u32 startAddress, u32 newSize) {
 	std::lock_guard<std::recursive_mutex> guard(m_lock);
 
 	auto funcInfo = activeFunctions.find(startAddress);
@@ -488,7 +488,7 @@ bool SymbolMap::SetFunctionSize(u32 startAddress, u32 newSize) {
 	return true;
 }
 
-bool SymbolMap::RemoveFunction(u32 startAddress, bool removeName) {
+bool PSymbolMap::RemoveFunction(u32 startAddress, bool removeName) {
 	std::lock_guard<std::recursive_mutex> guard(m_lock);
 
 	auto it = activeFunctions.find(startAddress);
@@ -517,7 +517,7 @@ bool SymbolMap::RemoveFunction(u32 startAddress, bool removeName) {
 	return true;
 }
 
-void SymbolMap::AddLabel(const char* name, u32 address, int moduleIndex) {
+void PSymbolMap::AddLabel(const char* name, u32 address, int moduleIndex) {
 	std::lock_guard<std::recursive_mutex> guard(m_lock);
 
 	if (moduleIndex == -1) {
@@ -561,7 +561,7 @@ void SymbolMap::AddLabel(const char* name, u32 address, int moduleIndex) {
 	}
 }
 
-void SymbolMap::SetLabelName(const char* name, u32 address, bool updateImmediately) {
+void PSymbolMap::SetLabelName(const char* name, u32 address, bool updateImmediately) {
 	std::lock_guard<std::recursive_mutex> guard(m_lock);
 	auto labelInfo = activeLabels.find(address);
 	if (labelInfo == activeLabels.end()) {
@@ -582,7 +582,7 @@ void SymbolMap::SetLabelName(const char* name, u32 address, bool updateImmediate
 	}
 }
 
-const char *SymbolMap::GetLabelName(u32 address) const {
+const char *PSymbolMap::GetLabelName(u32 address) const {
 	std::lock_guard<std::recursive_mutex> guard(m_lock);
 	auto it = activeLabels.find(address);
 	if (it == activeLabels.end())
@@ -591,7 +591,7 @@ const char *SymbolMap::GetLabelName(u32 address) const {
 	return it->second.name;
 }
 
-const char *SymbolMap::GetLabelNameRel(u32 relAddress, int moduleIndex) const {
+const char *PSymbolMap::GetLabelNameRel(u32 relAddress, int moduleIndex) const {
 	std::lock_guard<std::recursive_mutex> guard(m_lock);
 	auto it = labels.find(std::make_pair(moduleIndex, relAddress));
 	if (it == labels.end())
@@ -600,7 +600,7 @@ const char *SymbolMap::GetLabelNameRel(u32 relAddress, int moduleIndex) const {
 	return it->second.name;
 }
 
-std::string SymbolMap::GetLabelString(u32 address) const {
+std::string PSymbolMap::GetLabelString(u32 address) const {
 	std::lock_guard<std::recursive_mutex> guard(m_lock);
 	const char *label = GetLabelName(address);
 	if (label == NULL)
@@ -608,7 +608,7 @@ std::string SymbolMap::GetLabelString(u32 address) const {
 	return label;
 }
 
-bool SymbolMap::GetLabelValue(const char* name, u32& dest) {
+bool PSymbolMap::GetLabelValue(const char* name, u32& dest) {
 	std::lock_guard<std::recursive_mutex> guard(m_lock);
 	for (auto it = activeLabels.begin(); it != activeLabels.end(); it++) {
 		if (strcasecmp(name, it->second.name) == 0) {
@@ -620,7 +620,7 @@ bool SymbolMap::GetLabelValue(const char* name, u32& dest) {
 	return false;
 }
 
-void SymbolMap::AddData(u32 address, u32 size, DataType type, int moduleIndex) {
+void PSymbolMap::AddData(u32 address, u32 size, DataType type, int moduleIndex) {
 	std::lock_guard<std::recursive_mutex> guard(m_lock);
 
 	if (moduleIndex == -1) {
@@ -664,7 +664,7 @@ void SymbolMap::AddData(u32 address, u32 size, DataType type, int moduleIndex) {
 	}
 }
 
-u32 SymbolMap::GetDataStart(u32 address) const {
+u32 PSymbolMap::GetDataStart(u32 address) const {
 	std::lock_guard<std::recursive_mutex> guard(m_lock);
 	auto it = activeData.upper_bound(address);
 	if (it == activeData.end())
@@ -694,7 +694,7 @@ u32 SymbolMap::GetDataStart(u32 address) const {
 	return INVALID_ADDRESS;
 }
 
-u32 SymbolMap::GetDataSize(u32 startAddress) const {
+u32 PSymbolMap::GetDataSize(u32 startAddress) const {
 	std::lock_guard<std::recursive_mutex> guard(m_lock);
 	auto it = activeData.find(startAddress);
 	if (it == activeData.end())
@@ -702,7 +702,7 @@ u32 SymbolMap::GetDataSize(u32 startAddress) const {
 	return it->second.size;
 }
 
-DataType SymbolMap::GetDataType(u32 startAddress) const {
+DataType PSymbolMap::GetDataType(u32 startAddress) const {
 	std::lock_guard<std::recursive_mutex> guard(m_lock);
 	auto it = activeData.find(startAddress);
 	if (it == activeData.end())
diff --git a/pcsx2/pcsx2/DebugTools/SymbolMap.h b/pcsx2/pcsx2/DebugTools/SymbolMap.h
index 9d9d64b..4b1a74f 100644
--- a/pcsx2/pcsx2/DebugTools/SymbolMap.h
+++ b/pcsx2/pcsx2/DebugTools/SymbolMap.h
@@ -53,9 +53,9 @@ enum DataType {
 	DATATYPE_NONE, DATATYPE_BYTE, DATATYPE_HALFWORD, DATATYPE_WORD, DATATYPE_ASCII
 };
 
-class SymbolMap {
+class PSymbolMap {
 public:
-	SymbolMap() {}
+	PSymbolMap() {}
 	void Clear();
 	void SortSymbols();
 
@@ -148,5 +148,5 @@ private:
 	mutable std::recursive_mutex m_lock;
 };
 
-extern SymbolMap symbolMap;
+extern PSymbolMap symbolMap;
 
diff --git a/pcsx2/pcsx2/EmuCmp.cpp b/pcsx2/pcsx2/EmuCmp.cpp
index 74f241d..b7dcfe6 100644
--- a/pcsx2/pcsx2/EmuCmp.cpp
+++ b/pcsx2/pcsx2/EmuCmp.cpp
@@ -13,8 +13,9 @@
  *  If not, see <http://www.gnu.org/licenses/>.
  */
 
+#include "EmuCmp.h"
 #include "PrecompiledHeader.h"
-#include "../common/include/Utilities/Assertions.h"
+#include "Assertions.h"
 #include "R5900.h"
 #include "VU.h"
 #include "DebugTools/Debug.h"
@@ -25,8 +26,6 @@
 #include <unistd.h>
 #endif
 
-#include "EmuCmp.h"
-
 using namespace EmuCmp;
 
 Config::Mode EmuCmp::mode = Config::Mode::Off;
@@ -109,12 +108,10 @@ done:
 }
 
 void EmuCmp::shutdown() {
-#ifdef __POSIX__
 	if (comms) {
 		fclose(comms);
 		comms = nullptr;
 	}
-#endif
 	mode = Config::Mode::Off;
 }
 
@@ -203,7 +200,8 @@ static void CompareBuffer(void *buffer, int startOffset, int length, const char
 		send(local, length);
 	} else if (mode == Config::Mode::Client) {
 		const int maxStackBuffer = _64kb;
-		u8 *srv = length > maxStackBuffer ? (u8*)malloc(length) : (u8*)alloca(length);
+		u8 srv_[std::min(length, maxStackBuffer)];
+		u8 *srv = length > maxStackBuffer ? (u8*)malloc(length) : srv_;
 		receive(srv, length);
 
 		if (0 != memcmp(srv, local, length)) {
@@ -231,7 +229,7 @@ static void CompareBuffer(void *buffer, int startOffset, int length, const char
 
 #define COMPARE(reg) Compare(servCPU.reg, cpuRegs.reg, #reg, found, pc)
 
-void __fastcall EmuCmp::cmpR5900(u32 pc) {
+void EmuCmp::cmpR5900(u32 pc) {
 	static u32 lastPC = 0;
 	// Example use of CompareBuffer to find bad memory around 0x70001000
 	// CompareBuffer(eeMem->Scratch, 0x1000, 0x500, "Scratch", lastPC);
@@ -282,7 +280,7 @@ void __fastcall EmuCmp::cmpR5900(u32 pc) {
 	lastPC = pc;
 }
 
-void __fastcall EmuCmp::cmpVU(u32 idx, u32 pc) {
+void EmuCmp::cmpVU(u32 idx, u32 pc) {
 	if (!pxAssert(idx == 0 || idx == 1)) { return; }
 	static u32 lastPC[2] = {0};
 	VURegs& regs = vuRegs[idx];
@@ -330,7 +328,8 @@ void EmuCmp::detail::cmpMem(void *mem, int length, const char *description) {
 		send(mem, length);
 	} else {
 		const int maxStackBuffer = _64kb;
-		u8 *srv = length > maxStackBuffer ? (u8*)malloc(length) : (u8*)alloca(length);
+		u8 srv_[std::min(length, maxStackBuffer)];
+		u8 *srv = length > maxStackBuffer ? (u8*)malloc(length) : srv_;
 
 		if (0 != memcmp(srv, mem, length)) {
 			char err[1024];
diff --git a/pcsx2/pcsx2/EmuCmp.h b/pcsx2/pcsx2/EmuCmp.h
index 36842b0..fc0bd64 100644
--- a/pcsx2/pcsx2/EmuCmp.h
+++ b/pcsx2/pcsx2/EmuCmp.h
@@ -15,6 +15,7 @@
 
 #pragma once
 
+#include "PrecompiledHeader.h"
 #include <cstddef>
 
 /**
diff --git a/pcsx2/pcsx2/FiFo.cpp b/pcsx2/pcsx2/FiFo.cpp
index 2b1602a..f0a637e 100644
--- a/pcsx2/pcsx2/FiFo.cpp
+++ b/pcsx2/pcsx2/FiFo.cpp
@@ -24,6 +24,9 @@
 #include "Vif_Dma.h"
 #include "IPU/IPU.h"
 #include "IPU/IPU_Fifo.h"
+typedef unsigned char uint8;
+void GSinitReadFIFO(uint8* mem);
+void GSreadFIFO(uint8* mem);
 
 //////////////////////////////////////////////////////////////////////////
 /////////////////////////// Quick & dirty FIFO :D ////////////////////////
@@ -56,7 +59,7 @@ void __fastcall ReadFIFO_VIF1(mem128_t* out)
 				GetMTGS().SendPointerPacket(GS_RINGTYPE_INIT_READ_FIFO1, 0, out);
 				GetMTGS().WaitGS(false); // wait without reg sync
 			}
-			GSreadFIFO((u64*)out);
+			GSreadFIFO((uint8*)out);
 			vif1.GSLastDownloadSize--;
 			GUNIT_LOG("ReadFIFO_VIF1");
 			if (vif1.GSLastDownloadSize <= 16)
diff --git a/pcsx2/pcsx2/GSState.cpp b/pcsx2/pcsx2/GSState.cpp
index f6c193b..4c92e60 100644
--- a/pcsx2/pcsx2/GSState.cpp
+++ b/pcsx2/pcsx2/GSState.cpp
@@ -27,6 +27,12 @@ int g_SaveGSStream = 0; // save GS stream; 1 - prepare, 2 - save
 int g_nLeftGSFrames = 0; // when saving, number of frames left
 static std::unique_ptr<memSavingState> g_fGSSave;
 
+void initGSState()
+{
+    g_SaveGSStream = 0; 
+    g_nLeftGSFrames = 0; 
+}
+
 // fixme - need to take this concept and make it MTGS friendly.
 #ifdef _STGS_GSSTATE_CODE
 void GSGIFTRANSFER1(u32 *pMem, u32 addr) {
diff --git a/pcsx2/pcsx2/Hw.cpp b/pcsx2/pcsx2/Hw.cpp
index 1742c6d..f530623 100644
--- a/pcsx2/pcsx2/Hw.cpp
+++ b/pcsx2/pcsx2/Hw.cpp
@@ -28,13 +28,15 @@ int rdram_sdevid = 0;
 
 static bool hwInitialized = false;
 
-void hwInit()
+void initHW()
 {
-	// [TODO] / FIXME:  PCSX2 no longer works on an Init system.  It assumes that the
-	// static global vars for the process will be initialized when the process is created, and
-	// then issues *resets only* from then on. (reset code for various S2 components should do
-	// NULL checks and allocate memory and such if the pointers are NULL only).
+    rdram_sdevid = 0;
+    hwInitialized = false;
+
+}
 
+void hwInit()
+{
 	if( hwInitialized ) return;
 
 	VifUnpackSSE_Init();
diff --git a/pcsx2/pcsx2/Interpreter.cpp b/pcsx2/pcsx2/Interpreter.cpp
index 891adbb..60acd41 100644
--- a/pcsx2/pcsx2/Interpreter.cpp
+++ b/pcsx2/pcsx2/Interpreter.cpp
@@ -49,17 +49,17 @@ static void debugI()
 void intBreakpoint(bool memcheck)
 {
 	u32 pc = cpuRegs.pc;
- 	if (CBreakPoints::CheckSkipFirst(pc) != 0)
+ 	if (PCBreakPoints::CheckSkipFirst(pc) != 0)
 		return;
 
 	if (!memcheck)
 	{
-		auto cond = CBreakPoints::GetBreakPointCondition(pc);
+		auto cond = PCBreakPoints::GetBreakPointCondition(pc);
 		if (cond && !cond->Evaluate())
 			return;
 	}
 
-	CBreakPoints::SetBreakpointTriggered(true);
+	PCBreakPoints::SetBreakpointTriggered(true);
 	GetCoreThread().PauseSelfDebug();
 	throw Exception::ExitCpuExecute();
 }
@@ -76,7 +76,7 @@ void intMemcheck(u32 op, u32 bits, bool store)
 	start = standardizeBreakpointAddress(start);
 	u32 end = start + bits/8;
 	
-	auto checks = CBreakPoints::GetMemChecks();
+	auto checks = PCBreakPoints::GetMemChecks();
 	for (size_t i = 0; i < checks.size(); i++)
 	{
 		auto& check = checks[i];
diff --git a/pcsx2/pcsx2/IopCounters.cpp b/pcsx2/pcsx2/IopCounters.cpp
index 619c927..2c400d2 100644
--- a/pcsx2/pcsx2/IopCounters.cpp
+++ b/pcsx2/pcsx2/IopCounters.cpp
@@ -62,6 +62,12 @@ u8 psxvblankgate = 0;
 // which ensures they stay 100% in sync with the EE's hblank counters.
 #define PSXHBLANK 0x2001
 
+void initIopCounters()
+{
+    psxhblankgate = 0;
+    psxvblankgate = 0;
+}
+
 static void psxRcntReset(int index)
 {
 	psxCounters[index].count = 0;
diff --git a/pcsx2/pcsx2/IopMem.cpp b/pcsx2/pcsx2/IopMem.cpp
index 12ebf04..512457e 100644
--- a/pcsx2/pcsx2/IopMem.cpp
+++ b/pcsx2/pcsx2/IopMem.cpp
@@ -25,18 +25,24 @@ IopVM_MemoryAllocMess* iopMem = NULL;
 
 __pagealigned u8 iopHw[Ps2MemSize::IopHardware];
 
+
+void initIopMem()
+{
+    psxMemWLUT = NULL;
+    psxMemRLUT = NULL;
+    iopMem = NULL;
+}
+
 // --------------------------------------------------------------------------------------
 //  iopMemoryReserve
 // --------------------------------------------------------------------------------------
 iopMemoryReserve::iopMemoryReserve()
-	: _parent( L"IOP Main Memory (2mb)", sizeof(*iopMem) )
+	: _parent( L"IOP Main Memory (2mb)")
 {
 }
 
-void iopMemoryReserve::Reserve(VirtualMemoryManagerPtr allocator)
-{
-	_parent::Reserve(std::move(allocator), HostMemoryMap::IOPmemOffset);
-	//_parent::Reserve(EmuConfig.HostMap.IOP);
+bool iopMemoryReserve::IsSizeOK(size_t size) {
+	return size >= sizeof(*iopMem);
 }
 
 void iopMemoryReserve::Commit()
diff --git a/pcsx2/pcsx2/Linux/LnxConsolePipe.cpp b/pcsx2/pcsx2/Linux/LnxConsolePipe.cpp
index a8e2b98..3d26718 100644
--- a/pcsx2/pcsx2/Linux/LnxConsolePipe.cpp
+++ b/pcsx2/pcsx2/Linux/LnxConsolePipe.cpp
@@ -16,6 +16,8 @@
 #include "PrecompiledHeader.h"
 
 #include "App.h"
+typedef unsigned int uint32;
+void GSosdLog(const char *utf8, uint32 color);
 #include "ConsoleLogger.h"
 #include <unistd.h>
 
diff --git a/pcsx2/pcsx2/Linux/LnxKeyCodes.cpp b/pcsx2/pcsx2/Linux/LnxKeyCodes.cpp
index 55f513c..b8aa045 100644
--- a/pcsx2/pcsx2/Linux/LnxKeyCodes.cpp
+++ b/pcsx2/pcsx2/Linux/LnxKeyCodes.cpp
@@ -14,6 +14,8 @@
  */
 
 #include "../PrecompiledHeader.h"
+typedef unsigned int uint32;
+void GSosdLog(const char *utf8, uint32 color);
 #include "ConsoleLogger.h"
 
 #include <gdk/gdkkeysyms.h>
diff --git a/pcsx2/pcsx2/MTGS.cpp b/pcsx2/pcsx2/MTGS.cpp
index 1c4a0ee..d8e9a1a 100644
--- a/pcsx2/pcsx2/MTGS.cpp
+++ b/pcsx2/pcsx2/MTGS.cpp
@@ -24,7 +24,20 @@
 #include "MTVU.h"
 #include "Elfheader.h"
 
-
+#include <X11/Xlib.h>
+#include <SDL.h>
+typedef unsigned int uint32;
+typedef unsigned char uint8;
+int GSopen2(void** dsp, uint32 flags);
+void GSsetVsync(int vsync);
+int GSopen(void** dsp, const char* title, int mt);
+void GSsetBaseMem(uint8* mem);
+void GSinitReadFIFO2(uint8* mem, uint32 size);
+void GSinitReadFIFO(uint8* mem);
+void GSsetGameCRC(uint32 crc, int options);
+void GSgifTransfer(const uint8* mem, uint32 size);
+void GSgifTransfer2(uint8* mem, uint32 size);
+void GSgifTransfer3(uint8* mem, uint32 size);
 // Uncomment this to enable profiling of the GS RingBufferCopy function.
 //#define PCSX2_GSRING_SAMPLING_STATS
 
@@ -185,7 +198,9 @@ static void dummyIrqCallback()
 	// dummy, because MTGS doesn't need this mess!
 	// (and zerogs does >_<)
 }
-
+extern Display* XDisplay;
+extern Window Xwindow;
+void create_new_window(void);  
 void SysMtgsThread::OpenPlugin()
 {
 
@@ -194,13 +209,17 @@ void SysMtgsThread::OpenPlugin()
 	memcpy( RingBuffer.Regs, PS2MEM_GS, sizeof(PS2MEM_GS) );
 	GSsetBaseMem( RingBuffer.Regs );
 	GSirqCallback( dummyIrqCallback );
+    
+	create_new_window();
+	pDsp[0] = (uptr)XDisplay;
+	pDsp[1] = (uptr)Xwindow;
 
 	int result;
 
 	if( GSopen2 != NULL )
-		result = GSopen2( (void*)pDsp, 1 | (renderswitch ? 4 : 0) );
+		result = GSopen2( (void**)pDsp, 1 | (renderswitch ? 4 : 0) );
 	else
-		result = GSopen( (void*)pDsp, "PCSX2", renderswitch ? 2 : 1 );
+		result = GSopen( (void**)pDsp, "PCSX2", renderswitch ? 2 : 1 );
 
 
 	GSsetVsync(EmuConfig.GS.GetVsync());
@@ -271,6 +290,95 @@ class RingBufferLock {
 	}
 };
 
+
+void PrintEvent(const SDL_Event * event)
+{
+    if (event->type == SDL_WINDOWEVENT) {
+        switch (event->window.event) {
+        case SDL_WINDOWEVENT_SHOWN:
+            SDL_Log("jc: Window %d shown", event->window.windowID);
+            break;
+        case SDL_WINDOWEVENT_HIDDEN:
+            SDL_Log("jc: Window %d hidden", event->window.windowID);
+            break;
+        case SDL_WINDOWEVENT_EXPOSED:
+            SDL_Log("jc: Window %d exposed", event->window.windowID);
+            break;
+        case SDL_WINDOWEVENT_MOVED:
+            SDL_Log("jc: Window %d moved to %d,%d",
+                    event->window.windowID, event->window.data1,
+                    event->window.data2);
+            break;
+        case SDL_WINDOWEVENT_RESIZED:
+            SDL_Log("jc: Window %d resized to %dx%d",
+                    event->window.windowID, event->window.data1,
+                    event->window.data2);
+            break;
+        case SDL_WINDOWEVENT_SIZE_CHANGED:
+            SDL_Log("jc: Window %d size changed to %dx%d",
+                    event->window.windowID, event->window.data1,
+                    event->window.data2);
+            break;
+        case SDL_WINDOWEVENT_MINIMIZED:
+            SDL_Log("jc: Window %d minimized", event->window.windowID);
+            break;
+        case SDL_WINDOWEVENT_MAXIMIZED:
+            SDL_Log("jc: Window %d maximized", event->window.windowID);
+            break;
+        case SDL_WINDOWEVENT_RESTORED:
+            SDL_Log("jc: Window %d restored", event->window.windowID);
+            break;
+        case SDL_WINDOWEVENT_ENTER:
+            SDL_Log("jc: Mouse entered window %d",
+                    event->window.windowID);
+            break;
+        case SDL_WINDOWEVENT_LEAVE:
+            SDL_Log("jc: Mouse left window %d", event->window.windowID);
+            break;
+        case SDL_WINDOWEVENT_FOCUS_GAINED:
+            SDL_Log("jc: Window %d gained keyboard focus",
+                    event->window.windowID);
+            break;
+        case SDL_WINDOWEVENT_FOCUS_LOST:
+            SDL_Log("jc: Window %d lost keyboard focus",
+                    event->window.windowID);
+            break;
+        case SDL_WINDOWEVENT_CLOSE:
+            SDL_Log("jc: Window %d closed", event->window.windowID);
+            break;
+#if SDL_VERSION_ATLEAST(2, 0, 5)
+        case SDL_WINDOWEVENT_TAKE_FOCUS:
+            SDL_Log("jc: Window %d is offered a focus", event->window.windowID);
+            break;
+        case SDL_WINDOWEVENT_HIT_TEST:
+            SDL_Log("jc: Window %d has a special hit test", event->window.windowID);
+            break;
+#endif
+        default:
+            SDL_Log("jc: Window %d got unknown event %d",
+                    event->window.windowID, event->window.event);
+            break;
+        }
+    }
+}
+
+void shutdownExternal();
+void sdl_event_loop()
+{
+    SDL_Event event;
+    while( SDL_PollEvent( &event ) != 0 )
+    {
+        PrintEvent(&event);
+        switch (event.type)
+        {
+            case SDL_QUIT: 
+                shutdownExternal();
+                break;
+            default:
+                break;
+        }
+    }
+}
 void SysMtgsThread::ExecuteTaskInThread()
 {
 	// Threading info: run in MTGS thread
@@ -283,6 +391,8 @@ void SysMtgsThread::ExecuteTaskInThread()
 	RingBufferLock busy (*this);
 
 	while(true) {
+		sdl_event_loop();
+
 		busy.Release();
 
 		// Performance note: Both of these perform cancellation tests, but pthread_testcancel
@@ -334,13 +444,13 @@ void SysMtgsThread::ExecuteTaskInThread()
 					if( endpos >= RingBufferSize )
 					{
 						uint firstcopylen = RingBufferSize - datapos;
-						GSgifTransfer( (u32*)data, firstcopylen );
+						GSgifTransfer( (uint8*)data, firstcopylen );
 						datapos = endpos & RingBufferMask;
-						GSgifTransfer( (u32*)RingBuffer.m_Ring, datapos );
+						GSgifTransfer( (uint8*)RingBuffer.m_Ring, datapos );
 					}
 					else
 					{
-						GSgifTransfer( (u32*)data, qsize );
+						GSgifTransfer( (uint8*)data, qsize );
 					}
 
 					ringposinc += qsize;
@@ -359,13 +469,13 @@ void SysMtgsThread::ExecuteTaskInThread()
 					if( endpos >= RingBufferSize )
 					{
 						uint firstcopylen = RingBufferSize - datapos;
-						GSgifTransfer2( (u32*)data, firstcopylen );
+						GSgifTransfer2( (uint8*)data, firstcopylen );
 						datapos = endpos & RingBufferMask;
-						GSgifTransfer2( (u32*)RingBuffer.m_Ring, datapos );
+						GSgifTransfer2( (uint8*)RingBuffer.m_Ring, datapos );
 					}
 					else
 					{
-						GSgifTransfer2( (u32*)data, qsize );
+						GSgifTransfer2( (uint8*)data, qsize );
 					}
 
 					ringposinc += qsize;
@@ -384,13 +494,13 @@ void SysMtgsThread::ExecuteTaskInThread()
 					if( endpos >= RingBufferSize )
 					{
 						uint firstcopylen = RingBufferSize - datapos;
-						GSgifTransfer3( (u32*)data, firstcopylen );
+						GSgifTransfer3( (uint8*)data, firstcopylen );
 						datapos = endpos & RingBufferMask;
-						GSgifTransfer3( (u32*)RingBuffer.m_Ring, datapos );
+						GSgifTransfer3( (uint8*)RingBuffer.m_Ring, datapos );
 					}
 					else
 					{
-						GSgifTransfer3( (u32*)data, qsize );
+						GSgifTransfer3( (uint8*)data, qsize );
 					}
 
 					ringposinc += qsize;
@@ -401,7 +511,7 @@ void SysMtgsThread::ExecuteTaskInThread()
 					Gif_Path& path   = gifUnit.gifPath[tag.data[2]];
 					u32       offset = tag.data[0];
 					u32       size   = tag.data[1];
-					if (offset != ~0u) GSgifTransfer((u32*)&path.buffer[offset], size/16);
+					if (offset != ~0u) GSgifTransfer((uint8*)&path.buffer[offset], size/16);
 					path.readAmount.fetch_sub(size, std::memory_order_acq_rel);
 					break;
 				}
@@ -415,7 +525,7 @@ void SysMtgsThread::ExecuteTaskInThread()
 					busy.PartialAcquire();
 					Gif_Path& path   = gifUnit.gifPath[GIF_PATH_1];
 					GS_Packet gsPack = path.GetGSPacketMTVU(); // Get vu1 program's xgkick packet(s)
-					if (gsPack.size) GSgifTransfer((u32*)&path.buffer[gsPack.offset], gsPack.size/16);
+					if (gsPack.size) GSgifTransfer((uint8*)&path.buffer[gsPack.offset], gsPack.size/16);
 					path.readAmount.fetch_sub(gsPack.size + gsPack.readAmount, std::memory_order_acq_rel);
 					path.PopGSPacketMTVU(); // Should be done last, for proper Gif_MTGS_Wait()
 					break;
@@ -499,14 +609,12 @@ void SysMtgsThread::ExecuteTaskInThread()
 
 						case GS_RINGTYPE_INIT_READ_FIFO1:
 							MTGS_LOG( "(MTGS Packet Read) ringtype=Fifo1" );
-							if (GSinitReadFIFO)
-								GSinitReadFIFO( (u64*)tag.pointer);
+                            GSinitReadFIFO( (uint8*)tag.pointer);
 						break;
 
 						case GS_RINGTYPE_INIT_READ_FIFO2:
 							MTGS_LOG( "(MTGS Packet Read) ringtype=Fifo2, size=%d", tag.data[0] );
-							if (GSinitReadFIFO2)
-								GSinitReadFIFO2( (u64*)tag.pointer, tag.data[0]);
+                            GSinitReadFIFO2( (uint8*)tag.pointer, tag.data[0]);
 						break;
 
 #ifdef PCSX2_DEVBUILD
diff --git a/pcsx2/pcsx2/Memory.cpp b/pcsx2/pcsx2/Memory.cpp
index 212581c..0e8df43 100644
--- a/pcsx2/pcsx2/Memory.cpp
+++ b/pcsx2/pcsx2/Memory.cpp
@@ -53,6 +53,11 @@ BIOS
 
 int MemMode = 0;		// 0 is Kernel Mode, 1 is Supervisor Mode, 2 is User Mode
 
+void initMemory()
+{
+    MemMode = 0;
+}
+
 void memSetKernelMode() {
 	//Do something here
 	MemMode = 0;
@@ -705,14 +710,12 @@ void memBindConditionalHandlers()
 //  eeMemoryReserve  (implementations)
 // --------------------------------------------------------------------------------------
 eeMemoryReserve::eeMemoryReserve()
-	: _parent( L"EE Main Memory", sizeof(*eeMem) )
+	: _parent( L"EE Main Memory" )
 {
 }
 
-void eeMemoryReserve::Reserve(VirtualMemoryManagerPtr allocator)
-{
-	_parent::Reserve(std::move(allocator), HostMemoryMap::EEmemOffset);
-	//_parent::Reserve(EmuConfig.HostMap.IOP);
+bool eeMemoryReserve::IsSizeOK(size_t size) {
+	return size >= sizeof(*eeMem);
 }
 
 void eeMemoryReserve::Commit()
diff --git a/pcsx2/pcsx2/Pcsx2Config.cpp b/pcsx2/pcsx2/Pcsx2Config.cpp
index 4bf9544..86ae3cd 100644
--- a/pcsx2/pcsx2/Pcsx2Config.cpp
+++ b/pcsx2/pcsx2/Pcsx2Config.cpp
@@ -426,6 +426,7 @@ Pcsx2Config::Pcsx2Config()
 	McdFolderAutoManage = true;
 	EnablePatches = true;
 	BackupSavestate = true;
+	ConsoleToStdio = true;
 }
 
 void Pcsx2Config::LoadSave( IniInterface& ini )
diff --git a/pcsx2/pcsx2/PluginManager.cpp b/pcsx2/pcsx2/PluginManager.cpp
index 99764c0..8ae3d64 100644
--- a/pcsx2/pcsx2/PluginManager.cpp
+++ b/pcsx2/pcsx2/PluginManager.cpp
@@ -13,6 +13,7 @@
  *  If not, see <http://www.gnu.org/licenses/>.
  */
 
+ 
 #include "PrecompiledHeader.h"
 #include "IopCommon.h"
 
@@ -27,8 +28,33 @@
 #include "Utilities/pxStreams.h"
 
 #include "svnrev.h"
+typedef unsigned int uint32;
+typedef unsigned char uint8;
+void GSosdMonitor(const char *key, const char *value, uint32 color);
+void GSosdLog(const char *utf8, uint32 color);
+void GSsetVsync(int vsync);
+void GSsetExclusive(int enabled);
+int  GSopen(void** dsp, const char* title, int mt);
+int  GSopen2(void** dsp, uint32 flags);
+void GSreadFIFO(uint8* mem);
+void GSreadFIFO2(uint8* mem, uint32 size);
+struct GSKeyEventData {uint32 key, type;};
+void GSkeyEvent(GSKeyEventData* e);
+void GSgifTransfer(const uint8* mem, uint32 size);
+void GSgifTransfer1(uint8* mem, uint32 addr);
+void GSgifTransfer2(uint8* mem, uint32 size);
+void GSgifTransfer3(uint8* mem, uint32 size);
+void GSsetBaseMem(uint8* mem);
+void GSsetGameCRC(uint32 crc, int options);
+void GSinitReadFIFO(uint8* mem);
 #include "ConsoleLogger.h"
 
+void GSmakeSnapshot2(char *pathname, int *snapdone, int savejpg) {} 
+void GSsetLogDir(const char* dir) {}
+void GSinitReadFIFO2(unsigned long* mem, int i) {GSinitReadFIFO((uint8*) mem);}
+int  GSopen_(void* dsp, char const* title, int mt) {return GSopen((void**) dsp,title,mt);}
+
+
 SysPluginBindings SysPlugins;
 
 bool SysPluginBindings::McdIsPresent( uint port, uint slot )
@@ -238,12 +264,12 @@ static void CALLBACK GS_Legacy_gifTransfer( const u32* src, u32 data )
 				memcpy( &path1queue[path1size], src128, data*16);
 				path1size += data;
 			}
-			GSgifTransfer1( (u32*)path1queue, 0 );
+			GSgifTransfer1( (uint8*)path1queue, 0 );
 			path1size = 0;
 		}
 		else
 		{
-			GSgifTransfer1( (u32*)src128, 0 );
+			GSgifTransfer1( (uint8*)src128, 0 );
 		}
 	}
 }
@@ -253,12 +279,12 @@ static void CALLBACK GS_Legacy_gifTransfer( const u32* src, u32 data )
 // Since GSgifTransfer2 is the least hacky old call-back, and MTGS will
 // just be using a single gif path, we'll just solely use path 2...
 static void CALLBACK GS_Legacy_gifTransfer(const u32* src, u32 data) {
-	GSgifTransfer2((u32*)src, data);
+	GSgifTransfer2((uint8*)src, data);
 }
 #endif
 
 static void CALLBACK GS_Legacy_GSreadFIFO2(u64* pMem, int qwc) {
-	while(qwc--) GSreadFIFO(pMem);
+	while(qwc--) GSreadFIFO((uint8*)pMem);
 }
 
 // PAD
@@ -381,7 +407,7 @@ static const LegacyApi_CommonMethod s_MethMessCommon[] =
 // ----------------------------------------------------------------------------
 static const LegacyApi_ReqMethod s_MethMessReq_GS[] =
 {
-	{	"GSopen",			(vMeth**)&GSopen,			NULL	},
+	{	"GSopen",			(vMeth**)&GSopen_,			NULL	},
 	{	"GSvsync",			(vMeth**)&GSvsync,			NULL	},
 	{	"GSgifTransfer",	(vMeth**)&GSgifTransfer,	(vMeth*)GS_Legacy_gifTransfer },
 	{	"GSgifTransfer2",	(vMeth**)&GSgifTransfer2,	NULL	},
@@ -435,8 +461,10 @@ static const LegacyApi_ReqMethod s_MethMessReq_PAD[] =
 	// fixme - Following functions are new as of some revison post-0.9.6, and
 	// are for multitap support only.  They should either be optional or offer
 	// NOP fallbacks, to allow older plugins to retain functionality.
+#ifndef BUILTIN_PAD_PLUGIN
 	{	"PADsetSlot",		(vMeth**)&PADsetSlot,	(vMeth*)PAD_setSlot },
 	{	"PADqueryMtap",		(vMeth**)&PADqueryMtap,	(vMeth*)PAD_queryMtap },
+#endif
 	{ NULL },
 };
 
@@ -688,8 +716,6 @@ static const LegacyApi_OptMethod* const s_MethMessOpt[] =
 	s_MethMessOpt_DEV9
 };
 
-SysCorePlugins *g_plugins = NULL;
-
 // ---------------------------------------------------------------------------------
 //       Plugin-related Exception Implementations
 // ---------------------------------------------------------------------------------
@@ -837,7 +863,6 @@ void* StaticLibrary::GetSymbol(const wxString &name)
 	RETURN_SYMBOL(p##keyEvent) \
 	RETURN_SYMBOL(p##setSettingsDir) \
 	RETURN_SYMBOL(p##setLogDir) \
-	RETURN_SYMBOL(p##freeze) \
 	RETURN_SYMBOL(p##test) \
 	RETURN_SYMBOL(p##configure) \
 	RETURN_SYMBOL(p##about)
@@ -1118,10 +1143,10 @@ void SysCorePlugins::Load( const wxString (&folders)[PluginId_Count] )
 
 	CDVDapi_Plugin.newDiskCB( cdvdNewDiskCB );
 
-	// Hack for PAD's stupid parameter passed on Init
+#ifndef BUILTIN_PAD_PLUGIN
 	PADinit = (_PADinit)m_info[PluginId_PAD]->CommonBindings.Init;
 	m_info[PluginId_PAD]->CommonBindings.Init = _hack_PADinit;
-
+#endif
 	Console.WriteLn( Color_StrongBlue, "Plugins loaded successfully.\n" );
 
 	// HACK!  Manually bind the Internal MemoryCard plugin for now, until
@@ -1435,6 +1460,7 @@ void SysCorePlugins::Close()
 		Close( tbl_PluginInfo[i].id );
 	
 	Console.WriteLn( Color_StrongBlue, "Plugins closed successfully." );
+	Shutdown();
 }
 
 void SysCorePlugins::Init( PluginsEnum_t pid )
@@ -1520,7 +1546,7 @@ bool SysCorePlugins::Shutdown()
 
 	for( int i=PluginId_Count-1; i>=0; --i )
 	{
-		Shutdown( tbl_PluginInfo[i].id );
+		//Shutdown( tbl_PluginInfo[i].id );
 	}
 
 	// More memorycard hacks!!
diff --git a/pcsx2/pcsx2/R3000A.cpp b/pcsx2/pcsx2/R3000A.cpp
index 338449f..79d9baf 100644
--- a/pcsx2/pcsx2/R3000A.cpp
+++ b/pcsx2/pcsx2/R3000A.cpp
@@ -50,6 +50,15 @@ bool iopEventTestIsActive = false;
 
 __aligned16 psxRegisters psxRegs;
 
+void initR3000A()
+{
+    g_iopNextEventCycle = 0;
+    iopBreak = 0;
+    iopCycleEE = -1;
+    iopEventAction = false;
+    iopEventTestIsActive = false;
+}
+
 void psxReset()
 {
 	memzero(psxRegs);
diff --git a/pcsx2/pcsx2/R5900.cpp b/pcsx2/pcsx2/R5900.cpp
index 0c49a1c..7af0cbf 100644
--- a/pcsx2/pcsx2/R5900.cpp
+++ b/pcsx2/pcsx2/R5900.cpp
@@ -67,6 +67,15 @@ const int kMaxArgs = 16;
 uptr g_argPtrs[kMaxArgs];
 #define DEBUG_LAUNCHARG 0 // show lots of helpful console messages as the launch arguments are passed to the game
 
+void initR5900()
+{
+    Cpu = NULL;
+    eeEventTestIsActive = false;
+    g_eeloadMain = 0;
+    g_eeloadExec = 0; 
+    g_osdsys_str = 0;
+}
+
 extern SysMainMemory& GetVmMemory();
 
 void cpuReset()
@@ -766,11 +775,11 @@ inline bool isBranchOrJump(u32 addr)
 int isBreakpointNeeded(u32 addr)
 {
 	int bpFlags = 0;
-	if (CBreakPoints::IsAddressBreakPoint(addr))
+	if (PCBreakPoints::IsAddressBreakPoint(addr))
 		bpFlags += 1;
 
 	// there may be a breakpoint in the delay slot
-	if (isBranchOrJump(addr) && CBreakPoints::IsAddressBreakPoint(addr+4))
+	if (isBranchOrJump(addr) && PCBreakPoints::IsAddressBreakPoint(addr+4))
 		bpFlags += 2;
 
 	return bpFlags;
@@ -778,7 +787,7 @@ int isBreakpointNeeded(u32 addr)
 
 int isMemcheckNeeded(u32 pc)
 {
-	if (CBreakPoints::GetNumMemchecks() == 0)
+	if (PCBreakPoints::GetNumMemchecks() == 0)
 		return 0;
 	
 	u32 addr = pc;
diff --git a/pcsx2/pcsx2/R5900OpcodeImpl.cpp b/pcsx2/pcsx2/R5900OpcodeImpl.cpp
index 3c41874..12a31ae 100644
--- a/pcsx2/pcsx2/R5900OpcodeImpl.cpp
+++ b/pcsx2/pcsx2/R5900OpcodeImpl.cpp
@@ -27,6 +27,13 @@
 GS_VideoMode gsVideoMode = GS_VideoMode::Uninitialized;
 bool gsIsInterlaced = false;
 
+void initR5900Op()
+{
+    gsVideoMode = GS_VideoMode::Uninitialized;
+    gsIsInterlaced = false;
+
+}
+
 static __fi bool _add64_Overflow( s64 x, s64 y, s64 &ret )
 {
 	const s64 result = x + y;
diff --git a/pcsx2/pcsx2/Recording/PadData.cpp b/pcsx2/pcsx2/Recording/PadData.cpp
index 1654875..53ca347 100644
--- a/pcsx2/pcsx2/Recording/PadData.cpp
+++ b/pcsx2/pcsx2/Recording/PadData.cpp
@@ -16,6 +16,8 @@
 #include "PrecompiledHeader.h"
 
 #include "Common.h"
+typedef unsigned int uint32;
+void GSosdLog(const char *utf8, uint32 color);
 #include "ConsoleLogger.h"
 #include "PadData.h"
 
diff --git a/pcsx2/pcsx2/Sio.cpp b/pcsx2/pcsx2/Sio.cpp
index 79bd47f..7f2382c 100644
--- a/pcsx2/pcsx2/Sio.cpp
+++ b/pcsx2/pcsx2/Sio.cpp
@@ -17,6 +17,8 @@
 #include "IopCommon.h"
 
 #include "Common.h"
+typedef unsigned int uint32;
+void GSosdLog(const char *utf8, uint32 color);
 #include "ConsoleLogger.h"
 #include "Sio.h"
 #include "sio_internal.h"
@@ -296,10 +298,11 @@ SIO_WRITE sioWriteMultitap(u8 data)
 		case 0x21:
 			{
 				sio.slot[sio.port] = data;
-
+#ifndef BUILTIN_PAD_PLUGIN
 				u32 ret = PADsetSlot(sio.port+1, data+1);
 				sio.buf[5] = ret? data : 0xFF;
 				sio.buf[6] = ret? 0x5A : 0x66;
+#endif
 			}
 			break;
 
diff --git a/pcsx2/pcsx2/System.cpp b/pcsx2/pcsx2/System.cpp
index 63af907..20f89a3 100644
--- a/pcsx2/pcsx2/System.cpp
+++ b/pcsx2/pcsx2/System.cpp
@@ -57,15 +57,15 @@ void RecompiledCodeReserve::_termProfiler()
 {
 }
 
-void* RecompiledCodeReserve::Assign( VirtualMemoryManagerPtr allocator, void *baseptr, size_t size )
+void* RecompiledCodeReserve::Assign( void *baseptr, size_t size )
 {
-	if (!_parent::Assign(std::move(allocator), baseptr, size)) return NULL;
+	if (!_parent::Assign(baseptr, size)) return NULL;
 
 	Commit();
 
 	_registerProfiler();
 
-	return m_baseptr;
+	return IsOk() ? m_baseptr : nullptr;
 }
 
 void RecompiledCodeReserve::Reset()
@@ -101,6 +101,10 @@ RecompiledCodeReserve& RecompiledCodeReserve::SetProfilerName( const wxString& s
 	return *this;
 }
 
+bool RecompiledCodeReserve::IsOk() const {
+	return m_baseptr != nullptr && m_pages_commited == m_pages_reserved;
+}
+
 // This error message is shared by R5900, R3000, and microVU recompilers.
 void RecompiledCodeReserve::ThrowIfNotOk() const
 {
@@ -351,50 +355,39 @@ static wxString GetMemoryErrorVM()
 	);
 }
 
-namespace HostMemoryMap {
-	// For debuggers
-	uptr EEmem, IOPmem, VUmem, EErec, IOPrec, VIF0rec, VIF1rec, mVU0rec, mVU1rec, bumpAllocator;
-}
+__pagealigned EEVM_MemoryAllocMess HostMemoryMap::EEmem;
+__pagealigned u8 HostMemoryMap::IOPmem[(sizeof(IopVM_MemoryAllocMess) + __pagesize - 1) & -__pagesize];
+__pagealigned u8 HostMemoryMap::VUmem[_64kb];
+__pagealigned u8 HostMemoryMap::EErec[_64mb];
+__pagealigned u8 HostMemoryMap::IOPrec[_32mb];
+__pagealigned u8 HostMemoryMap::VIF0rec[_8mb];
+__pagealigned u8 HostMemoryMap::VIF1rec[_8mb];
+__pagealigned u8 HostMemoryMap::mVU0rec[_64mb];
+__pagealigned u8 HostMemoryMap::mVU1rec[_64mb];
+__pagealigned u8 HostMemoryMap::bumpAllocator[_64mb];
 
-/// Attempts to find a spot near static variables for the main memory
-static VirtualMemoryManagerPtr makeMainMemoryManager() {
-	uptr codeBase = (uptr)(void*)makeMainMemoryManager / (1 << 28) * (1 << 28);
-	for (int offset = 4; offset >= -6; offset--) {
-		uptr base = codeBase + (offset << 28);
-		if ((sptr)base < 0 || (sptr)(base + HostMemoryMap::Size - 1) < 0) {
-			// VTLB will throw a fit if we try to put EE main memory here
-			continue;
-		}
-		auto mgr = std::make_shared<VirtualMemoryManager>("Main Memory Manager", base, HostMemoryMap::Size, /*upper_bounds=*/0, /*strict=*/true);
-		if (mgr->IsOk()) {
-			return mgr;
-		}
-	}
-
-	if (sizeof(void*) == 8) {
-		pxAssertRel(0, "Failed to find a good place for the main memory allocation, recompilers may fail");
-	}
-	return std::make_shared<VirtualMemoryManager>("Main Memory Manager", 0, HostMemoryMap::Size);
+template <typename T>
+static void DecommitBSS(T& t) {
+	static_assert(sizeof(T) % __pagesize == 0, "Size must be page-aligned");
+	HostSys::MmapResetPtr((void*)&t, sizeof(T));
 }
 
 // --------------------------------------------------------------------------------------
 //  SysReserveVM  (implementations)
 // --------------------------------------------------------------------------------------
 SysMainMemory::SysMainMemory()
-	: m_mainMemory(makeMainMemoryManager())
-	, m_bumpAllocator(m_mainMemory, HostMemoryMap::bumpAllocatorOffset, HostMemoryMap::Size - HostMemoryMap::bumpAllocatorOffset)
-{
-	uptr base = (uptr)MainMemory()->GetBase();
-	HostMemoryMap::EEmem   = base + HostMemoryMap::EEmemOffset;
-	HostMemoryMap::IOPmem  = base + HostMemoryMap::IOPmemOffset;
-	HostMemoryMap::VUmem   = base + HostMemoryMap::VUmemOffset;
-	HostMemoryMap::EErec   = base + HostMemoryMap::EErecOffset;
-	HostMemoryMap::IOPrec  = base + HostMemoryMap::IOPrecOffset;
-	HostMemoryMap::VIF0rec = base + HostMemoryMap::VIF0recOffset;
-	HostMemoryMap::VIF1rec = base + HostMemoryMap::VIF1recOffset;
-	HostMemoryMap::mVU0rec = base + HostMemoryMap::mVU0recOffset;
-	HostMemoryMap::mVU1rec = base + HostMemoryMap::mVU1recOffset;
-	HostMemoryMap::bumpAllocator = base + HostMemoryMap::bumpAllocatorOffset;
+	: m_bumpAllocator((void*)HostMemoryMap::bumpAllocator, sizeof(HostMemoryMap::bumpAllocator))
+{
+	DecommitBSS(HostMemoryMap::EEmem);
+	DecommitBSS(HostMemoryMap::IOPmem);
+	DecommitBSS(HostMemoryMap::VUmem);
+	DecommitBSS(HostMemoryMap::EErec);
+	DecommitBSS(HostMemoryMap::IOPrec);
+	DecommitBSS(HostMemoryMap::VIF0rec);
+	DecommitBSS(HostMemoryMap::VIF1rec);
+	DecommitBSS(HostMemoryMap::mVU0rec);
+	DecommitBSS(HostMemoryMap::mVU1rec);
+	DecommitBSS(HostMemoryMap::bumpAllocator);
 }
 
 SysMainMemory::~SysMainMemory()
@@ -412,9 +405,9 @@ void SysMainMemory::ReserveAll()
 	DevCon.WriteLn( Color_StrongBlue, "Mapping host memory for virtual systems..." );
 	ConsoleIndentScope indent(1);
 
-	m_ee.Reserve(MainMemory());
-	m_iop.Reserve(MainMemory());
-	m_vu.Reserve(MainMemory());
+	m_ee.Assign(HostMemoryMap::EEmem);
+	m_iop.Assign(HostMemoryMap::IOPmem);
+	m_vu.Assign(HostMemoryMap::VUmem);
 }
 
 void SysMainMemory::CommitAll()
diff --git a/pcsx2/pcsx2/System.h b/pcsx2/pcsx2/System.h
index eed8061..1f1ce80 100644
--- a/pcsx2/pcsx2/System.h
+++ b/pcsx2/pcsx2/System.h
@@ -41,41 +41,35 @@ class RecompiledCodeReserve;
 
 namespace HostMemoryMap
 {
-	static const u32 Size = 0x28000000;
-
-	// The actual addresses may not be equivalent to Base + Offset in the event that allocation at Base failed
-	// Each of these offsets has a debugger-accessible equivalent variable without the Offset suffix that will hold the actual address (not here because we don't want code using it)
-
 	// PS2 main memory, SPR, and ROMs
-	static const u32 EEmemOffset   = 0x00000000;
+	extern __pagealigned EEVM_MemoryAllocMess EEmem;
 
 	// IOP main memory and ROMs
-	static const u32 IOPmemOffset  = 0x04000000;
+	extern __pagealigned u8 IOPmem[(sizeof(IopVM_MemoryAllocMess) + __pagesize - 1) & -__pagesize];
 
 	// VU0 and VU1 memory.
-	static const u32 VUmemOffset   = 0x08000000;
+	extern __pagealigned u8 VUmem[_64kb];
 
 	// EE recompiler code cache area (64mb)
-	static const u32 EErecOffset   = 0x10000000;
+	extern __pagealigned u8 EErec[_64mb];
 
 	// IOP recompiler code cache area (16 or 32mb)
-	static const u32 IOPrecOffset  = 0x14000000;
+	extern __pagealigned u8 IOPrec[_32mb];
 
 	// newVif0 recompiler code cache area (16mb)
-	static const u32 VIF0recOffset = 0x16000000;
+	extern __pagealigned u8 VIF0rec[_8mb];
 
 	// newVif1 recompiler code cache area (32mb)
-	static const u32 VIF1recOffset = 0x18000000;
+	extern __pagealigned u8 VIF1rec[_8mb];
 
 	// microVU1 recompiler code cache area (32 or 64mb)
-	static const u32 mVU0recOffset = 0x1C000000;
+	extern __pagealigned u8 mVU0rec[_64mb];
 
 	// microVU0 recompiler code cache area (64mb)
-	static const u32 mVU1recOffset = 0x20000000;
+	extern __pagealigned u8 mVU1rec[_64mb];
 
 	// Bump allocator for any other small allocations
-	// size: Difference between it and HostMemoryMap::Size, so nothing should allocate higher than it!
-	static const u32 bumpAllocatorOffset = 0x24000000;
+	extern __pagealigned u8 bumpAllocator[_64mb];
 }
 
 // --------------------------------------------------------------------------------------
@@ -85,18 +79,16 @@ namespace HostMemoryMap
 class SysMainMemory
 {
 protected:
-	const VirtualMemoryManagerPtr m_mainMemory;
-	VirtualMemoryBumpAllocator    m_bumpAllocator;
-	eeMemoryReserve               m_ee;
-	iopMemoryReserve              m_iop;
-	vuMemoryReserve               m_vu;
+	VirtualMemoryBumpAllocator m_bumpAllocator;
+	eeMemoryReserve            m_ee;
+	iopMemoryReserve           m_iop;
+	vuMemoryReserve            m_vu;
 
 public:
 	SysMainMemory();
 	virtual ~SysMainMemory();
 
-	const VirtualMemoryManagerPtr& MainMemory()    { return m_mainMemory; }
-	VirtualMemoryBumpAllocator&    BumpAllocator() { return m_bumpAllocator; }
+	VirtualMemoryBumpAllocator& BumpAllocator() { return m_bumpAllocator; }
 
 	virtual void ReserveAll();
 	virtual void CommitAll();
@@ -175,13 +167,12 @@ extern SysMainMemory& GetVmMemory();
 // This should be available on Windows, via Microsoft or Intel compilers (I'm pretty sure Intel
 // supports native SEH model).  GNUC in Windows, or any compiler in a non-windows platform, will
 // need to use setjmp/longjmp instead to exit recompiled code.
-// In addition, we don't currently set up SEH properly on Windows x64 so disable it there too
 //
 
 //#define PCSX2_SEH		0		// use this to force disable SEH on win32, to test setjmp functionality.
 
 #ifndef PCSX2_SEH
-#	if defined(_WIN32) && !defined(__GNUC__) && !defined(_WIN64)
+#	if defined(_WIN32) && !defined(__GNUC__)
 #		define PCSX2_SEH	1
 #	else
 #		define PCSX2_SEH	0
diff --git a/pcsx2/pcsx2/System/RecTypes.h b/pcsx2/pcsx2/System/RecTypes.h
index 385e022..525ca7a 100644
--- a/pcsx2/pcsx2/System/RecTypes.h
+++ b/pcsx2/pcsx2/System/RecTypes.h
@@ -34,7 +34,7 @@ public:
 	RecompiledCodeReserve( const wxString& name=wxEmptyString, uint defCommit = 0 );
 	virtual ~RecompiledCodeReserve();
 
-	virtual void* Assign( VirtualMemoryManagerPtr allocator, void *baseptr, size_t size ) override;
+	virtual void* Assign( void *baseptr, size_t size ) override;
 	virtual void Reset() override;
 	virtual bool Commit() override;
 
@@ -44,6 +44,7 @@ public:
 		return SetProfilerName( fromUTF8(shortname) );
 	}
 
+	bool IsOk() const;
 	void ThrowIfNotOk() const;
 
 	operator void*()				{ return m_baseptr; }
diff --git a/pcsx2/pcsx2/System/SysCoreThread.cpp b/pcsx2/pcsx2/System/SysCoreThread.cpp
index 7f52fd4..2d1189e 100644
--- a/pcsx2/pcsx2/System/SysCoreThread.cpp
+++ b/pcsx2/pcsx2/System/SysCoreThread.cpp
@@ -234,7 +234,7 @@ void SysCoreThread::GameStartingInThread()
 {
 	GetMTGS().SendGameCRC(ElfCRC);
 
-	MIPSAnalyst::ScanForFunctions(ElfTextRange.first,ElfTextRange.first+ElfTextRange.second,true);
+	PMIPSAnalyst::ScanForFunctions(ElfTextRange.first,ElfTextRange.first+ElfTextRange.second,true);
 	symbolMap.UpdateActiveSymbols();
 	sApp.PostAppMethod(&Pcsx2App::resetDebugger);
 
diff --git a/pcsx2/pcsx2/System/SysThreadBase.cpp b/pcsx2/pcsx2/System/SysThreadBase.cpp
index 6b179d8..f74e8bd 100644
--- a/pcsx2/pcsx2/System/SysThreadBase.cpp
+++ b/pcsx2/pcsx2/System/SysThreadBase.cpp
@@ -279,6 +279,8 @@ void SysThreadBase::OnResumeInThread( bool isSuspended ) {}
 // Return value:
 //   TRUE if the thread was paused or closed; FALSE if the thread
 //   continued execution unimpeded.
+void wxRequestExit(void);
+extern bool requestShutdown;
 bool SysThreadBase::StateCheckInThread()
 {
 	switch( m_ExecMode.load() )
@@ -327,6 +329,10 @@ bool SysThreadBase::StateCheckInThread()
 			OnSuspendInThread();
 			m_ExecMode = ExecMode_Closed;
 			m_RunningLock.Release();
+			if (requestShutdown) 
+			{
+				wxRequestExit();
+			}
 		}
 		// Fall through
 
diff --git a/pcsx2/pcsx2/VUmicroMem.cpp b/pcsx2/pcsx2/VUmicroMem.cpp
index 13ee3fe..c8f0c13 100644
--- a/pcsx2/pcsx2/VUmicroMem.cpp
+++ b/pcsx2/pcsx2/VUmicroMem.cpp
@@ -23,16 +23,16 @@ __aligned16 VURegs vuRegs[2];
 
 
 vuMemoryReserve::vuMemoryReserve()
-	: _parent( L"VU0/1 on-chip memory", VU1_PROGSIZE + VU1_MEMSIZE + VU0_PROGSIZE + VU0_MEMSIZE )
+	: _parent( L"VU0/1 on-chip memory" )
 {
 }
 
-void vuMemoryReserve::Reserve(VirtualMemoryManagerPtr allocator)
-{
-	_parent::Reserve(std::move(allocator), HostMemoryMap::VUmemOffset);
-	//_parent::Reserve(EmuConfig.HostMemMap.VUmem);
+bool vuMemoryReserve::IsSizeOK(size_t size) {
+	return size >= VU1_PROGSIZE + VU1_MEMSIZE + VU0_PROGSIZE + VU0_MEMSIZE;
+}
 
-	u8* curpos = m_reserve.GetPtr();
+void vuMemoryReserve::DidAssign(void *mem) {
+	u8* curpos = (u8*)mem;
 	VU0.Micro	= curpos; curpos += VU0_PROGSIZE;
 	VU0.Mem		= curpos; curpos += VU0_MEMSIZE;
 	VU1.Micro	= curpos; curpos += VU1_PROGSIZE;
diff --git a/pcsx2/pcsx2/Vif0_Dma.cpp b/pcsx2/pcsx2/Vif0_Dma.cpp
index e9a3925..5918da0 100644
--- a/pcsx2/pcsx2/Vif0_Dma.cpp
+++ b/pcsx2/pcsx2/Vif0_Dma.cpp
@@ -21,6 +21,11 @@
 
 u32 g_vif0Cycles = 0;
 
+void initVif0_Dma()
+{
+    g_vif0Cycles = 0;
+}
+
 // Run VU0 until finish, don't add cycles to EE
 // because its vif stalling not the EE core...
 __fi void vif0FLUSH()
diff --git a/pcsx2/pcsx2/Vif1_Dma.cpp b/pcsx2/pcsx2/Vif1_Dma.cpp
index 8841098..654056e 100644
--- a/pcsx2/pcsx2/Vif1_Dma.cpp
+++ b/pcsx2/pcsx2/Vif1_Dma.cpp
@@ -20,9 +20,16 @@
 #include "Gif_Unit.h"
 #include "VUmicro.h"
 #include "newVif.h"
-
+typedef unsigned char uint8;
+typedef unsigned int uint32;
+void GSreadFIFO2(uint8* mem, uint32 size);
 u32 g_vif1Cycles = 0;
 
+void initVif1_Dma()
+{
+    g_vif1Cycles = 0;
+}
+
 __fi void vif1FLUSH()
 {
 	if(vif1Regs.stat.VEW)
@@ -72,7 +79,7 @@ void vif1TransferToMemory()
 		GetMTGS().SendPointerPacket(GS_RINGTYPE_INIT_READ_FIFO2, size, pMem);
 		GetMTGS().WaitGS(false); // wait without reg sync
 	}
-	GSreadFIFO2((u64*)pMem, size);
+	GSreadFIFO2((uint8*)pMem, size);
 //	pMem += size;
 
 	//Some games such as Alex Ferguson's Player Manager 2001 reads less than GSLastDownloadSize by VIF then reads the remainder by FIFO
diff --git a/pcsx2/pcsx2/gui/App.h b/pcsx2/pcsx2/gui/App.h
index 1086d07..7e37ed4 100644
--- a/pcsx2/pcsx2/gui/App.h
+++ b/pcsx2/pcsx2/gui/App.h
@@ -554,6 +554,7 @@ public:
 	void LogicalVsync();
 	
 	SysMainMemory& GetVmReserve();
+    void ReleaseVmReserve();
 	
 	GSFrame&			GetGsFrame() const;
 	MainEmuFrame&		GetMainFrame() const;
@@ -585,6 +586,7 @@ public:
 	void DetectCpuAndUserMode();
 	void OpenProgramLog();
 	void OpenMainFrame();
+	int  FilterEvent(wxEvent &event);
 	void PrepForExit();
 	void CleanupRestartable();
 	void CleanupResources();
@@ -794,6 +796,7 @@ extern int  EnumeratePluginsInFolder( const wxDirName& searchPath, wxArrayString
 extern void LoadPluginsPassive();
 extern void LoadPluginsImmediate();
 extern void UnloadPlugins();
+extern void ClosePlugins();
 extern void ShutdownPlugins();
 
 extern bool SysHasValidState();
diff --git a/pcsx2/pcsx2/gui/AppConfig.cpp b/pcsx2/pcsx2/gui/AppConfig.cpp
index 1d227ce..45ea3db 100644
--- a/pcsx2/pcsx2/gui/AppConfig.cpp
+++ b/pcsx2/pcsx2/gui/AppConfig.cpp
@@ -25,6 +25,7 @@
 #include <wx/stdpaths.h>
 #include "DebugTools/Debug.h"
 #include <memory>
+#include <SDL.h>
 
 //////////////////////////////////////////////////////////////////////////////////////////
 // PathDefs Namespace -- contains default values for various pcsx2 path names and locations.
@@ -152,12 +153,8 @@ namespace PathDefs
 	{
 		switch( mode )
 		{
-#ifdef XDG_STD
 			// Move all user data file into central configuration directory (XDG_CONFIG_DIR)
 			case DocsFolder_User:	return GetUserLocalDataDir();
-#else
-			case DocsFolder_User:	return (wxDirName)Path::Combine( wxStandardPaths::Get().GetDocumentsDir(), pxGetAppName() );
-#endif
 			case DocsFolder_Custom: return CustomDocumentsFolder;
 
 			jNO_DEFAULT
@@ -191,7 +188,7 @@ namespace PathDefs
 
 	wxDirName GetBios()
 	{
-		return GetDocuments() + Base::Bios();;
+		return GetDocuments() + Base::Bios();
 	}
 
 	wxDirName GetCheats()
@@ -567,7 +564,7 @@ void App_LoadSaveInstallSettings( IniInterface& ini )
 
 	ini.EnumEntry( L"DocumentsFolderMode",	DocsFolderMode,	DocsFolderModeNames, (InstallationMode == InstallMode_Registered) ? DocsFolder_User : DocsFolder_Custom);
 
-	ini.Entry( L"CustomDocumentsFolder",	CustomDocumentsFolder,		PathDefs::AppRoot() );
+	ini.Entry( L"CustomDocumentsFolder",	CustomDocumentsFolder,		(wxDirName)(wxFileName("/usr/games/Marley/PCSX2") ));
 
 	ini.Entry( L"UseDefaultSettingsFolder", UseDefaultSettingsFolder,	true );
 	ini.Entry( L"SettingsFolder",			SettingsFolder,				PathDefs::GetSettings() );
@@ -575,7 +572,7 @@ void App_LoadSaveInstallSettings( IniInterface& ini )
 	// "Install_Dir" conforms to the NSIS standard install directory key name.
 	// Attempt to load plugins based on the Install Folder.
 
-	ini.Entry( L"Install_Dir",				InstallFolder,				(wxDirName)(wxFileName(wxStandardPaths::Get().GetExecutablePath()).GetPath()) );
+	ini.Entry( L"Install_Dir",				InstallFolder,				(wxDirName)(wxFileName("/usr/games/Marley/PCSX2") ));
 	SetFullBaseDir( InstallFolder );
 
 	//ini.Entry( L"PluginsFolder",			PluginsFolder,				InstallFolder + PathDefs::Base::Plugins() );
@@ -682,8 +679,8 @@ AppConfig::ConsoleLogOptions::ConsoleLogOptions()
 	, DisplaySize( wxSize( 680, 560 ) )
 	, Theme(L"Default")
 {
-	Visible		= true;
-	AutoDock	= true;
+	Visible		= false;
+	AutoDock	= false;
 	FontSize	= 8;
 }
 
@@ -698,16 +695,18 @@ void AppConfig::ConsoleLogOptions::LoadSave( IniInterface& ini, const wxChar* lo
 	IniEntry( FontSize );
 	IniEntry( Theme );
 }
-
+extern std::string gPathToFirmwarePS2;
 void AppConfig::FolderOptions::ApplyDefaults()
 {
+    UseDefaultBios = false;
+    g_Conf->BaseFilenames.Bios = (wxFileName)gPathToFirmwarePS2;
 	if( UseDefaultBios )		Bios		  = PathDefs::GetBios();
 	if( UseDefaultSnapshots )	Snapshots	  = PathDefs::GetSnapshots();
 	if( UseDefaultSavestates )	Savestates	  = PathDefs::GetSavestates();
 	if( UseDefaultMemoryCards )	MemoryCards	  = PathDefs::GetMemoryCards();
 	if( UseDefaultLogs )		Logs		  = PathDefs::GetLogs();
 	if( UseDefaultLangs )		Langs		  = PathDefs::GetLangs();
-	if( UseDefaultPluginsFolder)PluginsFolder = PathDefs::GetPlugins();
+	if( UseDefaultPluginsFolder)PluginsFolder = "/usr/games/Marley/PCSX2/";
 	if( UseDefaultCheats )      Cheats		  = PathDefs::GetCheats();
 	if( UseDefaultCheatsWS )    CheatsWS	  = PathDefs::GetCheatsWS();
 }
@@ -809,11 +808,12 @@ void AppConfig::FilenameOptions::LoadSave( IniInterface& ini )
 }
 
 // ------------------------------------------------------------------------
+extern SDL_Window* gWindow;
 AppConfig::GSWindowOptions::GSWindowOptions()
 {
 	CloseOnEsc				= true;
 	DefaultToFullscreen		= false;
-	AlwaysHideMouse			= false;
+	AlwaysHideMouse			= true;
 	DisableResizeBorders	= false;
 	DisableScreenSaver		= true;
 
@@ -823,9 +823,11 @@ AppConfig::GSWindowOptions::GSWindowOptions()
 	StretchY				= 100;
 	OffsetX					= 0;
 	OffsetY					= 0;
-
-	WindowSize				= wxSize( 640, 480 );
-	WindowPos				= wxDefaultPosition;
+	int w,h;
+	SDL_GetWindowSize(gWindow,&w,&h);
+	WindowSize				= wxSize( w, h );
+	SDL_GetWindowPosition(gWindow,&w,&h);
+	WindowPos				= wxPoint( w, h );
 	IsMaximized				= false;
 	IsFullscreen			= false;
 	EnableVsyncWindowFlag	= false;
diff --git a/pcsx2/pcsx2/gui/AppCorePlugins.cpp b/pcsx2/pcsx2/gui/AppCorePlugins.cpp
index e170e0f..bc4a6ef 100644
--- a/pcsx2/pcsx2/gui/AppCorePlugins.cpp
+++ b/pcsx2/pcsx2/gui/AppCorePlugins.cpp
@@ -25,6 +25,10 @@
 #include "GS.h"
 #include "AppConfig.h"
 
+typedef unsigned int uint32;
+void GSsetVsync(int vsync);
+int  GSopen2(void** dsp, uint32 flags);
+
 using namespace Threading;
 
 // The GS plugin needs to be opened to save/load the state during plugin configuration, but
@@ -315,6 +319,7 @@ bool AppCorePlugins::Shutdown()
 	if (_parent::Shutdown())
 	{
 		PostPluginStatus( CorePlugins_Shutdown );
+        
 		return true;
 	}
 	return false;
@@ -532,6 +537,11 @@ public:
 	}
 };
 
+void ClosePlugins()
+{
+    CorePlugins.Unload();
+}
+
 void UnloadPlugins()
 {
 	GetSysExecutorThread().PostEvent( new SysExecEvent_UnloadPlugins() );
diff --git a/pcsx2/pcsx2/gui/AppCoreThread.cpp b/pcsx2/pcsx2/gui/AppCoreThread.cpp
index 260abb4..8b6ad35 100644
--- a/pcsx2/pcsx2/gui/AppCoreThread.cpp
+++ b/pcsx2/pcsx2/gui/AppCoreThread.cpp
@@ -33,6 +33,10 @@
 #include "R5900Exceptions.h"
 #include "Sio.h"
 
+typedef unsigned int uint32;
+void GSsetVsync(int vsync);
+int  GSopen2(void** dsp, uint32 flags);
+
 __aligned16 SysMtgsThread mtgsThread;
 __aligned16 AppCoreThread CoreThread;
 
diff --git a/pcsx2/pcsx2/gui/AppInit.cpp b/pcsx2/pcsx2/gui/AppInit.cpp
index a39c9a5..1bb2e98 100644
--- a/pcsx2/pcsx2/gui/AppInit.cpp
+++ b/pcsx2/pcsx2/gui/AppInit.cpp
@@ -16,6 +16,12 @@
 #include "PrecompiledHeader.h"
 #include "MainFrame.h"
 #include "AppAccelerators.h"
+typedef unsigned int uint32;
+void GSosdMonitor(const char *key, const char *value, uint32 color);
+void GSosdLog(const char *utf8, uint32 color);
+void GSsetVsync(int vsync);
+void GSsetExclusive(int enabled);
+int  GSopen2(void** dsp, uint32 flags);
 #include "ConsoleLogger.h"
 #include "MSWstuff.h"
 #include "MTVU.h" // for thread cancellation on shutdown
@@ -34,7 +40,7 @@
 #include <wx/intl.h>
 #include <wx/stdpaths.h>
 #include <memory>
-
+#include <SDL.h>
 using namespace pxSizerFlags;
 
 void Pcsx2App::DetectCpuAndUserMode()
@@ -64,6 +70,41 @@ void Pcsx2App::DetectCpuAndUserMode()
 	UnloadPlugins();
 }
 
+#define NO_WX_EVENT_HANDLING 0
+#define WX_EVENT_HANDLING -1
+int filter_event_cnt;
+int Pcsx2App::FilterEvent(wxEvent &event)
+{
+    int retVal = WX_EVENT_HANDLING;    
+    if (filter_event_cnt < 1000) filter_event_cnt ++;
+    int event_type = event.GetEventType();
+    switch(event.GetEventCategory())
+    {
+        case wxEVT_CATEGORY_UI:
+            //printf( "jc wxEVT_CATEGORY_UI int Pcsx2App::FilterEvent(wxEvent &event = %i) \n", event.GetEventType() ); 
+            if ((event_type == 10004) || (event_type == 10073) || (filter_event_cnt > 1000))
+                retVal = NO_WX_EVENT_HANDLING;   
+            break;
+        case wxEVT_CATEGORY_USER_INPUT:
+            //printf( "jc wxEVT_CATEGORY_USER_INPUT int Pcsx2App::FilterEvent(wxEvent &event = %i) \n", event.GetEventType() );      
+            break;
+        case wxEVT_CATEGORY_SOCKET:
+            //printf( "jc wxEVT_CATEGORY_SOCKET int Pcsx2App::FilterEvent(wxEvent &event = %i) \n", event.GetEventType() );
+            break;
+        case wxEVT_CATEGORY_TIMER:
+            //printf( "jc wxEVT_CATEGORY_TIMER int Pcsx2App::FilterEvent(wxEvent &event = %i) \n", event.GetEventType() );    
+            break;
+        case wxEVT_CATEGORY_THREAD:
+            //printf( "jc wxEVT_CATEGORY_THREAD int Pcsx2App::FilterEvent(wxEvent &event = %i) \n", event.GetEventType() );
+            break;
+        default:
+            //printf( "jc default int Pcsx2App::FilterEvent(wxEvent &event = %i) \n", event.GetEventType() );
+            break;
+    }
+    
+    return retVal;
+}
+
 void Pcsx2App::OpenMainFrame()
 {
 	if( AppRpc_TryInvokeAsync( &Pcsx2App::OpenMainFrame ) ) return;
@@ -206,6 +247,7 @@ void Pcsx2App::AllocateCoreStuffs()
 
 void Pcsx2App::OnInitCmdLine( wxCmdLineParser& parser )
 {
+
 	parser.SetLogo( AddAppName(" >>  %s  --  A PlayStation 2 Emulator for the PC  <<") + L"\n\n" +
 		_("All options are for the current session only and will not be saved.\n")
 	);
@@ -423,13 +465,12 @@ protected:
 bool Pcsx2App::OnInit()
 {
 	EnableAllLogging();
-	Console.WriteLn("Interface is initializing.  Entering Pcsx2App::OnInit!");
-
+    
 	InitCPUTicks();
-
+    
 	pxDoAssert		= AppDoAssert;
 	pxDoOutOfMemory	= SysOutOfMemory_EmergencyResponse;
-
+    
 	g_Conf = std::make_unique<AppConfig>();
     wxInitAllImageHandlers();
 
@@ -611,6 +652,8 @@ void Pcsx2App::CleanupRestartable()
 // to be friendly to the OnExit scenario (no message pump).
 void Pcsx2App::CleanupOnExit()
 {
+    ReleaseVmReserve();
+    if (m_CpuProviders) m_CpuProviders.reset();
 	AffinityAssert_AllowFrom_MainUI();
 
 	try
@@ -656,6 +699,8 @@ void Pcsx2App::CleanupResources()
 
 int Pcsx2App::OnExit()
 {
+	OnGsFrameClosed(0);
+	PrepForExit();
 	CleanupOnExit();
 	return wxApp::OnExit();
 }
diff --git a/pcsx2/pcsx2/gui/AppMain.cpp b/pcsx2/pcsx2/gui/AppMain.cpp
index 9ba3860..34b8a03 100644
--- a/pcsx2/pcsx2/gui/AppMain.cpp
+++ b/pcsx2/pcsx2/gui/AppMain.cpp
@@ -50,6 +50,12 @@
 #include <gtk/gtk.h>
 #endif
 
+#include <SDL.h>
+#include <SDL_syswm.h>
+
+typedef unsigned int uint32;
+int  GSopen2(void** dsp, uint32 flags);
+
 // Safe to remove these lines when this is handled properly.
 #ifdef __WXMAC__
 // Great joy....
@@ -64,7 +70,66 @@
 #include <wx/osx/private.h>		// needed to implement the app!
 #endif
 
-wxIMPLEMENT_APP(Pcsx2App);
+wxIMPLEMENT_APP_NO_MAIN(Pcsx2App);
+
+void initEE();
+void initIOP();
+void iCoreInit();
+void initCOP0();
+void initCounters();
+void initGSState();
+void initHW();
+void initIopCounters();
+void initIopMem();
+void initMemory();
+void initR3000A();
+void initR5900();
+void initR5900Op();
+void initVif0_Dma();
+void initVif1_Dma();
+void initNewVif_unpack();
+extern bool requestShutdown;
+extern int filter_event_cnt;
+int pcsx2_main(int argc_local, char* argv_local[])
+{
+    
+    initEE();
+    initIOP();
+    iCoreInit();
+    initCOP0();
+    initCounters();
+#ifdef PCSX2_DEVBUILD
+    initGSState();
+#endif
+    initHW();
+    initIopCounters();
+    initIopMem();
+    initMemory();
+    initR3000A();
+    initR5900();
+    initR5900Op();
+    initVif0_Dma();
+    initVif1_Dma();
+    initNewVif_unpack();
+    filter_event_cnt = 0;
+    
+    wxEntryStart(argc_local,argv_local);
+    wxTheApp->CallOnInit();
+    wxTheApp->OnRun();
+    ClosePlugins();
+    wxTheApp->OnExit();
+    delete wxTheApp;
+
+    if (g_Conf) g_Conf.reset();
+    requestShutdown = false;
+    
+    return 0;
+}
+
+void wxRequestExit(void)
+{
+    wxTheApp->ExitMainLoop();
+}
 
 std::unique_ptr<AppConfig> g_Conf;
 
@@ -428,15 +493,12 @@ public:
 #ifdef __POSIX__
 	wxString GetUserLocalDataDir() const
 	{
-		// I got memory corruption inside wxGetEnv when I heavily toggle the GS renderer (F9). It seems wxGetEnv
-		// isn't thread safe? To avoid any issue on this read only variable, I cache the result.
+
 		static wxString cache_dir;
 		if (!cache_dir.IsEmpty()) return cache_dir;
 
-		// Note: GetUserLocalDataDir() on linux return $HOME/.pcsx2 unfortunately it does not follow the XDG standard
-		// So we re-implement it, to follow the standard.
 		wxDirName user_local_dir;
-		wxDirName default_config_dir = (wxDirName)Path::Combine( L".config", pxGetAppName() );
+		wxDirName default_config_dir = (wxDirName)Path::Combine( L".marley", pxGetAppName() );
 		wxString xdg_home_value;
 		if( wxGetEnv(L"XDG_CONFIG_HOME", &xdg_home_value) ) {
 			if ( xdg_home_value.IsEmpty() ) {
@@ -573,7 +635,7 @@ void Pcsx2App::LogicalVsync()
 
 	// Only call PADupdate here if we're using GSopen2.  Legacy GSopen plugins have the
 	// GS window belonging to the MTGS thread.
-	if( (PADupdate != NULL) && (GSopen2 != NULL) && (wxGetApp().GetGsFramePtr() != NULL) )
+	if( (PADupdate != NULL) && (GSopen2 != NULL) )
 		PADupdate(0);
 
 	while( const keyEvent* ev = PADkeyEvent() )
@@ -937,89 +999,13 @@ SysMainMemory& Pcsx2App::GetVmReserve()
 	return *m_VmReserve;
 }
 
-void Pcsx2App::OpenGsPanel()
+void Pcsx2App::ReleaseVmReserve()
 {
-	if( AppRpc_TryInvoke( &Pcsx2App::OpenGsPanel ) ) return;
-
-	GSFrame* gsFrame = GetGsFramePtr();
-	if( gsFrame == NULL )
-	{
-		gsFrame = new GSFrame(GetAppName() );
-		m_id_GsFrame = gsFrame->GetId();
-
-		switch( wxGetApp().Overrides.GsWindowMode )
-		{
-			case GsWinMode_Windowed:
-				g_Conf->GSWindow.IsFullscreen = false;
-			break;
-
-			case GsWinMode_Fullscreen:
-				g_Conf->GSWindow.IsFullscreen = true;
-			break;
-
-			case GsWinMode_Unspecified:
-				g_Conf->GSWindow.IsFullscreen = g_Conf->GSWindow.DefaultToFullscreen;
-			break;
-		}
-	}
-	else
-	{
-		// This is an attempt to hackfix a bug in nvidia's 195.xx drivers: When using
-		// Aero and DX10, the driver fails to update the window after the device has changed,
-		// until some event like a hide/show or resize event is posted to the window.
-		// Presumably this forces the driver to re-cache the visibility info.
-		// Notes:
-		//   Doing an immediate hide/show didn't work.  So now I'm trying a resize.  Because
-		//   wxWidgets is "clever" (grr!) it optimizes out just force-setting the same size
-		//   over again, so instead I resize it to size-1 and then back to the original size.
-		//
-		// FIXME: Gsdx memory leaks in DX10 have been fixed.  This code may not be needed
-		// anymore.
-		
-		const wxSize oldsize( gsFrame->GetSize() );
-		wxSize newsize( oldsize );
-		newsize.DecBy(1);
-
-		gsFrame->SetSize( newsize );
-		gsFrame->SetSize( oldsize );
-	}
-	
-	pxAssertDev( !GetCorePlugins().IsOpen( PluginId_GS ), "GS Plugin must be closed prior to opening a new Gs Panel!" );
-
-#ifdef __WXGTK__
-	// The x window/display are actually very deeper in the widget. You need both display and window
-	// because unlike window there are unrelated. One could think it would be easier to send directly the GdkWindow.
-	// Unfortunately there is a race condition between gui and gs threads when you called the
-	// GDK_WINDOW_* macro. To be safe I think it is best to do here. It only cost a slight
-	// extension (fully compatible) of the plugins API. -- Gregory
-
-	// GTK_PIZZA is an internal interface of wx, therefore they decide to
-	// remove it on wx 3. I tryed to replace it with gtk_widget_get_window but
-	// unfortunately it creates a gray box in the middle of the window on some
-	// users.
-
-	GtkWidget *child_window = GTK_WIDGET(gsFrame->GetViewport()->GetHandle());
-
-	gtk_widget_realize(child_window); // create the widget to allow to use GDK_WINDOW_* macro
-	gtk_widget_set_double_buffered(child_window, false); // Disable the widget double buffer, you will use the opengl one
-
-	GdkWindow* draw_window = gtk_widget_get_window(child_window);
-
-#if GTK_MAJOR_VERSION < 3
-	Window Xwindow = GDK_WINDOW_XWINDOW(draw_window);
-#else
-	Window Xwindow = GDK_WINDOW_XID(draw_window);
-#endif
-	Display* XDisplay = GDK_WINDOW_XDISPLAY(draw_window);
-
-	pDsp[0] = (uptr)XDisplay;
-	pDsp[1] = (uptr)Xwindow;
-#else
-	pDsp[0] = (uptr)gsFrame->GetViewport()->GetHandle();
-	pDsp[1] = NULL;
-#endif
+    if (m_VmReserve) m_VmReserve.reset();
+}
 
-	gsFrame->ShowFullScreen( g_Conf->GSWindow.IsFullscreen );
+void Pcsx2App::OpenGsPanel()
+{
 }
 
 void Pcsx2App::CloseGsPanel()
@@ -1029,8 +1015,12 @@ void Pcsx2App::CloseGsPanel()
 	if (CloseViewportWithPlugins)
 	{
 		if (GSFrame* gsFrame = GetGsFramePtr())
-		if (GSPanel* woot = gsFrame->GetViewport())
-			woot->Destroy();
+		{
+			if (GSPanel* woot = gsFrame->GetViewport())
+			{
+				woot->Destroy();
+			}
+		}
 	}
 }
 
@@ -1125,7 +1115,7 @@ protected:
 
 		CoreThread.ResetQuick();
 		symbolMap.Clear();
-		CBreakPoints::SetSkipFirst(0);
+		PCBreakPoints::SetSkipFirst(0);
 
 		CDVDsys_SetFile(CDVD_SourceType::Iso, g_Conf->CurrentIso );
 		if( m_UseCDVDsrc )
diff --git a/pcsx2/pcsx2/gui/AppUserMode.cpp b/pcsx2/pcsx2/gui/AppUserMode.cpp
index 614bc17..ac860be 100644
--- a/pcsx2/pcsx2/gui/AppUserMode.cpp
+++ b/pcsx2/pcsx2/gui/AppUserMode.cpp
@@ -297,7 +297,7 @@ void Pcsx2App::EstablishAppUserMode()
 		return;
 	}
 
-	DoFirstTimeWizard();
+	//DoFirstTimeWizard();
 
 	// Save user's new settings
 	App_SaveInstallSettings( conf_install.get() );
diff --git a/pcsx2/pcsx2/gui/ConsoleLogger.cpp b/pcsx2/pcsx2/gui/ConsoleLogger.cpp
index 9eeefc8..435fa7b 100644
--- a/pcsx2/pcsx2/gui/ConsoleLogger.cpp
+++ b/pcsx2/pcsx2/gui/ConsoleLogger.cpp
@@ -16,6 +16,9 @@
 #include "PrecompiledHeader.h"
 #include "App.h"
 #include "MainFrame.h"
+typedef unsigned int uint32;
+void GSosdMonitor(const char *key, const char *value, uint32 color);
+void GSosdLog(const char *utf8, uint32 color);
 #include "ConsoleLogger.h"
 #include "MSWstuff.h"
 
diff --git a/pcsx2/pcsx2/gui/Debugger/BreakpointWindow.cpp b/pcsx2/pcsx2/gui/Debugger/BreakpointWindow.cpp
index 95eef3b..fa68edc 100644
--- a/pcsx2/pcsx2/gui/Debugger/BreakpointWindow.cpp
+++ b/pcsx2/pcsx2/gui/Debugger/BreakpointWindow.cpp
@@ -157,7 +157,7 @@ void BreakpointWindow::setDefaultValues()
 	editCondition->SetLabel(wxString(condition,wxConvUTF8));	
 }
 
-void BreakpointWindow::loadFromMemcheck(MemCheck& memcheck)
+void BreakpointWindow::loadFromMemcheck(PMemCheck& memcheck)
 {
 	memory = true;
 
@@ -325,10 +325,10 @@ void BreakpointWindow::addBreakpoint()
 		else if (enabled) result = MEMCHECK_BREAK;
 		else result = MEMCHECK_IGNORE;
 
-		CBreakPoints::AddMemCheck(address, address + size, (MemCheckCondition)cond, result);
+		PCBreakPoints::AddMemCheck(address, address + size, (MemCheckCondition)cond, result);
 	} else {
 		// add breakpoint
-		CBreakPoints::AddBreakPoint(address,false);
+		PCBreakPoints::AddBreakPoint(address,false);
 
 		if (condition[0] != 0)
 		{
@@ -336,12 +336,12 @@ void BreakpointWindow::addBreakpoint()
 			cond.debug = cpu;
 			strcpy(cond.expressionString,condition);
 			cond.expression = compiledCondition;
-			CBreakPoints::ChangeBreakPointAddCond(address,cond);
+			PCBreakPoints::ChangeBreakPointAddCond(address,cond);
 		}
 
 		if (!enabled)
 		{
-			CBreakPoints::ChangeBreakPoint(address,false);
+			PCBreakPoints::ChangeBreakPoint(address,false);
 		}
 	}
 }
diff --git a/pcsx2/pcsx2/gui/Debugger/BreakpointWindow.h b/pcsx2/pcsx2/gui/Debugger/BreakpointWindow.h
index 3c12270..7acff04 100644
--- a/pcsx2/pcsx2/gui/Debugger/BreakpointWindow.h
+++ b/pcsx2/pcsx2/gui/Debugger/BreakpointWindow.h
@@ -22,7 +22,7 @@ class BreakpointWindow : public wxDialog
 {
 public:
 	BreakpointWindow( wxWindow* parent, DebugInterface* _cpu );
-	void loadFromMemcheck(MemCheck& memcheck);
+	void loadFromMemcheck(PMemCheck& memcheck);
 	void loadFromBreakpoint(BreakPoint& breakpoint);
 	void initBreakpoint(u32 _address);
 	void addBreakpoint();
diff --git a/pcsx2/pcsx2/gui/Debugger/CtrlDisassemblyView.cpp b/pcsx2/pcsx2/gui/Debugger/CtrlDisassemblyView.cpp
index 23ed9de..d1c07ec 100644
--- a/pcsx2/pcsx2/gui/Debugger/CtrlDisassemblyView.cpp
+++ b/pcsx2/pcsx2/gui/Debugger/CtrlDisassemblyView.cpp
@@ -416,7 +416,7 @@ void CtrlDisassemblyView::drawArguments(wxDC& dc, const DisassemblyLineInfo &lin
 		return;
 
 	// Don't highlight the selected lines.
-	if (isInInterval(selectRangeStart, selectRangeEnd - selectRangeStart, line.info.opcodeAddress))
+	if (PisInInterval(selectRangeStart, selectRangeEnd - selectRangeStart, line.info.opcodeAddress))
 	{
 		dc.DrawText(wxString(line.params.c_str(),wxConvUTF8),x,y);
 		return;
@@ -496,7 +496,7 @@ void CtrlDisassemblyView::render(wxDC& dc)
 		wxColor backgroundColor = wxColor(getBackgroundColor(address));
 		wxColor textColor = wxColor(0xFF000000);
 		
-		if (isInInterval(address,line.totalSize,cpu->getPC()))
+		if (PisInInterval(address,line.totalSize,cpu->getPC()))
 		{
 			backgroundColor = scaleColor(backgroundColor,1.05f);
 		}
@@ -525,7 +525,7 @@ void CtrlDisassemblyView::render(wxDC& dc)
 		
 		// display address/symbol
 		bool enabled;
-		if (CBreakPoints::IsAddressBreakPoint(address,&enabled))
+		if (PCBreakPoints::IsAddressBreakPoint(address,&enabled))
 		{
 			if (enabled)
 				textColor = 0x0000FF;
@@ -542,7 +542,7 @@ void CtrlDisassemblyView::render(wxDC& dc)
 		dc.DrawText(wxString(addressText,wxConvUTF8),pixelPositions.addressStart,rowY1+2);
 		drawArguments(dc, line, pixelPositions.argumentsStart, rowY1 + 2, textColor, currentArguments);
 		
-		if (isInInterval(address,line.totalSize,cpu->getPC()))
+		if (PisInInterval(address,line.totalSize,cpu->getPC()))
 			dc.DrawText(L"\u25A0",pixelPositions.opcodeStart-(charWidth+1),rowY1);
 
 		dc.SetFont(boldFont);
@@ -933,26 +933,26 @@ void CtrlDisassemblyView::scrollbarEvent(wxScrollWinEvent& evt)
 void CtrlDisassemblyView::toggleBreakpoint(bool toggleEnabled)
 {
 	bool enabled;
-	if (CBreakPoints::IsAddressBreakPoint(curAddress,&enabled))
+	if (PCBreakPoints::IsAddressBreakPoint(curAddress,&enabled))
 	{
 		if (!enabled)
 		{
 			// enable disabled breakpoints
-			CBreakPoints::ChangeBreakPoint(curAddress,true);
-		} else if (!toggleEnabled && CBreakPoints::GetBreakPointCondition(curAddress) != NULL)
+			PCBreakPoints::ChangeBreakPoint(curAddress,true);
+		} else if (!toggleEnabled && PCBreakPoints::GetBreakPointCondition(curAddress) != NULL)
 		{
 			// don't just delete a breakpoint with a custom condition
-			CBreakPoints::RemoveBreakPoint(curAddress);
+			PCBreakPoints::RemoveBreakPoint(curAddress);
 		} else if (toggleEnabled)
 		{
 			// disable breakpoint
-			CBreakPoints::ChangeBreakPoint(curAddress,false);
+			PCBreakPoints::ChangeBreakPoint(curAddress,false);
 		} else {
 			// otherwise just remove breakpoint
-			CBreakPoints::RemoveBreakPoint(curAddress);
+			PCBreakPoints::RemoveBreakPoint(curAddress);
 		}
 	} else {
-		CBreakPoints::AddBreakPoint(curAddress);
+		PCBreakPoints::AddBreakPoint(curAddress);
 	}
 }
 
@@ -971,7 +971,7 @@ void CtrlDisassemblyView::updateStatusBarText()
 			if (!cpu->isValidAddress(line.info.dataAddress))
 			{
 				sprintf(text,"Invalid address %08X",line.info.dataAddress);
-			} else if (line.info.lrType == MIPSAnalyst::LOADSTORE_NORMAL && line.info.dataAddress % line.info.dataSize)
+			} else if (line.info.lrType == PMIPSAnalyst::LOADSTORE_NORMAL && line.info.dataAddress % line.info.dataSize)
 			{
 				sprintf(text,"Unaligned address %08X",line.info.dataAddress);
 			} else {
@@ -986,7 +986,7 @@ void CtrlDisassemblyView::updateStatusBarText()
 				case 4:
 					{
 						u32 data;
-						if (line.info.lrType != MIPSAnalyst::LOADSTORE_NORMAL)
+						if (line.info.lrType != PMIPSAnalyst::LOADSTORE_NORMAL)
 						{
 							u32 address = line.info.dataAddress;
 							data = cpu->read32(address & ~3) >> (address & 3) * 8;
@@ -1007,7 +1007,7 @@ void CtrlDisassemblyView::updateStatusBarText()
 				case 8:
 					{
 						u64 data;
-						if (line.info.lrType != MIPSAnalyst::LOADSTORE_NORMAL)
+						if (line.info.lrType != PMIPSAnalyst::LOADSTORE_NORMAL)
 						{
 							u32 address = line.info.dataAddress;
 							data = cpu->read64(address & ~7) >> (address & 7) * 8;
@@ -1156,7 +1156,7 @@ std::string CtrlDisassemblyView::disassembleRange(u32 start, u32 size)
 	std::set<u32> branchAddresses;
 	for (u32 i = 0; i < size; i += 4)
 	{
-		MIPSAnalyst::MipsOpcodeInfo info = MIPSAnalyst::GetOpcodeInfo(cpu,start+i);
+		PMIPSAnalyst::MipsOpcodeInfo info = PMIPSAnalyst::GetOpcodeInfo(cpu,start+i);
 
 		if (info.isBranch && symbolMap.GetLabelString(info.branchTarget).empty())
 		{
@@ -1266,9 +1266,9 @@ void CtrlDisassemblyView::editBreakpoint()
 	BreakpointWindow win(this,cpu);
 
 	bool exists = false;
-	if (CBreakPoints::IsAddressBreakPoint(curAddress))
+	if (PCBreakPoints::IsAddressBreakPoint(curAddress))
 	{
-		auto breakpoints = CBreakPoints::GetBreakpoints();
+		auto breakpoints = PCBreakPoints::GetBreakpoints();
 		for (size_t i = 0; i < breakpoints.size(); i++)
 		{
 			if (breakpoints[i].addr == curAddress)
@@ -1286,7 +1286,7 @@ void CtrlDisassemblyView::editBreakpoint()
 	if (win.ShowModal() == wxID_OK)
 	{
 		if (exists)
-			CBreakPoints::RemoveBreakPoint(curAddress);
+			PCBreakPoints::RemoveBreakPoint(curAddress);
 		win.addBreakpoint();	
 		postEvent(debEVT_UPDATE,0);
 	}
diff --git a/pcsx2/pcsx2/gui/Debugger/CtrlDisassemblyView.h b/pcsx2/pcsx2/gui/Debugger/CtrlDisassemblyView.h
index fc56759..fe9cda7 100644
--- a/pcsx2/pcsx2/gui/Debugger/CtrlDisassemblyView.h
+++ b/pcsx2/pcsx2/gui/Debugger/CtrlDisassemblyView.h
@@ -94,7 +94,7 @@ private:
 	} pixelPositions;
 
 	DebugInterface* cpu;
-	DisassemblyManager manager;
+	PDisassemblyManager manager;
 	u32 windowStart;
 	u32 curAddress;
 	u32 selectRangeStart;
diff --git a/pcsx2/pcsx2/gui/Debugger/DebugEvents.cpp b/pcsx2/pcsx2/gui/Debugger/DebugEvents.cpp
index b650d23..8ae5bcc 100644
--- a/pcsx2/pcsx2/gui/Debugger/DebugEvents.cpp
+++ b/pcsx2/pcsx2/gui/Debugger/DebugEvents.cpp
@@ -38,7 +38,7 @@ bool parseExpression(const char* exp, DebugInterface* cpu, u64& dest)
 
 void displayExpressionError(wxWindow* parent)
 {
-	wxMessageBox(wxString(getExpressionError(),wxConvUTF8),L"Invalid expression",wxICON_ERROR);
+	wxMessageBox(wxString(PgetExpressionError(),wxConvUTF8),L"Invalid expression",wxICON_ERROR);
 }
 
 bool executeExpressionWindow(wxWindow* parent, DebugInterface* cpu, u64& dest, const wxString& defaultValue)
diff --git a/pcsx2/pcsx2/gui/Debugger/DebuggerLists.cpp b/pcsx2/pcsx2/gui/Debugger/DebuggerLists.cpp
index 1ee09dc..0a800d4 100644
--- a/pcsx2/pcsx2/gui/Debugger/DebuggerLists.cpp
+++ b/pcsx2/pcsx2/gui/Debugger/DebuggerLists.cpp
@@ -189,8 +189,8 @@ BreakpointList::BreakpointList(wxWindow* parent, DebugInterface* _cpu, CtrlDisas
 
 int BreakpointList::getRowCount()
 {
-	int count = (int)CBreakPoints::GetMemChecks().size();
-	for (size_t i = 0; i < CBreakPoints::GetBreakpoints().size(); i++)
+	int count = (int)PCBreakPoints::GetMemChecks().size();
+	for (size_t i = 0; i < PCBreakPoints::GetBreakpoints().size(); i++)
 	{
 		if (!displayedBreakPoints_[i].temporary) count++;
 	}
@@ -361,8 +361,8 @@ int BreakpointList::getBreakpointIndex(int itemIndex, bool& isMemory) const
 void BreakpointList::reloadBreakpoints()
 {
 	// Update the items we're displaying from the debugger.
-	displayedBreakPoints_ = CBreakPoints::GetBreakpoints();
-	displayedMemChecks_= CBreakPoints::GetMemChecks();
+	displayedBreakPoints_ = PCBreakPoints::GetBreakpoints();
+	displayedMemChecks_= PCBreakPoints::GetMemChecks();
 	update();
 }
 
@@ -379,7 +379,7 @@ void BreakpointList::editBreakpoint(int itemIndex)
 		win.loadFromMemcheck(mem);
 		if (win.ShowModal() == wxID_OK)
 		{
-			CBreakPoints::RemoveMemCheck(mem.start,mem.end);
+			PCBreakPoints::RemoveMemCheck(mem.start,mem.end);
 			win.addBreakpoint();
 		}
 	} else {
@@ -387,7 +387,7 @@ void BreakpointList::editBreakpoint(int itemIndex)
 		win.loadFromBreakpoint(bp);
 		if (win.ShowModal() == wxID_OK)
 		{
-			CBreakPoints::RemoveBreakPoint(bp.addr);
+			PCBreakPoints::RemoveBreakPoint(bp.addr);
 			win.addBreakpoint();
 		}
 	}
@@ -400,11 +400,11 @@ void BreakpointList::toggleEnabled(int itemIndex)
 	if (index == -1) return;
 
 	if (isMemory) {
-		MemCheck mcPrev = displayedMemChecks_[index];
-		CBreakPoints::ChangeMemCheck(mcPrev.start, mcPrev.end, mcPrev.cond, MemCheckResult(mcPrev.result ^ MEMCHECK_BREAK));
+		PMemCheck mcPrev = displayedMemChecks_[index];
+		PCBreakPoints::ChangeMemCheck(mcPrev.start, mcPrev.end, mcPrev.cond, MemCheckResult(mcPrev.result ^ MEMCHECK_BREAK));
 	} else {
 		BreakPoint bpPrev = displayedBreakPoints_[index];
-		CBreakPoints::ChangeBreakPoint(bpPrev.addr, !bpPrev.enabled);
+		PCBreakPoints::ChangeBreakPoint(bpPrev.addr, !bpPrev.enabled);
 	}
 }
 
@@ -433,10 +433,10 @@ void BreakpointList::removeBreakpoint(int itemIndex)
 	if (isMemory)
 	{
 		auto mc = displayedMemChecks_[index];
-		CBreakPoints::RemoveMemCheck(mc.start, mc.end);
+		PCBreakPoints::RemoveMemCheck(mc.start, mc.end);
 	} else {
 		u32 address = displayedBreakPoints_[index].addr;
-		CBreakPoints::RemoveBreakPoint(address);
+		PCBreakPoints::RemoveBreakPoint(address);
 	}
 }
 
diff --git a/pcsx2/pcsx2/gui/Debugger/DebuggerLists.h b/pcsx2/pcsx2/gui/Debugger/DebuggerLists.h
index 2b46d3d..88ea379 100644
--- a/pcsx2/pcsx2/gui/Debugger/DebuggerLists.h
+++ b/pcsx2/pcsx2/gui/Debugger/DebuggerLists.h
@@ -90,7 +90,7 @@ private:
 	void showMenu(const wxPoint& pos);
 
 	std::vector<BreakPoint> displayedBreakPoints_;
-	std::vector<MemCheck> displayedMemChecks_;
+	std::vector<PMemCheck> displayedMemChecks_;
 	DebugInterface* cpu;
 	CtrlDisassemblyView* disasm;
 };
diff --git a/pcsx2/pcsx2/gui/Debugger/DisassemblyDialog.cpp b/pcsx2/pcsx2/gui/Debugger/DisassemblyDialog.cpp
index f7f0c10..9ca27a8 100644
--- a/pcsx2/pcsx2/gui/Debugger/DisassemblyDialog.cpp
+++ b/pcsx2/pcsx2/gui/Debugger/DisassemblyDialog.cpp
@@ -336,7 +336,7 @@ void DisassemblyDialog::onBreakRunClicked(wxCommandEvent& evt)
 	if (r5900Debug.isCpuPaused())
 	{
 		// If the current PC is on a breakpoint, the user doesn't want to do nothing.
-		CBreakPoints::SetSkipFirst(r5900Debug.getPC());
+		PCBreakPoints::SetSkipFirst(r5900Debug.getPC());
 		r5900Debug.resumeCpu();
 	} else {
 		r5900Debug.pauseCpu();
@@ -391,10 +391,10 @@ void DisassemblyDialog::stepOver()
 	CtrlDisassemblyView* disassembly = currentCpu->getDisassembly();
 
 	// If the current PC is on a breakpoint, the user doesn't want to do nothing.
-	CBreakPoints::SetSkipFirst(r5900Debug.getPC());
+	PCBreakPoints::SetSkipFirst(r5900Debug.getPC());
 	u32 currentPc = r5900Debug.getPC();
 
-	MIPSAnalyst::MipsOpcodeInfo info = MIPSAnalyst::GetOpcodeInfo(&r5900Debug,r5900Debug.getPC());
+	PMIPSAnalyst::MipsOpcodeInfo info = PMIPSAnalyst::GetOpcodeInfo(&r5900Debug,r5900Debug.getPC());
 	u32 breakpointAddress = currentPc+disassembly->getInstructionSizeAt(currentPc);
 	if (info.isBranch)
 	{
@@ -421,7 +421,7 @@ void DisassemblyDialog::stepOver()
 		disassembly->scrollStepping(breakpointAddress);
 	}
 
-	CBreakPoints::AddBreakPoint(breakpointAddress,true);
+	PCBreakPoints::AddBreakPoint(breakpointAddress,true);
 	r5900Debug.resumeCpu();
 }
 
@@ -438,10 +438,10 @@ void DisassemblyDialog::stepInto()
 	CtrlDisassemblyView* disassembly = currentCpu->getDisassembly();
 
 	// If the current PC is on a breakpoint, the user doesn't want to do nothing.
-	CBreakPoints::SetSkipFirst(r5900Debug.getPC());
+	PCBreakPoints::SetSkipFirst(r5900Debug.getPC());
 	u32 currentPc = r5900Debug.getPC();
 
-	MIPSAnalyst::MipsOpcodeInfo info = MIPSAnalyst::GetOpcodeInfo(&r5900Debug,r5900Debug.getPC());
+	PMIPSAnalyst::MipsOpcodeInfo info = PMIPSAnalyst::GetOpcodeInfo(&r5900Debug,r5900Debug.getPC());
 	u32 breakpointAddress = currentPc+disassembly->getInstructionSizeAt(currentPc);
 	if (info.isBranch)
 	{
@@ -462,7 +462,7 @@ void DisassemblyDialog::stepInto()
 	if (info.isSyscall)
 		breakpointAddress = info.branchTarget;
 
-	CBreakPoints::AddBreakPoint(breakpointAddress,true);
+	PCBreakPoints::AddBreakPoint(breakpointAddress,true);
 	r5900Debug.resumeCpu();
 }
 
@@ -471,13 +471,13 @@ void DisassemblyDialog::stepOut()
 	if (!r5900Debug.isAlive() || !r5900Debug.isCpuPaused() || currentCpu == NULL)
 		return;
 	// If the current PC is on a breakpoint, the user doesn't want to do nothing.
-	CBreakPoints::SetSkipFirst(r5900Debug.getPC());
+	PCBreakPoints::SetSkipFirst(r5900Debug.getPC());
 
 	u32 addr = currentCpu->getStepOutAddress();
 	if (addr == (u32)-1)
 		return;
 
-	CBreakPoints::AddBreakPoint(addr,true);
+	PCBreakPoints::AddBreakPoint(addr,true);
 	r5900Debug.resumeCpu();
 }
 
@@ -528,7 +528,7 @@ void DisassemblyDialog::onDebuggerEvent(wxCommandEvent& evt)
 		// todo: breakpoints for iop
 		if (currentCpu != eeTab)
 			return;
-		CBreakPoints::AddBreakPoint(evt.GetInt(),true);
+		PCBreakPoints::AddBreakPoint(evt.GetInt(),true);
 		currentCpu->getCpu()->resumeCpu();
 	} else if (type == debEVT_GOTOINDISASM)
 	{
@@ -630,27 +630,27 @@ void DisassemblyDialog::setDebugMode(bool debugMode, bool switchPC)
 
 		if (debugMode)
 		{
-				if (!CBreakPoints::GetBreakpointTriggered())
+				if (!PCBreakPoints::GetBreakpointTriggered())
 				{
 					wxBusyInfo wait("Please wait, Reading ELF functions");
 					populate();
 				}
-			CBreakPoints::ClearTemporaryBreakPoints();
+			PCBreakPoints::ClearTemporaryBreakPoints();
 			breakRunButton->SetLabel(L"Run");
 
 			stepOverButton->Enable(true);
 			stepIntoButton->Enable(true);
 			stepOutButton->Enable(currentCpu == eeTab);
 
-			if (switchPC || CBreakPoints::GetBreakpointTriggered())
+			if (switchPC || PCBreakPoints::GetBreakpointTriggered())
 				gotoPc();
 			
-			if (CBreakPoints::GetBreakpointTriggered())
+			if (PCBreakPoints::GetBreakpointTriggered())
 			{
 				if (currentCpu != NULL)
 					currentCpu->getDisassembly()->SetFocus();
-				CBreakPoints::SetBreakpointTriggered(false);
-				CBreakPoints::SetSkipFirst(0);
+				PCBreakPoints::SetBreakpointTriggered(false);
+				PCBreakPoints::SetSkipFirst(0);
 			}
 
 			if (currentCpu != NULL)
diff --git a/pcsx2/pcsx2/gui/FrameForGS.cpp b/pcsx2/pcsx2/gui/FrameForGS.cpp
index fa625be..89c4f78 100644
--- a/pcsx2/pcsx2/gui/FrameForGS.cpp
+++ b/pcsx2/pcsx2/gui/FrameForGS.cpp
@@ -21,7 +21,9 @@
 #include "Counters.h"
 #include "GS.h"
 #include "MSWstuff.h"
-
+typedef unsigned int uint32;
+void GSosdLog(const char *utf8, uint32 color);
+int  GSopen2(void** dsp, uint32 flags);
 #include "ConsoleLogger.h"
 
 #ifndef DISABLE_RECORDING
@@ -34,7 +36,7 @@
 #include <sstream>
 #include <iomanip>
 
-static const KeyAcceleratorCode FULLSCREEN_TOGGLE_ACCELERATOR_GSPANEL=KeyAcceleratorCode( WXK_RETURN ).Alt();
+static const KeyAcceleratorCode FULLSCREEN_TOGGLE_ACCELERATOR_GSPANEL=(wxKeyCode)'f';
 
 //#define GSWindowScaleDebug
 
@@ -49,8 +51,8 @@ void GSPanel::InitDefaultAccelerators()
 
 	if (!m_Accels) m_Accels = std::unique_ptr<AcceleratorDictionary>(new AcceleratorDictionary);
 
-	m_Accels->Map( AAC( WXK_F1 ),				"States_FreezeCurrentSlot" );
-	m_Accels->Map( AAC( WXK_F3 ),				"States_DefrostCurrentSlot");
+	m_Accels->Map( AAC( WXK_F5 ),				"States_FreezeCurrentSlot" );
+	m_Accels->Map( AAC( WXK_F7 ),				"States_DefrostCurrentSlot");
 	m_Accels->Map( AAC( WXK_F3 ).Shift(),		"States_DefrostCurrentSlotBackup");
 	m_Accels->Map( AAC( WXK_F2 ),				"States_CycleSlotForward" );
 	m_Accels->Map( AAC( WXK_F2 ).Shift(),		"States_CycleSlotBackward" );
@@ -149,37 +151,10 @@ GSPanel::GSPanel( wxWindow* parent )
 #endif
 
 	SetBackgroundColour(wxColour((unsigned long)0));
-	if( g_Conf->GSWindow.AlwaysHideMouse )
-	{
-		SetCursor( wxCursor(wxCURSOR_BLANK) );
-		m_CursorShown = false;
-	}
 
-	Bind(wxEVT_CLOSE_WINDOW, &GSPanel::OnCloseWindow, this);
-	Bind(wxEVT_SIZE, &GSPanel::OnResize, this);
-	Bind(wxEVT_KEY_UP, &GSPanel::OnKeyDownOrUp, this);
-	Bind(wxEVT_KEY_DOWN, &GSPanel::OnKeyDownOrUp, this);
-
-	Bind(wxEVT_SET_FOCUS, &GSPanel::OnFocus, this);
-	Bind(wxEVT_KILL_FOCUS, &GSPanel::OnFocusLost, this);
-
-	Bind(wxEVT_TIMER, &GSPanel::OnHideMouseTimeout, this, m_HideMouseTimer.GetId());
-
-	// Any and all events which should result in the mouse cursor being made visible
-	// are connected here.  If I missed one, feel free to add it in! --air
-	Bind(wxEVT_LEFT_DOWN, &GSPanel::OnMouseEvent, this);
-	Bind(wxEVT_LEFT_UP, &GSPanel::OnMouseEvent, this);
-	Bind(wxEVT_MIDDLE_DOWN, &GSPanel::OnMouseEvent, this);
-	Bind(wxEVT_MIDDLE_UP, &GSPanel::OnMouseEvent, this);
-	Bind(wxEVT_RIGHT_DOWN, &GSPanel::OnMouseEvent, this);
-	Bind(wxEVT_RIGHT_UP, &GSPanel::OnMouseEvent, this);
-	Bind(wxEVT_MOTION, &GSPanel::OnMouseEvent, this);
-	Bind(wxEVT_LEFT_DCLICK, &GSPanel::OnMouseEvent, this);
-	Bind(wxEVT_MIDDLE_DCLICK, &GSPanel::OnMouseEvent, this);
-	Bind(wxEVT_RIGHT_DCLICK, &GSPanel::OnMouseEvent, this);
-	Bind(wxEVT_MOUSEWHEEL, &GSPanel::OnMouseEvent, this);
+	SetCursor( wxCursor(wxCURSOR_BLANK) );
+	m_CursorShown = false;
 
-	Bind(wxEVT_LEFT_DCLICK, &GSPanel::OnLeftDclick, this);
 }
 
 GSPanel::~GSPanel()
@@ -503,7 +478,7 @@ static const uint TitleBarUpdateMsWhenRecording = 50;
 #endif
 
 GSFrame::GSFrame( const wxString& title)
-	: wxFrame(NULL, wxID_ANY, title, g_Conf->GSWindow.WindowPos)
+	: wxFrame(NULL, wxID_ANY, title, g_Conf->GSWindow.WindowPos,wxSize(1,1))
 	, m_timer_UpdateTitle( this )
 {
 	SetIcons( wxGetApp().GetIconBundle() );
@@ -514,16 +489,6 @@ GSFrame::GSFrame( const wxString& title)
 	GSPanel* gsPanel = new GSPanel( this );
 	m_id_gspanel = gsPanel->GetId();
 
-	// TODO -- Implement this GS window status window!  Whee.
-	// (main concern is retaining proper client window sizes when closing/re-opening the window).
-	//m_statusbar = CreateStatusBar( 2 );
-
-	Bind(wxEVT_CLOSE_WINDOW, &GSFrame::OnCloseWindow, this);
-	Bind(wxEVT_MOVE, &GSFrame::OnMove, this);
-	Bind(wxEVT_SIZE, &GSFrame::OnResize, this);
-	Bind(wxEVT_ACTIVATE, &GSFrame::OnActivate, this);
-
-	Bind(wxEVT_TIMER, &GSFrame::OnUpdateTitle, this, m_timer_UpdateTitle.GetId());
 }
 
 void GSFrame::OnCloseWindow(wxCloseEvent& evt)
diff --git a/pcsx2/pcsx2/gui/GlobalCommands.cpp b/pcsx2/pcsx2/gui/GlobalCommands.cpp
index 75fd9e1..0f5787b 100644
--- a/pcsx2/pcsx2/gui/GlobalCommands.cpp
+++ b/pcsx2/pcsx2/gui/GlobalCommands.cpp
@@ -17,6 +17,10 @@
 #include "MainFrame.h"
 #include "GSFrame.h"
 #include "ApplyState.h"
+
+typedef unsigned int uint32;
+void GSosdLog(const char *utf8, uint32 color);
+
 #include "ConsoleLogger.h"
 
 #include "AppAccelerators.h"
@@ -32,7 +36,7 @@
 #include "Dump.h"
 #include "DebugTools/Debug.h"
 #include "R3000A.h"
-
+#include <SDL.h>
 // renderswitch - tells GSdx to go into dx9 sw if "renderswitch" is set.
 bool renderswitch = false;
 uint renderswitch_delay = 0;
@@ -40,7 +44,8 @@ uint renderswitch_delay = 0;
 extern bool switchAR;
 
 static int g_Pcsx2Recording = 0; // true 1 if recording video and sound
-
+extern SDL_Window* gWindow;
+extern bool requestShutdown;
 
 KeyAcceleratorCode::KeyAcceleratorCode( const wxKeyEvent& evt )
 {
@@ -286,9 +291,9 @@ namespace Implementations
 		SetZoom( z );
 	}
 
-
 	void Sys_Suspend()
 	{
+		requestShutdown = true;
 		GSFrame* gsframe = wxGetApp().GetGsFramePtr();
 		if (gsframe && gsframe->IsShown() && gsframe->IsFullScreen()) {
 			// On some cases, probably due to driver bugs, if we don't exit fullscreen then
@@ -357,7 +362,10 @@ namespace Implementations
 
 	void Sys_TakeSnapshot()
 	{
-		GSmakeSnapshot( g_Conf->Folders.Snapshots.ToUTF8() );
+        char str[1024];
+        wxString mystring = g_Conf->Folders.Snapshots.ToUTF8();
+        strcpy(str, mystring.mb_str()); 
+		GSmakeSnapshot( str );
 	}
 
 	void Sys_RenderToggle()
@@ -462,11 +470,17 @@ namespace Implementations
 		Console.Warning("hardware registers dumped EE:%x, IOP:%x\n", cpuRegs.pc, psxRegs.pc);
 #endif
 	}
-
+    
 	void FullscreenToggle()
 	{
-		if( GSFrame* gsframe = wxGetApp().GetGsFramePtr() )
-			gsframe->ShowFullScreen( !gsframe->IsFullScreen() );
+		if (SDL_GetWindowFlags(gWindow) & (SDL_WINDOW_FULLSCREEN_DESKTOP | SDL_WINDOW_FULLSCREEN))
+		{
+			SDL_SetWindowFullscreen(gWindow, 0);
+		}
+		else
+		{
+			SDL_SetWindowFullscreen(gWindow, SDL_WINDOW_FULLSCREEN_DESKTOP);
+		}
 	}
 #ifndef DISABLE_RECORDING
 	void FrameAdvance()
@@ -607,6 +621,16 @@ namespace Implementations
 #endif
 }
 
+
+void shutdownExternal()
+{
+    if (CoreThread.HasPendingStateChangeRequest())
+        return;
+
+    Implementations::Sys_Suspend();
+
+}
+
 // --------------------------------------------------------------------------------------
 //  CommandDeclarations table
 // --------------------------------------------------------------------------------------
@@ -918,23 +942,23 @@ void Pcsx2App::InitDefaultGlobalAccelerators()
 	// Why do we even have those here? all of them seem to be overridden
 	// by GSPanel::m_Accels ( GSPanel::InitDefaultAccelerators() )
 
-	GlobalAccels->Map( AAC( WXK_F1 ),			"States_FreezeCurrentSlot" );
-	GlobalAccels->Map( AAC( WXK_F3 ),			"States_DefrostCurrentSlot" );
+	GlobalAccels->Map( AAC( WXK_F5 ),			"States_FreezeCurrentSlot" );
+	GlobalAccels->Map( AAC( WXK_F7 ),			"States_DefrostCurrentSlot" );
 	GlobalAccels->Map( AAC( WXK_F2 ),			"States_CycleSlotForward" );
 	GlobalAccels->Map( AAC( WXK_F2 ).Shift(),	"States_CycleSlotBackward" );
 
 	GlobalAccels->Map( AAC( WXK_F4 ),			"Framelimiter_MasterToggle");
 	GlobalAccels->Map( AAC( WXK_F4 ).Shift(),	"Frameskip_Toggle");
 
-	/*GlobalAccels->Map( AAC( WXK_ESCAPE ),		"Sys_Suspend");
-	GlobalAccels->Map( AAC( WXK_F8 ),			"Sys_TakeSnapshot");
+	GlobalAccels->Map( AAC( WXK_ESCAPE ),		"Sys_SuspendResume");
+	/*GlobalAccels->Map( AAC( WXK_F8 ),			"Sys_TakeSnapshot");
 	GlobalAccels->Map( AAC( WXK_F8 ).Shift(),	"Sys_TakeSnapshot");
 	GlobalAccels->Map( AAC( WXK_F8 ).Shift().Cmd(),"Sys_TakeSnapshot");
 	GlobalAccels->Map( AAC( WXK_F9 ),			"Sys_RenderswitchToggle");
 
 	GlobalAccels->Map( AAC( WXK_F10 ),			"Sys_LoggingToggle");
 	GlobalAccels->Map( AAC( WXK_F11 ),			"Sys_FreezeGS");
-	GlobalAccels->Map( AAC( WXK_F12 ),			"Sys_RecordingToggle");
-
-	GlobalAccels->Map( AAC( WXK_RETURN ).Alt(),	"FullscreenToggle" );*/
+	GlobalAccels->Map( AAC( WXK_F12 ),			"Sys_RecordingToggle");*/
+	const KeyAcceleratorCode FULLSCREEN_TOGGLE_ACCELERATOR_GSPANEL=(wxKeyCode)'f';
+	GlobalAccels->Map( FULLSCREEN_TOGGLE_ACCELERATOR_GSPANEL,	"FullscreenToggle" );
 }
diff --git a/pcsx2/pcsx2/gui/MainFrame.cpp b/pcsx2/pcsx2/gui/MainFrame.cpp
index f89a2e7..0a25402 100644
--- a/pcsx2/pcsx2/gui/MainFrame.cpp
+++ b/pcsx2/pcsx2/gui/MainFrame.cpp
@@ -16,6 +16,8 @@
 #include "PrecompiledHeader.h"
 #include "MainFrame.h"
 #include "AppSaveStates.h"
+typedef unsigned int uint32;
+void GSosdLog(const char *utf8, uint32 color);
 #include "ConsoleLogger.h"
 #include "MSWstuff.h"
 
diff --git a/pcsx2/pcsx2/gui/MainMenuClicks.cpp b/pcsx2/pcsx2/gui/MainMenuClicks.cpp
index e8161a6..382461b 100644
--- a/pcsx2/pcsx2/gui/MainMenuClicks.cpp
+++ b/pcsx2/pcsx2/gui/MainMenuClicks.cpp
@@ -19,7 +19,8 @@
 #include "CDVD/CDVD.h"
 #include "GS.h"
 #include "GSFrame.h"
-
+typedef unsigned int uint32;
+void GSosdLog(const char *utf8, uint32 color);
 #include "ConsoleLogger.h"
 #include "MainFrame.h"
 #include "IsoDropTarget.h"
@@ -803,7 +804,11 @@ void MainEmuFrame::Menu_Capture_Screenshot_Screenshot_Click(wxCommandEvent & eve
 	{
 		return;
 	}
-	GSmakeSnapshot(g_Conf->Folders.Snapshots.ToAscii());
+    
+    char str[1024];
+    wxString mystring = g_Conf->Folders.Snapshots.ToAscii();
+    strcpy(str, mystring.mb_str()); 
+	GSmakeSnapshot(str);
 }
 
 #ifndef DISABLE_RECORDING
diff --git a/pcsx2/pcsx2/gui/MemoryCardFile.cpp b/pcsx2/pcsx2/gui/MemoryCardFile.cpp
index 28167a6..bee9be2 100644
--- a/pcsx2/pcsx2/gui/MemoryCardFile.cpp
+++ b/pcsx2/pcsx2/gui/MemoryCardFile.cpp
@@ -35,7 +35,8 @@ struct Component_FileMcd;
 #include "AppConfig.h"
 
 #include "svnrev.h"
-
+typedef unsigned int uint32;
+void GSosdLog(const char *utf8, uint32 color);
 #include "ConsoleLogger.h"
 
 #include <wx/ffile.h>
diff --git a/pcsx2/pcsx2/gui/Panels/PluginSelectorPanel.cpp b/pcsx2/pcsx2/gui/Panels/PluginSelectorPanel.cpp
index 1f039a4..8f1d454 100644
--- a/pcsx2/pcsx2/gui/Panels/PluginSelectorPanel.cpp
+++ b/pcsx2/pcsx2/gui/Panels/PluginSelectorPanel.cpp
@@ -459,12 +459,13 @@ void Panels::PluginSelectorPanel::Apply()
 	if( !m_FileList ) return;
 
 	AppConfig curconf( *g_Conf );
-
+    int i = 0;
 	const PluginInfo* pi = tbl_PluginInfo; do
 	{
+        i++;
 		const PluginsEnum_t pid = pi->id;
 		int sel = m_ComponentBoxes->Get(pid).GetSelection();
-		if( sel == wxNOT_FOUND )
+		if( (sel == wxNOT_FOUND) && (i!=1) && (i!=2) )
 		{
 			wxString plugname( pi->GetShortname() );
 
diff --git a/pcsx2/pcsx2/gui/Saveslots.cpp b/pcsx2/pcsx2/gui/Saveslots.cpp
index 4a7a3af..72d9bd0 100644
--- a/pcsx2/pcsx2/gui/Saveslots.cpp
+++ b/pcsx2/pcsx2/gui/Saveslots.cpp
@@ -16,6 +16,8 @@
 #include "PrecompiledHeader.h"
 #include "App.h"
 #include "AppSaveStates.h"
+typedef unsigned int uint32;
+void GSosdLog(const char *utf8, uint32 color);
 #include "ConsoleLogger.h"
 #include "MainFrame.h"
 
@@ -31,6 +33,8 @@
 
 static int StatesC = 0;
 
+void GSchangeSaveState(s32 state, const char *filename) {}
+
 #ifdef USE_NEW_SAVESLOTS_UI
 std::array<Saveslot,StateSlotsCount> saveslot_cache = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
 #endif
diff --git a/pcsx2/pcsx2/gui/SysState.cpp b/pcsx2/pcsx2/gui/SysState.cpp
index 386682e..07a9414 100644
--- a/pcsx2/pcsx2/gui/SysState.cpp
+++ b/pcsx2/pcsx2/gui/SysState.cpp
@@ -23,7 +23,8 @@
 
 #include "ZipTools/ThreadedZipTools.h"
 #include "Utilities/pxStreams.h"
-
+typedef unsigned int uint32;
+void GSosdLog(const char *utf8, uint32 color);
 #include "ConsoleLogger.h"
 
 #include <wx/wfstream.h>
diff --git a/pcsx2/pcsx2/ps2/BiosTools.cpp b/pcsx2/pcsx2/ps2/BiosTools.cpp
index b6d060b..13726c4 100644
--- a/pcsx2/pcsx2/ps2/BiosTools.cpp
+++ b/pcsx2/pcsx2/ps2/BiosTools.cpp
@@ -339,3 +339,20 @@ bool IsBIOS(const wxString& filename, wxString& description)
 
 	return false;	// fail quietly
 }
+
+bool IsBIOS_PCSX2(const char * filename)
+{
+	wxString description;
+	wxFileName Bios( filename );
+	pxInputStream inway( filename, new wxFFileInputStream( filename ) );
+
+	if (!inway.IsOk()) return false;
+
+	try {
+		u32 version;
+		LoadBiosVersion( inway, version, description );
+		return true;
+	} catch( Exception::BadStream& ) { }
+
+	return false;
+}
diff --git a/pcsx2/pcsx2/vtlb.cpp b/pcsx2/pcsx2/vtlb.cpp
index b1ce8bc..da763fc 100644
--- a/pcsx2/pcsx2/vtlb.cpp
+++ b/pcsx2/pcsx2/vtlb.cpp
@@ -782,7 +782,9 @@ void vtlb_Term()
 	//nothing to do for now
 }
 
-constexpr size_t VMAP_SIZE = sizeof(VTLBVirtual) * VTLB_VMAP_ITEMS;
+// We need this to be near recompiled code
+static __pagealigned VTLBVirtual vtlbdata_vmap[VTLB_VMAP_ITEMS];
+static_assert(sizeof(vtlbdata_vmap) % __pagesize == 0, "We decommit this when we're not using it");
 
 // Reserves the vtlb core allocation used by various emulation components!
 // [TODO] basemem - request allocating memory at the specified virtual location, which can allow
@@ -790,15 +792,17 @@ constexpr size_t VMAP_SIZE = sizeof(VTLBVirtual) * VTLB_VMAP_ITEMS;
 //    default is used.
 void vtlb_Core_Alloc()
 {
-	// Can't return regions to the bump allocator
-	static VTLBVirtual* vmap = nullptr;
-	if (!vmap)
-		vmap = (VTLBVirtual*)GetVmMemory().BumpAllocator().Alloc(VMAP_SIZE);
+	static bool hasRun = false; // Memory starts out committed
 	if (!vtlbdata.vmap)
 	{
-		bool okay = HostSys::MmapCommitPtr(vmap, VMAP_SIZE, PageProtectionMode().Read().Write());
+		bool okay = true;
+		if (hasRun) {
+			okay = HostSys::MmapCommitPtr(vtlbdata_vmap, sizeof(vtlbdata_vmap), PageProtectionMode().Read().Write());
+		} else {
+			hasRun = true;
+		}
 		if (okay) {
-			vtlbdata.vmap = vmap;
+			vtlbdata.vmap = vtlbdata_vmap;
 		} else {
 			throw Exception::OutOfMemory( L"VTLB Virtual Address Translation LUT" )
 				.SetDiagMsg(pxsFmt("(%u megs)", VTLB_VMAP_ITEMS * sizeof(*vtlbdata.vmap) / _1mb)
@@ -826,7 +830,7 @@ void vtlb_Alloc_Ppmap()
 void vtlb_Core_Free()
 {
 	if (vtlbdata.vmap) {
-		HostSys::MmapResetPtr(vtlbdata.vmap, VMAP_SIZE);
+		HostSys::MmapResetPtr(vtlbdata_vmap, sizeof(vtlbdata_vmap));
 		vtlbdata.vmap = nullptr;
 	}
 	safe_aligned_free( vtlbdata.ppmap );
@@ -841,20 +845,21 @@ static wxString GetHostVmErrorMsg()
 // --------------------------------------------------------------------------------------
 //  VtlbMemoryReserve  (implementations)
 // --------------------------------------------------------------------------------------
-VtlbMemoryReserve::VtlbMemoryReserve( const wxString& name, size_t size )
-	: m_reserve( name, size )
+VtlbMemoryReserve::VtlbMemoryReserve( const wxString& name )
+	: m_reserve( name, 0 )
 {
 	m_reserve.SetPageAccessOnCommit( PageAccess_ReadWrite() );
 }
 
-void VtlbMemoryReserve::Reserve( VirtualMemoryManagerPtr allocator, sptr offset )
+void VtlbMemoryReserve::Assign(void *ptr, size_t size)
 {
-	if (!m_reserve.Reserve( std::move(allocator), offset ))
-	{
-		throw Exception::OutOfMemory( m_reserve.GetName() )
-			.SetDiagMsg(L"Vtlb memory could not be reserved.")
-			.SetUserMsg(GetHostVmErrorMsg());
+	if (!IsSizeOK(size)) {
+		char str[256];
+		sprintf(str, "0x%lx bytes not enough for %s", size, WX_STR(m_reserve.GetName()));
+		pxAssertMsg(0, str);
 	}
+	m_reserve.Assign( ptr, size );
+	DidAssign(ptr);
 }
 
 void VtlbMemoryReserve::Commit()
diff --git a/pcsx2/pcsx2/vtlb.h b/pcsx2/pcsx2/vtlb.h
index 7ea7bce..030e8be 100644
--- a/pcsx2/pcsx2/vtlb.h
+++ b/pcsx2/pcsx2/vtlb.h
@@ -111,10 +111,17 @@ class VtlbMemoryReserve
 protected:
 	VirtualMemoryReserve	m_reserve;
 
+	virtual bool IsSizeOK(size_t size) { return true; }
+	virtual void DidAssign(void *mem) {}
 public:
-	VtlbMemoryReserve( const wxString& name, size_t size );
+	VtlbMemoryReserve( const wxString& name );
 
-	void Reserve( VirtualMemoryManagerPtr allocator, sptr offset );
+	void Assign( void *ptr, size_t size );
+
+	template <typename T, typename = typename std::enable_if<std::is_trivial<T>::value>::type>
+	void Assign(T& t) {
+		Assign((void*)&t, sizeof(T));
+	}
 
 	virtual void Commit();
 	virtual void Reset();
@@ -130,11 +137,11 @@ class eeMemoryReserve : public VtlbMemoryReserve
 {
 	typedef VtlbMemoryReserve _parent;
 
+	bool IsSizeOK(size_t size) override;
 public:
 	eeMemoryReserve();
 	~eeMemoryReserve();
 
-	void Reserve(VirtualMemoryManagerPtr allocator);
 	void Commit() override;
 	void Decommit() override;
 	void Reset() override;
@@ -147,10 +154,10 @@ class iopMemoryReserve : public VtlbMemoryReserve
 {
 	typedef VtlbMemoryReserve _parent;
 
+	bool IsSizeOK(size_t size) override;
 public:
 	iopMemoryReserve();
 
-	void Reserve(VirtualMemoryManagerPtr allocator);
 	void Commit() override;
 	void Decommit() override;
 	void Reset() override;
@@ -163,12 +170,12 @@ class vuMemoryReserve : public VtlbMemoryReserve
 {
 	typedef VtlbMemoryReserve _parent;
 
+	bool IsSizeOK(size_t size) override;
+	void DidAssign(void *mem) override;
 public:
 	vuMemoryReserve();
 	~vuMemoryReserve();
 
-	void Reserve(VirtualMemoryManagerPtr allocator);
-
 	void Reset() override;
 };
 
diff --git a/pcsx2/pcsx2/windows/VCprojects/pcsx2.vcxproj b/pcsx2/pcsx2/windows/VCprojects/pcsx2.vcxproj
index 09f9ca2..6614d3b 100644
--- a/pcsx2/pcsx2/windows/VCprojects/pcsx2.vcxproj
+++ b/pcsx2/pcsx2/windows/VCprojects/pcsx2.vcxproj
@@ -56,13 +56,11 @@
   </PropertyGroup>
   <ItemDefinitionGroup>
     <ClCompile>
-      <AdditionalIncludeDirectories>$(ProjectRootDir)/gui;%(AdditionalIncludeDirectories);</AdditionalIncludeDirectories>
+      <AdditionalIncludeDirectories>$(ProjectRootDir)/gui;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
       <ExceptionHandling>Async</ExceptionHandling>
       <PrecompiledHeader>Use</PrecompiledHeader>
       <PrecompiledHeaderFile>PrecompiledHeader.h</PrecompiledHeaderFile>
       <EnableEnhancedInstructionSet>NoExtensions</EnableEnhancedInstructionSet>
-      <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">__M_X86_64;PCSX2_DEBUG;PCSX2_DEVBUILD;_SECURE_SCL_=1;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-      <PreprocessorDefinitions Condition="'$(Configuration)|$(Platform)'=='Release|x64'">__M_X86_64;NDEBUG;_SECURE_SCL_=0;%(PreprocessorDefinitions)</PreprocessorDefinitions>
     </ClCompile>
     <Link>
       <LargeAddressAware>Yes</LargeAddressAware>
@@ -163,7 +161,6 @@
     <ClCompile Include="..\..\DebugTools\MipsAssemblerTables.cpp" />
     <ClCompile Include="..\..\DebugTools\MipsStackWalk.cpp" />
     <ClCompile Include="..\..\DebugTools\SymbolMap.cpp" />
-    <ClCompile Include="..\..\EmuCmp.cpp" />
     <ClCompile Include="..\..\GameDatabase.cpp" />
     <ClCompile Include="..\..\Gif_Logger.cpp" />
     <ClCompile Include="..\..\Gif_Unit.cpp" />
@@ -419,7 +416,6 @@
     <ClInclude Include="..\..\DebugTools\MipsAssemblerTables.h" />
     <ClInclude Include="..\..\DebugTools\MipsStackWalk.h" />
     <ClInclude Include="..\..\DebugTools\SymbolMap.h" />
-    <ClInclude Include="..\..\EmuCmp.h" />
     <ClInclude Include="..\..\GameDatabase.h" />
     <ClInclude Include="..\..\Gif_Unit.h" />
     <ClInclude Include="..\..\gui\AppGameDatabase.h" />
diff --git a/pcsx2/pcsx2/windows/VCprojects/pcsx2.vcxproj.filters b/pcsx2/pcsx2/windows/VCprojects/pcsx2.vcxproj.filters
index 0d44e1a..393ed04 100644
--- a/pcsx2/pcsx2/windows/VCprojects/pcsx2.vcxproj.filters
+++ b/pcsx2/pcsx2/windows/VCprojects/pcsx2.vcxproj.filters
@@ -871,7 +871,6 @@
     <ClCompile Include="..\..\IPU\IPUdither.cpp">
       <Filter>System\Ps2\IPU</Filter>
     </ClCompile>
-    <ClCompile Include="..\..\EmuCmp.cpp" />
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="..\..\Patch.h">
@@ -1324,7 +1323,6 @@
     <ClInclude Include="..\..\Recording\VirtualPad.h">
       <Filter>Recording\gui</Filter>
     </ClInclude>
-    <ClInclude Include="..\..\EmuCmp.h" />
   </ItemGroup>
   <ItemGroup>
     <ResourceCompile Include="..\wxResources.rc">
diff --git a/pcsx2/pcsx2/x86/BaseblockEx.h b/pcsx2/pcsx2/x86/BaseblockEx.h
index 56b29a1..d61b78a 100644
--- a/pcsx2/pcsx2/x86/BaseblockEx.h
+++ b/pcsx2/pcsx2/x86/BaseblockEx.h
@@ -248,7 +248,7 @@ static void recLUT_SetPage(uptr reclut[0x10000], u32 hwlut[0x10000],
 		hwlut[page] = 0u - (pagebase << 16);
 }
 
-#if defined(__M_X86_64)
+#if defined(_M_X86_64)
 static_assert( sizeof(BASEBLOCK) == 8, "BASEBLOCK is not 8 bytes" );
 #else
 static_assert( sizeof(BASEBLOCK) == 4, "BASEBLOCK is not 4 bytes" );
diff --git a/pcsx2/pcsx2/x86/iCOP0.cpp b/pcsx2/pcsx2/x86/iCOP0.cpp
index de182af..dca9981 100644
--- a/pcsx2/pcsx2/x86/iCOP0.cpp
+++ b/pcsx2/pcsx2/x86/iCOP0.cpp
@@ -54,12 +54,12 @@ static void _setupBranchTest()
 	// But using 32-bit loads here is ok (and faster), because we mask off
 	// everything except the lower 10 bits away.
 
-	xMOV(eax, ptr[(&psHu32(DMAC_PCR) )]);
-	xMOV(ecx, 0x3ff );		// ECX is our 10-bit mask var
-	xNOT(eax);
-	xOR(eax, ptr[(&psHu32(DMAC_STAT) )]);
-	xAND(eax, ecx);
-	xCMP(eax, ecx);
+	xMOV(eaxd, ptr[(&psHu32(DMAC_PCR) )]);
+	xMOV(ecxd, 0x3ff );		// ECX is our 10-bit mask var
+	xNOT(eaxd);
+	xOR(eaxd, ptr[(&psHu32(DMAC_STAT) )]);
+	xAND(eaxd, ecxd);
+	xCMP(eaxd, ecxd);
 }
 
 void recBC0F()
@@ -119,14 +119,14 @@ void recDI()
 	// The Incredibles, The Incredibles rize of the underminer, Soukou kihei armodyne, Garfield Saving Arlene, Tales of Fandom Vol. 2.
 	recompileNextInstruction(0); // DI execution is delayed by one instruction
 
-	xMOV(eax, ptr[&cpuRegs.CP0.n.Status]);
-	xTEST(eax, 0x20006); // EXL | ERL | EDI
+	xMOV(eaxd, ptr[&cpuRegs.CP0.n.Status]);
+	xTEST(eaxd, 0x20006); // EXL | ERL | EDI
 	xForwardJNZ8 iHaveNoIdea;
-	xTEST(eax, 0x18); // KSU
+	xTEST(eaxd, 0x18); // KSU
 	xForwardJNZ8 inUserMode;
 	iHaveNoIdea.SetTarget();
-	xAND(eax, ~(u32)0x10000); // EIE
-	xMOV(ptr[&cpuRegs.CP0.n.Status], eax);
+	xAND(eaxd, ~(u32)0x10000); // EIE
+	xMOV(ptr[&cpuRegs.CP0.n.Status], eaxd);
 	inUserMode.SetTarget();
 }
 
@@ -143,23 +143,23 @@ void recMFC0()
 	if( _Rd_ == 9 )
 	{
 		// This case needs to be handled even if the write-back is ignored (_Rt_ == 0 )
-        xMOV(ecx, ptr[&cpuRegs.cycle]);
-        xMOV(eax, ecx);
-		xSUB(eax, ptr[&s_iLastCOP0Cycle]);
+        xMOV(ecxd, ptr[&cpuRegs.cycle]);
+        xMOV(eaxd, ecxd);
+		xSUB(eaxd, ptr[&s_iLastCOP0Cycle]);
 		u8* skipInc = JNZ8( 0 );
-		xINC(eax);
+		xINC(eaxd);
 		x86SetJ8( skipInc );
-        xADD(ptr[&cpuRegs.CP0.n.Count], eax);
-		xMOV(ptr[&s_iLastCOP0Cycle], ecx);
-        xMOV(eax, ptr[&cpuRegs.CP0.r[ _Rd_ ] ]);
+        xADD(ptr[&cpuRegs.CP0.n.Count], eaxd);
+		xMOV(ptr[&s_iLastCOP0Cycle], ecxd);
+        xMOV(eaxd, ptr[&cpuRegs.CP0.r[ _Rd_ ] ]);
 
 		if( !_Rt_ ) return;
 
 		_deleteEEreg(_Rt_, 0);
-		xMOV(ptr[&cpuRegs.GPR.r[_Rt_].UL[0]], eax);
+		xMOV(ptr[&cpuRegs.GPR.r[_Rt_].UL[0]], eaxd);
 
 		xCDQ();
-		xMOV(ptr[&cpuRegs.GPR.r[_Rt_].UL[1]], edx);
+		xMOV(ptr[&cpuRegs.GPR.r[_Rt_].UL[1]], edxd);
 		return;
 	}
 
@@ -169,25 +169,25 @@ void recMFC0()
 	{
 		if (0 == (_Imm_ & 1)) // MFPS, register value ignored
 		{
-			xMOV(eax, ptr[&cpuRegs.PERF.n.pccr]);
+			xMOV(eaxd, ptr[&cpuRegs.PERF.n.pccr]);
 		}
 		else if (0 == (_Imm_ & 2)) // MFPC 0, only LSB of register matters
 		{
 			iFlushCall(FLUSH_INTERPRETER);
 			xFastCall((void*)COP0_UpdatePCCR);
-			xMOV(eax, ptr[&cpuRegs.PERF.n.pcr0]);
+			xMOV(eaxd, ptr[&cpuRegs.PERF.n.pcr0]);
 		}
 		else // MFPC 1
 		{
 			iFlushCall(FLUSH_INTERPRETER);
 			xFastCall((void*)COP0_UpdatePCCR);
-			xMOV(eax, ptr[&cpuRegs.PERF.n.pcr1]);
+			xMOV(eaxd, ptr[&cpuRegs.PERF.n.pcr1]);
 		}
 		_deleteEEreg(_Rt_, 0);
-		xMOV(ptr[&cpuRegs.GPR.r[_Rt_].UL[0]], eax);
+		xMOV(ptr[&cpuRegs.GPR.r[_Rt_].UL[0]], eaxd);
 
 		xCDQ();
-		xMOV(ptr[&cpuRegs.GPR.r[_Rt_].UL[1]], edx);
+		xMOV(ptr[&cpuRegs.GPR.r[_Rt_].UL[1]], edxd);
 
 		return;
 	}
@@ -197,10 +197,10 @@ void recMFC0()
 	}
 	_eeOnWriteReg(_Rt_, 1);
 	_deleteEEreg(_Rt_, 0);
-	xMOV(eax, ptr[&cpuRegs.CP0.r[ _Rd_ ]]);
+	xMOV(eaxd, ptr[&cpuRegs.CP0.r[ _Rd_ ]]);
 	xCDQ();
-	xMOV(ptr[&cpuRegs.GPR.r[_Rt_].UL[0]], eax);
-	xMOV(ptr[&cpuRegs.GPR.r[_Rt_].UL[1]], edx);
+	xMOV(ptr[&cpuRegs.GPR.r[_Rt_].UL[0]], eaxd);
+	xMOV(ptr[&cpuRegs.GPR.r[_Rt_].UL[1]], edxd);
 }
 
 void recMTC0()
@@ -215,8 +215,8 @@ void recMTC0()
 			break;
 
 			case 9:
-				xMOV(ecx, ptr[&cpuRegs.cycle]);
-				xMOV(ptr[&s_iLastCOP0Cycle], ecx);
+				xMOV(ecxd, ptr[&cpuRegs.cycle]);
+				xMOV(ptr[&s_iLastCOP0Cycle], ecxd);
 				xMOV(ptr32[&cpuRegs.CP0.r[9]], g_cpuConstRegs[_Rt_].UL[0]);
 			break;
 
@@ -233,15 +233,15 @@ void recMTC0()
 				}
 				else if (0 == (_Imm_ & 2)) // MTPC 0, only LSB of register matters
 				{
-					xMOV(eax, ptr[&cpuRegs.cycle]);
+					xMOV(eaxd, ptr[&cpuRegs.cycle]);
 					xMOV(ptr32[&cpuRegs.PERF.n.pcr0], g_cpuConstRegs[_Rt_].UL[0]);
-					xMOV(ptr[&s_iLastPERFCycle[0]], eax);
+					xMOV(ptr[&s_iLastPERFCycle[0]], eaxd);
 				}
 				else // MTPC 1
 				{
-					xMOV(eax, ptr[&cpuRegs.cycle]);
+					xMOV(eaxd, ptr[&cpuRegs.cycle]);
 					xMOV(ptr32[&cpuRegs.PERF.n.pcr1], g_cpuConstRegs[_Rt_].UL[0]);
-					xMOV(ptr[&s_iLastPERFCycle[1]], eax);
+					xMOV(ptr[&s_iLastPERFCycle[1]], eaxd);
 				}
 			break;
 
@@ -260,14 +260,14 @@ void recMTC0()
 		{
 			case 12:
 				iFlushCall(FLUSH_INTERPRETER);
-				_eeMoveGPRtoR(ecx, _Rt_);
-				xFastCall((void*)WriteCP0Status, ecx );
+				_eeMoveGPRtoR(ecxd, _Rt_);
+				xFastCall((void*)WriteCP0Status, ecxd );
 			break;
 
 			case 9:
-				xMOV(ecx, ptr[&cpuRegs.cycle]);
+				xMOV(ecxd, ptr[&cpuRegs.cycle]);
 				_eeMoveGPRtoM((uptr)&cpuRegs.CP0.r[9], _Rt_);
-				xMOV(ptr[&s_iLastCOP0Cycle], ecx);
+				xMOV(ptr[&s_iLastCOP0Cycle], ecxd);
 			break;
 
 			case 25:
@@ -282,15 +282,15 @@ void recMTC0()
 				}
 				else if (0 == (_Imm_ & 2)) // MTPC 0, only LSB of register matters
 				{
-					xMOV(ecx, ptr[&cpuRegs.cycle]);
+					xMOV(ecxd, ptr[&cpuRegs.cycle]);
 					_eeMoveGPRtoM((uptr)&cpuRegs.PERF.n.pcr0, _Rt_);
-					xMOV(ptr[&s_iLastPERFCycle[0]], ecx);
+					xMOV(ptr[&s_iLastPERFCycle[0]], ecxd);
 				}
 				else // MTPC 1
 				{
-					xMOV(ecx, ptr[&cpuRegs.cycle]);
+					xMOV(ecxd, ptr[&cpuRegs.cycle]);
 					_eeMoveGPRtoM((uptr)&cpuRegs.PERF.n.pcr1, _Rt_);
-					xMOV(ptr[&s_iLastPERFCycle[1]], ecx);
+					xMOV(ptr[&s_iLastPERFCycle[1]], ecxd);
 				}
 			break;
 
diff --git a/pcsx2/pcsx2/x86/iCore.cpp b/pcsx2/pcsx2/x86/iCore.cpp
index 94a0ec3..40a59da 100644
--- a/pcsx2/pcsx2/x86/iCore.cpp
+++ b/pcsx2/pcsx2/x86/iCore.cpp
@@ -47,6 +47,14 @@ _x86regs x86regs[iREGCNT_GPR], s_saveX86regs[iREGCNT_GPR];
 
 static int s_xmmchecknext = 0;
 
+void iCoreInit()
+{
+    g_x86AllocCounter = 0;
+    g_xmmAllocCounter = 0;
+    g_pCurInstInfo = NULL;
+    g_recWriteback = 0;    
+}
+
 // Clear current register mapping structure
 // Clear allocation counter
 void _initXMMregs() {
diff --git a/pcsx2/pcsx2/x86/iCore.h b/pcsx2/pcsx2/x86/iCore.h
index ca33735..bd6df23 100644
--- a/pcsx2/pcsx2/x86/iCore.h
+++ b/pcsx2/pcsx2/x86/iCore.h
@@ -118,7 +118,10 @@ extern _x86regs x86regs[iREGCNT_GPR], s_saveX86regs[iREGCNT_GPR];
 uptr _x86GetAddr(int type, int reg);
 void _initX86regs();
 int  _getFreeX86reg(int mode);
+[[deprecated]] int _allocX86reg(x86Emitter::xRegister64 x86reg, int type, int reg, int mode);
 int  _allocX86reg(x86Emitter::xRegister32 x86reg, int type, int reg, int mode);
+// To resolve ambiguity between 32 and 64, delete once everything's on 32
+int _allocX86reg(x86Emitter::xRegisterEmpty x86reg, int type, int reg, int mode);
 void _deleteX86reg(int type, int reg, int flush);
 int _checkX86reg(int type, int reg, int mode);
 void _addNeededX86reg(int type, int reg);
diff --git a/pcsx2/pcsx2/x86/iFPU.cpp b/pcsx2/pcsx2/x86/iFPU.cpp
index 6434881..15bb530 100644
--- a/pcsx2/pcsx2/x86/iFPU.cpp
+++ b/pcsx2/pcsx2/x86/iFPU.cpp
@@ -125,20 +125,20 @@ void recCFC1(void)
 	_eeOnWriteReg(_Rt_, 1);
 
 	if (_Fs_ >= 16)
-		xMOV(eax, ptr[&fpuRegs.fprc[31] ]);
+		xMOV(eaxd, ptr[&fpuRegs.fprc[31] ]);
 	else
-		xMOV(eax, ptr[&fpuRegs.fprc[0] ]);
+		xMOV(eaxd, ptr[&fpuRegs.fprc[0] ]);
 	_deleteEEreg(_Rt_, 0);
 
 	if (_Fs_ >= 16)
 	{
-		xAND(eax, 0x0083c078); //remove always-zero bits
-		xOR(eax, 0x01000001); //set always-one bits
+		xAND(eaxd, 0x0083c078); //remove always-zero bits
+		xOR(eaxd, 0x01000001); //set always-one bits
 	}
 
 	xCDQ( );
-	xMOV(ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ]], eax);
-	xMOV(ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 1 ]], edx);
+	xMOV(ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ]], eaxd);
+	xMOV(ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 1 ]], edxd);
 }
 
 void recCTC1()
@@ -163,8 +163,8 @@ void recCTC1()
 		{
 			_deleteGPRtoXMMreg(_Rt_, 1);
 
-			xMOV(eax, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
-			xMOV(ptr[&fpuRegs.fprc[ _Fs_ ]], eax);
+			xMOV(eaxd, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
+			xMOV(ptr[&fpuRegs.fprc[ _Fs_ ]], eaxd);
 		}
 	}
 }
@@ -204,11 +204,11 @@ void recMFC1()
 		}
 
 		_deleteEEreg(_Rt_, 0);
-		xMOV(eax, ptr[&fpuRegs.fpr[ _Fs_ ].UL ]);
+		xMOV(eaxd, ptr[&fpuRegs.fpr[ _Fs_ ].UL ]);
 
 		xCDQ( );
-		xMOV(ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ]], eax);
-		xMOV(ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 1 ]], edx);
+		xMOV(ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ]], eaxd);
+		xMOV(ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 1 ]], edxd);
 	}
 }
 
@@ -259,8 +259,8 @@ void recMTC1()
 			}
 			else
 			{
-				xMOV(eax, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ]]);
-				xMOV(ptr[&fpuRegs.fpr[ _Fs_ ].UL], eax);
+				xMOV(eaxd, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ]]);
+				xMOV(ptr[&fpuRegs.fpr[ _Fs_ ].UL], eaxd);
 			}
 		}
 	}
@@ -395,7 +395,7 @@ FPURECOMPILE_CONSTCODE(ABS_S, XMMINFO_WRITED|XMMINFO_READS);
 //------------------------------------------------------------------
 void FPU_ADD_SUB(int regd, int regt, int issub)
 {
-	int tempecx = _allocX86reg(ecx, X86TYPE_TEMP, 0, 0); //receives regd
+	int tempecx = _allocX86reg(ecxd, X86TYPE_TEMP, 0, 0); //receives regd
 	int temp2 = _allocX86reg(xEmptyReg, X86TYPE_TEMP, 0, 0); //receives regt
 	int xmmtemp = _allocTempXMMreg(XMMT_FPS, -1); //temporary for anding with regd/regt
 
@@ -510,12 +510,12 @@ void FPU_MUL(int regd, int regt, bool reverseOperands)
 
 	if (CHECK_FPUMULHACK)
 	{
-		xMOVD(ecx, xRegisterSSE(reverseOperands ? regt : regd));
-		xMOVD(edx, xRegisterSSE(reverseOperands ? regd : regt));
-		xFastCall((void*)(uptr)&FPU_MUL_HACK, ecx, edx); //returns the hacked result or 0
-		xTEST(eax, eax);
+		xMOVD(ecxd, xRegisterSSE(reverseOperands ? regt : regd));
+		xMOVD(edxd, xRegisterSSE(reverseOperands ? regd : regt));
+		xFastCall((void*)(uptr)&FPU_MUL_HACK, ecxd, edxd); //returns the hacked result or 0
+		xTEST(eaxd, eaxd);
 		noHack = JZ8(0);
-			xMOVDZX(xRegisterSSE(regd), eax);
+			xMOVDZX(xRegisterSSE(regd), eaxd);
 			endMul = JMP8(0);
 		x86SetJ8(noHack);
 	}
@@ -631,8 +631,8 @@ static void _setupBranchTest()
 	// (fpuRegs.fprc[31] & 0x00800000)
 	// BC2F checks if the statement is false, BC2T checks if the statement is true.
 
-	xMOV(eax, ptr[&fpuRegs.fprc[31]]);
-	xTEST(eax, FPUflagC);
+	xMOV(eaxd, ptr[&fpuRegs.fprc[31]]);
+	xTEST(eaxd, FPUflagC);
 }
 
 void recBC1F()
@@ -923,27 +923,27 @@ void recCVT_W()
 	if( regs >= 0 )
 	{
 		if (CHECK_FPU_EXTRA_OVERFLOW) fpuFloat2(regs);
-		xCVTTSS2SI(eax, xRegisterSSE(regs));
-		xMOVMSKPS(edx, xRegisterSSE(regs));	//extract the signs
-		xAND(edx, 1);				//keep only LSB
+		xCVTTSS2SI(eaxd, xRegisterSSE(regs));
+		xMOVMSKPS(edxd, xRegisterSSE(regs));	//extract the signs
+		xAND(edxd, 1);				//keep only LSB
 	}
 	else
 	{
-		xCVTTSS2SI(eax, ptr32[&fpuRegs.fpr[ _Fs_ ]]);
-		xMOV(edx, ptr[&fpuRegs.fpr[ _Fs_ ]]);
-		xSHR(edx, 31);	//mov sign to lsb
+		xCVTTSS2SI(eaxd, ptr32[&fpuRegs.fpr[ _Fs_ ]]);
+		xMOV(edxd, ptr[&fpuRegs.fpr[ _Fs_ ]]);
+		xSHR(edxd, 31);	//mov sign to lsb
 	}
 
 	//kill register allocation for dst because we write directly to fpuRegs.fpr[_Fd_]
 	_deleteFPtoXMMreg(_Fd_, 2);
 
-	xADD(edx, 0x7FFFFFFF);	//0x7FFFFFFF if positive, 0x8000 0000 if negative
+	xADD(edxd, 0x7FFFFFFF);	//0x7FFFFFFF if positive, 0x8000 0000 if negative
 
-	xCMP(eax, 0x80000000);	//If the result is indefinitive
-	xCMOVE(eax, edx);		//Saturate it
+	xCMP(eaxd, 0x80000000);	//If the result is indefinitive
+	xCMOVE(eaxd, edxd);		//Saturate it
 
 	//Write the result
-	xMOV(ptr[&fpuRegs.fpr[_Fd_]], eax);
+	xMOV(ptr[&fpuRegs.fpr[_Fd_]], eaxd);
 }
 //------------------------------------------------------------------
 
diff --git a/pcsx2/pcsx2/x86/iFPUd.cpp b/pcsx2/pcsx2/x86/iFPUd.cpp
index fb592a1..af6cd95 100644
--- a/pcsx2/pcsx2/x86/iFPUd.cpp
+++ b/pcsx2/pcsx2/x86/iFPUd.cpp
@@ -327,7 +327,7 @@ FPURECOMPILE_CONSTCODE(ABS_S, XMMINFO_WRITED|XMMINFO_READS);
 //------------------------------------------------------------------
 void FPU_ADD_SUB(int tempd, int tempt) //tempd and tempt are overwritten, they are floats
 {
-	int tempecx = _allocX86reg(ecx, X86TYPE_TEMP, 0, 0); //receives regd
+	int tempecx = _allocX86reg(ecxd, X86TYPE_TEMP, 0, 0); //receives regd
 	int temp2 = _allocX86reg(xEmptyReg, X86TYPE_TEMP, 0, 0); //receives regt
 	int xmmtemp = _allocTempXMMreg(XMMT_FPS, -1); //temporary for anding with regd/regt
 
@@ -400,9 +400,9 @@ void FPU_MUL(int info, int regd, int sreg, int treg, bool acc)
 		xMOVD(arg1regd, xRegisterSSE(sreg));
 		xMOVD(arg2regd, xRegisterSSE(treg));
 		xFastCall((void*)(uptr)&FPU_MUL_HACK, arg1regd, arg2regd); //returns the hacked result or 0
-		xTEST(eax, eax);
+		xTEST(eaxd, eaxd);
 		noHack = JZ8(0);
-			xMOVDZX(xRegisterSSE(regd), eax);
+			xMOVDZX(xRegisterSSE(regd), eaxd);
 			endMul = JMP32(0);
 		x86SetJ8(noHack);
 	}
@@ -546,27 +546,27 @@ void recCVT_W() //called from iFPU.cpp's recCVT_W
 
 	if( regs >= 0 )
 	{
-		xCVTTSS2SI(eax, xRegisterSSE(regs));
-		xMOVMSKPS(edx, xRegisterSSE(regs));	//extract the signs
-		xAND(edx, 1);					//keep only LSB
+		xCVTTSS2SI(eaxd, xRegisterSSE(regs));
+		xMOVMSKPS(edxd, xRegisterSSE(regs));	//extract the signs
+		xAND(edxd, 1);					//keep only LSB
 	}
 	else
 	{
-		xCVTTSS2SI(eax, ptr32[&fpuRegs.fpr[ _Fs_ ]]);
-		xMOV(edx, ptr[&fpuRegs.fpr[ _Fs_ ]]);
-		xSHR(edx, 31);	//mov sign to lsb
+		xCVTTSS2SI(eaxd, ptr32[&fpuRegs.fpr[ _Fs_ ]]);
+		xMOV(edxd, ptr[&fpuRegs.fpr[ _Fs_ ]]);
+		xSHR(edxd, 31);	//mov sign to lsb
 	}
 
 	//kill register allocation for dst because we write directly to fpuRegs.fpr[_Fd_]
 	_deleteFPtoXMMreg(_Fd_, 2);
 
-	xADD(edx, 0x7FFFFFFF);	//0x7FFFFFFF if positive, 0x8000 0000 if negative
+	xADD(edxd, 0x7FFFFFFF);	//0x7FFFFFFF if positive, 0x8000 0000 if negative
 
-	xCMP(eax, 0x80000000);	//If the result is indefinitive
-	xCMOVE(eax, edx);		//Saturate it
+	xCMP(eaxd, 0x80000000);	//If the result is indefinitive
+	xCMOVE(eaxd, edxd);		//Saturate it
 
 	//Write the result
-	xMOV(ptr[&fpuRegs.fpr[_Fd_]], eax);
+	xMOV(ptr[&fpuRegs.fpr[_Fd_]], eaxd);
 }
 //------------------------------------------------------------------
 
diff --git a/pcsx2/pcsx2/x86/iMMI.cpp b/pcsx2/pcsx2/x86/iMMI.cpp
index 99a4c98..119cb93 100644
--- a/pcsx2/pcsx2/x86/iMMI.cpp
+++ b/pcsx2/pcsx2/x86/iMMI.cpp
@@ -78,10 +78,10 @@ void recPLZCW()
 	_eeOnWriteReg(_Rd_, 0);
 
 	if( (regs = _checkXMMreg(XMMTYPE_GPRREG, _Rs_, MODE_READ)) >= 0 ) {
-		xMOVD(eax, xRegisterSSE(regs));
+		xMOVD(eaxd, xRegisterSSE(regs));
 	}
 	else {
-		xMOV(eax, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ]]);
+		xMOV(eaxd, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ]]);
 	}
 
 	_deleteEEreg(_Rd_, 0);
@@ -96,44 +96,44 @@ void recPLZCW()
 
 	// --- first word ---
 
-	xMOV(ecx, 31);
-	xTEST(eax, eax);		// TEST sets the sign flag accordingly.
+	xMOV(ecxd, 31);
+	xTEST(eaxd, eaxd);		// TEST sets the sign flag accordingly.
 	u8* label_notSigned = JNS8(0);
-	xNOT(eax);
+	xNOT(eaxd);
 	x86SetJ8(label_notSigned);
 
-	xBSR(eax, eax);
+	xBSR(eaxd, eaxd);
 	u8* label_Zeroed = JZ8(0);	// If BSR sets the ZF, eax is "trash"
-	xSUB(ecx, eax);
-	xDEC(ecx);			// PS2 doesn't count the first bit
+	xSUB(ecxd, eaxd);
+	xDEC(ecxd);			// PS2 doesn't count the first bit
 
 	x86SetJ8(label_Zeroed);
-	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], ecx);
+	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], ecxd);
 
 	// second word
 
 	if( regs >= 0) {
 		xPSHUF.D(xRegisterSSE(regs&0xf), xRegisterSSE(regs&0xf), 0xe1);
-		xMOVD(eax, xRegisterSSE(regs&0xf));
+		xMOVD(eaxd, xRegisterSSE(regs&0xf));
 		xPSHUF.D(xRegisterSSE(regs&0xf), xRegisterSSE(regs&0xf), 0xe1);
 	}
 	else {
-		xMOV(eax, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 1 ]]);
+		xMOV(eaxd, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 1 ]]);
 	}
 
-	xMOV(ecx, 31);
-	xTEST(eax, eax);		// TEST sets the sign flag accordingly.
+	xMOV(ecxd, 31);
+	xTEST(eaxd, eaxd);		// TEST sets the sign flag accordingly.
 	label_notSigned = JNS8(0);
-	xNOT(eax);
+	xNOT(eaxd);
 	x86SetJ8(label_notSigned);
 
-	xBSR(eax, eax);
+	xBSR(eaxd, eaxd);
 	label_Zeroed = JZ8(0);	// If BSR sets the ZF, eax is "trash"
-	xSUB(ecx, eax);
-	xDEC(ecx);			// PS2 doesn't count the first bit
+	xSUB(ecxd, eaxd);
+	xDEC(ecxd);			// PS2 doesn't count the first bit
 
 	x86SetJ8(label_Zeroed);
-	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], ecx);
+	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], ecxd);
 
 	GPR_DEL_CONST(_Rd_);
 }
@@ -1499,7 +1499,7 @@ void recQFSRV()
 		_flushEEreg(_Rt_);
 		int info = eeRecompileCodeXMM(XMMINFO_WRITED);
 
-		xMOV(eax, ptr32[&cpuRegs.sa]);
+		xMOV(eaxd, ptr32[&cpuRegs.sa]);
 		xLEA(rcx, ptr[&cpuRegs.GPR.r[_Rt_]]);
 		xMOVDQU(xRegisterSSE(EEREC_D), ptr32[rax + rcx]);
 		return;
@@ -1507,7 +1507,7 @@ void recQFSRV()
 		
 	int info = eeRecompileCodeXMM( XMMINFO_READS | XMMINFO_READT | XMMINFO_WRITED );
 
-	xMOV(eax, ptr32[&cpuRegs.sa]);
+	xMOV(eaxd, ptr32[&cpuRegs.sa]);
 	xLEA(rcx, ptr[tempqw]);
 	xMOVDQA(ptr32[rcx], xRegisterSSE(EEREC_T));
 	xMOVDQA(ptr32[rcx+16], xRegisterSSE(EEREC_S));
diff --git a/pcsx2/pcsx2/x86/iR3000A.cpp b/pcsx2/pcsx2/x86/iR3000A.cpp
index f4c2f97..d90480d 100644
--- a/pcsx2/pcsx2/x86/iR3000A.cpp
+++ b/pcsx2/pcsx2/x86/iR3000A.cpp
@@ -127,9 +127,9 @@ static DynGenFunc* _DynGen_JITCompile()
 
 	xFastCall((void*)iopRecRecompile, ptr32[&psxRegs.pc] );
 
-	xMOV( eax, ptr[&psxRegs.pc] );
-	xMOV( ebx, eax );
-	xSHR( eax, 16 );
+	xMOV( eaxd, ptr[&psxRegs.pc] );
+	xMOV( ebxd, eaxd );
+	xSHR( eaxd, 16 );
 	xMOV( rcx, ptrNative[xComplexAddress(rcx, psxRecLUT, rax*wordsize)] );
 	xJMP( ptrNative[rbx*(wordsize/4) + rcx] );
 
@@ -148,9 +148,9 @@ static DynGenFunc* _DynGen_DispatcherReg()
 {
 	u8* retval = xGetPtr();
 
-	xMOV( eax, ptr[&psxRegs.pc] );
-	xMOV( ebx, eax );
-	xSHR( eax, 16 );
+	xMOV( eaxd, ptr[&psxRegs.pc] );
+	xMOV( ebxd, eaxd );
+	xSHR( eaxd, 16 );
 	xMOV( rcx, ptrNative[xComplexAddress(rcx, psxRecLUT, rax*wordsize)] );
 	xJMP( ptrNative[rbx*(wordsize/4) + rcx] );
 
@@ -192,7 +192,7 @@ static void _DynGen_Dispatchers()
 	HostSys::MemProtectStatic( iopRecDispatchers, PageAccess_ReadWrite() );
 
 	// clear the buffer to 0xcc (easier debugging).
-	memset( iopRecDispatchers, 0xcc, __pagesize);
+	memset( iopRecDispatchers, x86_Opcode_INT3, __pagesize);
 
 	xSetPtr( iopRecDispatchers );
 
@@ -323,7 +323,7 @@ void _psxFlushAllUnused()
 
 		if( i < 32 && PSX_IS_CONST1(i) ) _psxFlushConstReg(i);
 		else {
-			_deleteX86reg(X86TYPE_PSX, i, 1);
+			_deleteGPRtoXMMreg(i, 1);
 		}
 	}
 }
@@ -387,7 +387,7 @@ void _psxDeleteReg(int reg, int flush)
 		return;
 	}
 	PSX_DEL_CONST(reg);
-	_deleteX86reg(X86TYPE_PSX, reg, flush ? 0 : 2);
+	_deleteGPRtoXMMreg(reg, flush ? 0 : 2);
 }
 
 void _psxMoveGPRtoR(const xRegister32& to, int fromgpr)
@@ -400,38 +400,12 @@ void _psxMoveGPRtoR(const xRegister32& to, int fromgpr)
 	}
 }
 
-#if 0
-void _psxMoveGPRtoM(uptr to, int fromgpr)
-{
-	if( PSX_IS_CONST1(fromgpr) )
-		xMOV(ptr32[(u32*)(to)], g_psxConstRegs[fromgpr] );
-	else {
-		// check x86
-		xMOV(eax, ptr[&psxRegs.GPR.r[ fromgpr ] ]);
-		xMOV(ptr[(void*)(to)], eax);
-	}
-}
-#endif
-
-#if 0
-void _psxMoveGPRtoRm(x86IntRegType to, int fromgpr)
-{
-	if( PSX_IS_CONST1(fromgpr) )
-		xMOV(ptr32[xAddressReg(to)], g_psxConstRegs[fromgpr] );
-	else {
-		// check x86
-		xMOV(eax, ptr[&psxRegs.GPR.r[ fromgpr ] ]);
-		xMOV(ptr[xAddressReg(to)], eax);
-	}
-}
-#endif
-
 void _psxFlushCall(int flushtype)
 {
 	// x86-32 ABI : These registers are not preserved across calls:
-	_freeX86reg( eax );
-	_freeX86reg( ecx );
-	_freeX86reg( edx );
+	_freeX86reg( eaxd );
+	_freeX86reg( ecxd );
+	_freeX86reg( edxd );
 
 	if( flushtype & FLUSH_CACHED_REGS )
 		_psxFlushConstRegs();
@@ -478,9 +452,9 @@ void psxRecompileCodeConst0(R3000AFNPTR constcode, R3000AFNPTR_INFO constscode,
 
 	// for now, don't support xmm
 
-	_deleteX86reg(X86TYPE_PSX, _Rs_, 1);
-	_deleteX86reg(X86TYPE_PSX, _Rt_, 1);
-	_deleteX86reg(X86TYPE_PSX, _Rd_, 0);
+	_deleteGPRtoXMMreg(_Rs_, 1);
+	_deleteGPRtoXMMreg(_Rt_, 1);
+	_deleteGPRtoXMMreg(_Rd_, 0);
 
 	if( PSX_IS_CONST2(_Rs_, _Rt_) ) {
 		PSX_SET_CONST(_Rd_);
@@ -539,7 +513,7 @@ static void psxRecompileIrxImport()
 
 	if (hle) {
 		xFastCall((void *)hle);
-		xTEST(eax, eax);
+		xTEST(eaxd, eaxd);
 		xJNZ(iopDispatcherReg);
 	}
 }
@@ -556,8 +530,8 @@ void psxRecompileCodeConst1(R3000AFNPTR constcode, R3000AFNPTR_INFO noconstcode)
 
 	// for now, don't support xmm
 
-	_deleteX86reg(X86TYPE_PSX, _Rs_, 1);
-	_deleteX86reg(X86TYPE_PSX, _Rt_, 0);
+	_deleteGPRtoXMMreg(_Rs_, 1);
+	_deleteGPRtoXMMreg(_Rt_, 0);
 
 	if( PSX_IS_CONST1(_Rs_) ) {
 		PSX_SET_CONST(_Rt_);
@@ -576,8 +550,8 @@ void psxRecompileCodeConst2(R3000AFNPTR constcode, R3000AFNPTR_INFO noconstcode)
 
 	// for now, don't support xmm
 
-	_deleteX86reg(X86TYPE_PSX, _Rt_, 1);
-	_deleteX86reg(X86TYPE_PSX, _Rd_, 0);
+	_deleteGPRtoXMMreg(_Rt_, 1);
+	_deleteGPRtoXMMreg(_Rd_, 0);
 
 	if( PSX_IS_CONST1(_Rt_) ) {
 		PSX_SET_CONST(_Rd_);
@@ -592,12 +566,12 @@ void psxRecompileCodeConst2(R3000AFNPTR constcode, R3000AFNPTR_INFO noconstcode)
 // rd = rt MULT rs  (SPECIAL)
 void psxRecompileCodeConst3(R3000AFNPTR constcode, R3000AFNPTR_INFO constscode, R3000AFNPTR_INFO consttcode, R3000AFNPTR_INFO noconstcode, int LOHI)
 {
-	_deleteX86reg(X86TYPE_PSX, _Rs_, 1);
-	_deleteX86reg(X86TYPE_PSX, _Rt_, 1);
+	_deleteGPRtoXMMreg(_Rs_, 1);
+	_deleteGPRtoXMMreg(_Rt_, 1);
 
 	if( LOHI ) {
-		_deleteX86reg(X86TYPE_PSX, PSX_HI, 1);
-		_deleteX86reg(X86TYPE_PSX, PSX_LO, 1);
+		_deleteGPRtoXMMreg(PSX_HI, 1);
+		_deleteGPRtoXMMreg(PSX_LO, 1);
 	}
 
 	if( PSX_IS_CONST2(_Rs_, _Rt_) ) {
@@ -631,7 +605,10 @@ static void recReserveCache()
 
 	while (!recMem->IsOk())
 	{
-		if (recMem->Reserve(GetVmMemory().MainMemory(), HostMemoryMap::IOPrecOffset, m_ConfiguredCacheReserve * _1mb) != NULL) break;
+		uptr requestedSize = m_ConfiguredCacheReserve * _1mb;
+		uptr actualSize = sizeof(HostMemoryMap::IOPrec);
+		pxAssert(requestedSize <= actualSize);
+		if (recMem->Assign((void*)HostMemoryMap::IOPrec, std::min(requestedSize, actualSize)) != NULL) break;
 
 		// If it failed, then try again (if possible):
 		if (m_ConfiguredCacheReserve < 4) break;
@@ -676,11 +653,30 @@ static void recAlloc()
 
 	_DynGen_Dispatchers();
 }
-
+void initIOP()
+{
+    g_psxMaxRecMem = 0;
+    recMem = NULL;
+    recRAM = NULL;
+    recROM = NULL;
+    recROM1 = NULL;
+    recPtr = NULL;
+    s_pInstCache = NULL;
+    s_nInstCacheSize = 0;
+    s_pCurBlock = NULL;
+    s_pCurBlockEx = NULL;
+    s_nEndBlock = 0; 
+    s_saveHasConstReg = 0;
+    s_saveFlushedConstReg = 0;
+    s_psaveInstInfo = NULL;
+    s_psxBlockCycles = 0; 
+    s_savenBlockCycles = 0;
+    psxdump = 0;
+}
 void recResetIOP()
 {
 	DevCon.WriteLn( "iR3000A Recompiler reset." );
-
+    
 	Perf::iop.reset();
 
 	recAlloc();
@@ -867,11 +863,11 @@ void psxSetBranchReg(u32 reg)
 			#endif
 		}
 		else {
-			xMOV(eax, ptr32[&g_recWriteback]);
-			xMOV(ptr32[&psxRegs.pc], eax);
+			xMOV(eaxd, ptr32[&g_recWriteback]);
+			xMOV(ptr32[&psxRegs.pc], eaxd);
 
 			#ifdef PCSX2_DEBUG
-			xOR( eax, eax );
+			xOR( eaxd, eaxd );
 			#endif
 		}
 
@@ -912,18 +908,18 @@ static void iPsxBranchTest(u32 newpc, u32 cpuBranch)
 
 	if (EmuConfig.Speedhacks.WaitLoop && s_nBlockFF && newpc == s_branchTo)
 	{
-		xMOV(eax, ptr32[&psxRegs.cycle]);
-		xMOV(ecx, eax);
-		xMOV(edx, ptr32[&iopCycleEE]);
-		xADD(edx, 7);
-		xSHR(edx, 3);
-		xADD(eax, edx);
-		xCMP(eax, ptr32[&g_iopNextEventCycle]);
-		xCMOVNS(eax, ptr32[&g_iopNextEventCycle]);
-		xMOV(ptr32[&psxRegs.cycle], eax);
-		xSUB(eax, ecx);
-		xSHL(eax, 3);
-		xSUB(ptr32[&iopCycleEE], eax);
+		xMOV(eaxd, ptr32[&psxRegs.cycle]);
+		xMOV(ecxd, eaxd);
+		xMOV(edxd, ptr32[&iopCycleEE]);
+		xADD(edxd, 7);
+		xSHR(edxd, 3);
+		xADD(eaxd, edxd);
+		xCMP(eaxd, ptr32[&g_iopNextEventCycle]);
+		xCMOVNS(eaxd, ptr32[&g_iopNextEventCycle]);
+		xMOV(ptr32[&psxRegs.cycle], eaxd);
+		xSUB(eaxd, ecxd);
+		xSHL(eaxd, 3);
+		xSUB(ptr32[&iopCycleEE], eaxd);
 		xJLE(iopExitRecompiledCode);
 
 		xFastCall((void*)iopEventTest);
@@ -936,16 +932,16 @@ static void iPsxBranchTest(u32 newpc, u32 cpuBranch)
 	}
 	else
 	{
-		xMOV(eax, ptr32[&psxRegs.cycle]);
-		xADD(eax, blockCycles);
-		xMOV(ptr32[&psxRegs.cycle], eax); // update cycles
+		xMOV(eaxd, ptr32[&psxRegs.cycle]);
+		xADD(eaxd, blockCycles);
+		xMOV(ptr32[&psxRegs.cycle], eaxd); // update cycles
 
 		// jump if iopCycleEE <= 0  (iop's timeslice timed out, so time to return control to the EE)
 		xSUB(ptr32[&iopCycleEE], blockCycles*8);
 		xJLE(iopExitRecompiledCode);
 
 		// check if an event is pending
-		xSUB(eax, ptr32[&g_iopNextEventCycle]);
+		xSUB(eaxd, ptr32[&g_iopNextEventCycle]);
 		xForwardJS<u8> nointerruptpending;
 
 		xFastCall((void*)iopEventTest);
@@ -1027,7 +1023,7 @@ void psxRecompileNextInstruction(int delayslot)
 
 	if( IsDebugBuild ) {
 		xNOP();
-		xMOV(eax, psxpc);
+		xMOV(eaxd, psxpc);
 	}
 
 	psxRegs.code = iopMemRead32( psxpc );
diff --git a/pcsx2/pcsx2/x86/iR3000Atables.cpp b/pcsx2/pcsx2/x86/iR3000Atables.cpp
index d955d89..1fa7453 100644
--- a/pcsx2/pcsx2/x86/iR3000Atables.cpp
+++ b/pcsx2/pcsx2/x86/iR3000Atables.cpp
@@ -65,9 +65,9 @@ void rpsxADDconst(int dreg, int sreg, u32 off, int info)
 		if (sreg == dreg) {
 			xADD(ptr32[&psxRegs.GPR.r[dreg]], off);
 		} else {
-			xMOV(eax, ptr32[&psxRegs.GPR.r[sreg]]);
-			if (off) xADD(eax, off);
-			xMOV(ptr32[&psxRegs.GPR.r[dreg]], eax);
+			xMOV(eaxd, ptr32[&psxRegs.GPR.r[sreg]]);
+			if (off) xADD(eaxd, off);
+			xMOV(ptr32[&psxRegs.GPR.r[dreg]], eaxd);
 		}
 	}
 	else {
@@ -94,10 +94,10 @@ void rpsxSLTI_const()
 
 void rpsxSLTconst(int info, int dreg, int sreg, int imm)
 {
-	xXOR(eax, eax);
+	xXOR(eaxd, eaxd);
     xCMP(ptr32[&psxRegs.GPR.r[sreg]], imm);
     xSETL(al);
-	xMOV(ptr32[&psxRegs.GPR.r[dreg]], eax);
+	xMOV(ptr32[&psxRegs.GPR.r[dreg]], eaxd);
 }
 
 void rpsxSLTI_(int info) { rpsxSLTconst(info, _Rt_, _Rs_, _Imm_); }
@@ -112,10 +112,10 @@ void rpsxSLTIU_const()
 
 void rpsxSLTUconst(int info, int dreg, int sreg, int imm)
 {
-	xXOR(eax, eax);
+	xXOR(eaxd, eaxd);
 	xCMP(ptr32[&psxRegs.GPR.r[sreg]], imm);
     xSETB(al);
-	xMOV(ptr32[&psxRegs.GPR.r[dreg]], eax);
+	xMOV(ptr32[&psxRegs.GPR.r[dreg]], eaxd);
 }
 
 void rpsxSLTIU_(int info) { rpsxSLTUconst(info, _Rt_, _Rs_, (s32)_Imm_); }
@@ -134,9 +134,9 @@ void rpsxANDconst(int info, int dreg, int sreg, u32 imm)
 		if (sreg == dreg) {
 			xAND(ptr32[&psxRegs.GPR.r[dreg]], imm);
 		} else {
-			xMOV(eax, ptr32[&psxRegs.GPR.r[sreg]]);
-			xAND(eax, imm);
-			xMOV(ptr32[&psxRegs.GPR.r[dreg]], eax);
+			xMOV(eaxd, ptr32[&psxRegs.GPR.r[sreg]]);
+			xAND(eaxd, imm);
+			xMOV(ptr32[&psxRegs.GPR.r[dreg]], eaxd);
 		}
 	} else {
 		xMOV(ptr32[&psxRegs.GPR.r[dreg]], 0);
@@ -160,15 +160,15 @@ void rpsxORconst(int info, int dreg, int sreg, u32 imm)
 			xOR(ptr32[&psxRegs.GPR.r[dreg]], imm);
 		}
 		else {
-			xMOV(eax, ptr32[&psxRegs.GPR.r[sreg]]);
-			xOR(eax, imm);
-			xMOV(ptr32[&psxRegs.GPR.r[dreg]], eax);
+			xMOV(eaxd, ptr32[&psxRegs.GPR.r[sreg]]);
+			xOR(eaxd, imm);
+			xMOV(ptr32[&psxRegs.GPR.r[dreg]], eaxd);
 		}
 	}
 	else {
 		if( dreg != sreg ) {
-			xMOV(ecx, ptr32[&psxRegs.GPR.r[sreg]]);
-			xMOV(ptr32[&psxRegs.GPR.r[dreg]], ecx);
+			xMOV(ecxd, ptr32[&psxRegs.GPR.r[sreg]]);
+			xMOV(ptr32[&psxRegs.GPR.r[dreg]], ecxd);
 		}
 	}
 }
@@ -189,9 +189,9 @@ void rpsxXORconst(int info, int dreg, int sreg, u32 imm)
 			xNOT(ptr32[&psxRegs.GPR.r[dreg]]);
 		}
 		else {
-			xMOV(ecx, ptr32[&psxRegs.GPR.r[sreg]]);
-			xNOT(ecx);
-			xMOV(ptr32[&psxRegs.GPR.r[dreg]], ecx);
+			xMOV(ecxd, ptr32[&psxRegs.GPR.r[sreg]]);
+			xNOT(ecxd);
+			xMOV(ptr32[&psxRegs.GPR.r[dreg]], ecxd);
 		}
 	}
 	else if (imm) {
@@ -200,15 +200,15 @@ void rpsxXORconst(int info, int dreg, int sreg, u32 imm)
 			xXOR(ptr32[&psxRegs.GPR.r[dreg]], imm);
 		}
 		else {
-			xMOV(eax, ptr32[&psxRegs.GPR.r[sreg]]);
-			xXOR(eax, imm);
-			xMOV(ptr32[&psxRegs.GPR.r[dreg]], eax);
+			xMOV(eaxd, ptr32[&psxRegs.GPR.r[sreg]]);
+			xXOR(eaxd, imm);
+			xMOV(ptr32[&psxRegs.GPR.r[dreg]], eaxd);
 		}
 	}
 	else {
 		if( dreg != sreg ) {
-			xMOV(ecx, ptr32[&psxRegs.GPR.r[sreg]]);
-			xMOV(ptr32[&psxRegs.GPR.r[dreg]], ecx);
+			xMOV(ecxd, ptr32[&psxRegs.GPR.r[sreg]]);
+			xMOV(ptr32[&psxRegs.GPR.r[dreg]], ecxd);
 		}
 	}
 }
@@ -241,16 +241,16 @@ void rpsxADDU_constt(int info)
 void rpsxADDU_(int info)
 {
 	if (_Rs_ && _Rt_) {
-		xMOV(eax, ptr32[&psxRegs.GPR.r[_Rs_]]);
-		xADD(eax, ptr32[&psxRegs.GPR.r[_Rt_]]);
+		xMOV(eaxd, ptr32[&psxRegs.GPR.r[_Rs_]]);
+		xADD(eaxd, ptr32[&psxRegs.GPR.r[_Rt_]]);
 	} else if (_Rs_) {
-		xMOV(eax, ptr32[&psxRegs.GPR.r[_Rs_]]);
+		xMOV(eaxd, ptr32[&psxRegs.GPR.r[_Rs_]]);
 	} else if (_Rt_) {
-		xMOV(eax, ptr32[&psxRegs.GPR.r[_Rt_]]);
+		xMOV(eaxd, ptr32[&psxRegs.GPR.r[_Rt_]]);
 	} else {
-		xXOR(eax, eax);
+		xXOR(eaxd, eaxd);
 	}
-	xMOV(ptr32[&psxRegs.GPR.r[_Rd_]], eax);
+	xMOV(ptr32[&psxRegs.GPR.r[_Rd_]], eaxd);
 }
 
 PSXRECOMPILE_CONSTCODE0(ADDU);
@@ -265,9 +265,9 @@ void rpsxSUBU_const()
 
 void rpsxSUBU_consts(int info)
 {
-	xMOV(eax, g_psxConstRegs[_Rs_]);
-	xSUB(eax, ptr32[&psxRegs.GPR.r[_Rt_]]);
-	xMOV(ptr32[&psxRegs.GPR.r[_Rd_]], eax);
+	xMOV(eaxd, g_psxConstRegs[_Rs_]);
+	xSUB(eaxd, ptr32[&psxRegs.GPR.r[_Rt_]]);
+	xMOV(ptr32[&psxRegs.GPR.r[_Rd_]], eaxd);
 }
 
 void rpsxSUBU_constt(int info) { rpsxADDconst(_Rd_, _Rs_, -(int)g_psxConstRegs[_Rt_], info); }
@@ -278,13 +278,13 @@ void rpsxSUBU_(int info)
 	if (!_Rd_) return;
 
 	if( _Rd_ == _Rs_ ) {
-		xMOV(eax, ptr32[&psxRegs.GPR.r[_Rt_]]);
-		xSUB(ptr32[&psxRegs.GPR.r[_Rd_]], eax);
+		xMOV(eaxd, ptr32[&psxRegs.GPR.r[_Rt_]]);
+		xSUB(ptr32[&psxRegs.GPR.r[_Rd_]], eaxd);
 	}
 	else {
-		xMOV(eax, ptr32[&psxRegs.GPR.r[_Rs_]]);
-		xSUB(eax, ptr32[&psxRegs.GPR.r[_Rt_]]);
-		xMOV(ptr32[&psxRegs.GPR.r[_Rd_]], eax);
+		xMOV(eaxd, ptr32[&psxRegs.GPR.r[_Rs_]]);
+		xSUB(eaxd, ptr32[&psxRegs.GPR.r[_Rt_]]);
+		xMOV(ptr32[&psxRegs.GPR.r[_Rd_]], eaxd);
 	}
 }
 
@@ -296,13 +296,13 @@ void rpsxLogicalOp(int info, int op)
 {
 	if( _Rd_ == _Rs_ || _Rd_ == _Rt_ ) {
 		int vreg = _Rd_ == _Rs_ ? _Rt_ : _Rs_;
-		xMOV(ecx, ptr32[&psxRegs.GPR.r[vreg]]);
+		xMOV(ecxd, ptr32[&psxRegs.GPR.r[vreg]]);
 
 		switch(op) {
-			case 0: xAND(ptr32[&psxRegs.GPR.r[_Rd_]], ecx); break;
-			case 1: xOR(ptr32[&psxRegs.GPR.r[_Rd_]], ecx); break;
-			case 2: xXOR(ptr32[&psxRegs.GPR.r[_Rd_]], ecx); break;
-			case 3: xOR(ptr32[&psxRegs.GPR.r[_Rd_]], ecx); break;
+			case 0: xAND(ptr32[&psxRegs.GPR.r[_Rd_]], ecxd); break;
+			case 1: xOR(ptr32[&psxRegs.GPR.r[_Rd_]], ecxd); break;
+			case 2: xXOR(ptr32[&psxRegs.GPR.r[_Rd_]], ecxd); break;
+			case 3: xOR(ptr32[&psxRegs.GPR.r[_Rd_]], ecxd); break;
 			default: pxAssert(0);
 		}
 
@@ -310,19 +310,19 @@ void rpsxLogicalOp(int info, int op)
 			xNOT(ptr32[&psxRegs.GPR.r[_Rd_]]);
 	}
 	else {
-		xMOV(ecx, ptr32[&psxRegs.GPR.r[_Rs_]]);
+		xMOV(ecxd, ptr32[&psxRegs.GPR.r[_Rs_]]);
 
 		switch(op) {
-			case 0: xAND(ecx, ptr32[&psxRegs.GPR.r[_Rt_]]); break;
-			case 1: xOR(ecx, ptr32[&psxRegs.GPR.r[_Rt_]]); break;
-			case 2: xXOR(ecx, ptr32[&psxRegs.GPR.r[_Rt_]]); break;
-			case 3: xOR(ecx, ptr32[&psxRegs.GPR.r[_Rt_]]); break;
+			case 0: xAND(ecxd, ptr32[&psxRegs.GPR.r[_Rt_]]); break;
+			case 1: xOR(ecxd, ptr32[&psxRegs.GPR.r[_Rt_]]); break;
+			case 2: xXOR(ecxd, ptr32[&psxRegs.GPR.r[_Rt_]]); break;
+			case 3: xOR(ecxd, ptr32[&psxRegs.GPR.r[_Rt_]]); break;
 			default: pxAssert(0);
 		}
 
 		if( op == 3 )
-			xNOT(ecx);
-		xMOV(ptr32[&psxRegs.GPR.r[_Rd_]], ecx);
+			xNOT(ecxd);
+		xMOV(ptr32[&psxRegs.GPR.r[_Rd_]], ecxd);
 	}
 }
 
@@ -374,10 +374,10 @@ void rpsxNORconst(int info, int dreg, int sreg, u32 imm)
 			xNOT(ptr32[&psxRegs.GPR.r[dreg]]);
 		}
 		else {
-			xMOV(ecx, ptr32[&psxRegs.GPR.r[sreg]]);
-			xOR(ecx, imm);
-			xNOT(ecx);
-			xMOV(ptr32[&psxRegs.GPR.r[dreg]], ecx);
+			xMOV(ecxd, ptr32[&psxRegs.GPR.r[sreg]]);
+			xOR(ecxd, imm);
+			xNOT(ecxd);
+			xMOV(ptr32[&psxRegs.GPR.r[dreg]], ecxd);
 		}
 	}
 	else {
@@ -385,9 +385,9 @@ void rpsxNORconst(int info, int dreg, int sreg, u32 imm)
 			xNOT(ptr32[&psxRegs.GPR.r[dreg]]);
 		}
 		else {
-			xMOV(ecx, ptr32[&psxRegs.GPR.r[sreg]]);
-			xNOT(ecx);
-			xMOV(ptr32[&psxRegs.GPR.r[dreg]], ecx);
+			xMOV(ecxd, ptr32[&psxRegs.GPR.r[sreg]]);
+			xNOT(ecxd);
+			xMOV(ptr32[&psxRegs.GPR.r[dreg]], ecxd);
 		}
 	}
 }
@@ -406,20 +406,20 @@ void rpsxSLT_const()
 
 void rpsxSLT_consts(int info)
 {
-	xXOR(eax, eax);
+	xXOR(eaxd, eaxd);
 	xCMP(ptr32[&psxRegs.GPR.r[_Rt_]], g_psxConstRegs[_Rs_]);
 	xSETG(al);
-	xMOV(ptr32[&psxRegs.GPR.r[_Rd_]], eax);
+	xMOV(ptr32[&psxRegs.GPR.r[_Rd_]], eaxd);
 }
 
 void rpsxSLT_constt(int info) { rpsxSLTconst(info, _Rd_, _Rs_, g_psxConstRegs[_Rt_]); }
 void rpsxSLT_(int info)
 {
-	xMOV(eax, ptr32[&psxRegs.GPR.r[_Rs_]]);
-	xCMP(eax, ptr32[&psxRegs.GPR.r[_Rt_]]);
+	xMOV(eaxd, ptr32[&psxRegs.GPR.r[_Rs_]]);
+	xCMP(eaxd, ptr32[&psxRegs.GPR.r[_Rt_]]);
 	xSETL(al);
-	xAND(eax, 0xff);
-	xMOV(ptr32[&psxRegs.GPR.r[_Rd_]], eax);
+	xAND(eaxd, 0xff);
+	xMOV(ptr32[&psxRegs.GPR.r[_Rd_]], eaxd);
 }
 
 PSXRECOMPILE_CONSTCODE0(SLT);
@@ -432,10 +432,10 @@ void rpsxSLTU_const()
 
 void rpsxSLTU_consts(int info)
 {
-	xXOR(eax, eax);
+	xXOR(eaxd, eaxd);
 	xCMP(ptr32[&psxRegs.GPR.r[_Rt_]], g_psxConstRegs[_Rs_]);
 	xSETA(al);
-	xMOV(ptr32[&psxRegs.GPR.r[_Rd_]], eax);
+	xMOV(ptr32[&psxRegs.GPR.r[_Rd_]], eaxd);
 }
 
 void rpsxSLTU_constt(int info) { rpsxSLTUconst(info, _Rd_, _Rs_, g_psxConstRegs[_Rt_]); }
@@ -444,11 +444,11 @@ void rpsxSLTU_(int info)
 	// Rd = Rs < Rt (unsigned)
 	if (!_Rd_) return;
 
-	xMOV(eax, ptr32[&psxRegs.GPR.r[_Rs_]]);
-	xCMP(eax, ptr32[&psxRegs.GPR.r[_Rt_]]);
-	xSBB(eax, eax);
-	xNEG(eax);
-	xMOV(ptr32[&psxRegs.GPR.r[_Rd_]], eax);
+	xMOV(eaxd, ptr32[&psxRegs.GPR.r[_Rs_]]);
+	xCMP(eaxd, ptr32[&psxRegs.GPR.r[_Rt_]]);
+	xSBB(eaxd, eaxd);
+	xNEG(eaxd);
+	xMOV(ptr32[&psxRegs.GPR.r[_Rd_]], eaxd);
 }
 
 PSXRECOMPILE_CONSTCODE0(SLTU);
@@ -465,21 +465,21 @@ void rpsxMULT_const()
 void rpsxMULTsuperconst(int info, int sreg, int imm, int sign)
 {
 	// Lo/Hi = Rs * Rt (signed)
-	xMOV(eax, imm);
+	xMOV(eaxd, imm);
 	if( sign ) xMUL(ptr32[&psxRegs.GPR.r[sreg]]);
 	else xUMUL(ptr32[&psxRegs.GPR.r[sreg]]);
-	xMOV(ptr32[&psxRegs.GPR.n.lo], eax);
-	xMOV(ptr32[&psxRegs.GPR.n.hi], edx);
+	xMOV(ptr32[&psxRegs.GPR.n.lo], eaxd);
+	xMOV(ptr32[&psxRegs.GPR.n.hi], edxd);
 }
 
 void rpsxMULTsuper(int info, int sign)
 {
 	// Lo/Hi = Rs * Rt (signed)
-	xMOV(eax, ptr32[&psxRegs.GPR.r[_Rs_]]);
+	xMOV(eaxd, ptr32[&psxRegs.GPR.r[_Rs_]]);
 	if( sign ) xMUL(ptr32[&psxRegs.GPR.r[_Rt_]]);
 	else xUMUL(ptr32[&psxRegs.GPR.r[_Rt_]]);
-	xMOV(ptr32[&psxRegs.GPR.n.lo], eax);
-	xMOV(ptr32[&psxRegs.GPR.n.hi], edx);
+	xMOV(ptr32[&psxRegs.GPR.n.lo], eaxd);
+	xMOV(ptr32[&psxRegs.GPR.n.hi], edxd);
 }
 
 void rpsxMULT_consts(int info) { rpsxMULTsuperconst(info, _Rt_, g_psxConstRegs[_Rs_], 1); }
@@ -540,61 +540,61 @@ void rpsxDIVsuper(int info, int sign, int process = 0)
 {
 	// Lo/Hi = Rs / Rt (signed)
 	if( process & PROCESS_CONSTT )
-		xMOV(ecx, g_psxConstRegs[_Rt_]);
+		xMOV(ecxd, g_psxConstRegs[_Rt_]);
 	else
-		xMOV(ecx, ptr32[&psxRegs.GPR.r[_Rt_]]);
+		xMOV(ecxd, ptr32[&psxRegs.GPR.r[_Rt_]]);
 
 	if( process & PROCESS_CONSTS )
-		xMOV(eax, g_psxConstRegs[_Rs_]);
+		xMOV(eaxd, g_psxConstRegs[_Rs_]);
 	else
-		xMOV(eax, ptr32[&psxRegs.GPR.r[_Rs_]]);
+		xMOV(eaxd, ptr32[&psxRegs.GPR.r[_Rs_]]);
 
 	u8 *end1;
 	if (sign)  //test for overflow (x86 will just throw an exception)
 	{
-		xCMP(eax, 0x80000000 );
+		xCMP(eaxd, 0x80000000 );
 		u8 *cont1 = JNE8(0);
-		xCMP(ecx, 0xffffffff );
+		xCMP(ecxd, 0xffffffff );
 		u8 *cont2 = JNE8(0);
 		//overflow case:
-		xXOR(edx, edx); //EAX remains 0x80000000
+		xXOR(edxd, edxd); //eaxd remains 0x80000000
 		end1 = JMP8(0);
 
 		x86SetJ8(cont1);
 		x86SetJ8(cont2);
 	}
 
-	xCMP(ecx, 0 );
+	xCMP(ecxd, 0 );
 	u8 *cont3 = JNE8(0);
 
 	//divide by zero
-	xMOV(edx, eax);
-	if (sign) //set EAX to (EAX < 0)?1:-1
+	xMOV(edxd, eaxd);
+	if (sign) //set eaxd to (eaxd < 0)?1:-1
 	{
-		xSAR(eax, 31 ); //(EAX < 0)?-1:0
-		xSHL(eax, 1 ); //(EAX < 0)?-2:0
-		xNOT(eax); //(EAX < 0)?1:-1
+		xSAR(eaxd, 31 ); //(eaxd < 0)?-1:0
+		xSHL(eaxd, 1 ); //(eaxd < 0)?-2:0
+		xNOT(eaxd); //(eaxd < 0)?1:-1
 	}
 	else
-		xMOV(eax, 0xffffffff );
+		xMOV(eaxd, 0xffffffff );
 	u8 *end2 = JMP8(0);
 
 	// Normal division
 	x86SetJ8(cont3);
 	if( sign ) {
 		xCDQ();
-		xDIV(ecx);
+		xDIV(ecxd);
 	}
 	else {
-		xXOR(edx, edx);
-		xUDIV(ecx);
+		xXOR(edxd, edxd);
+		xUDIV(ecxd);
 	}
 
 	if (sign) x86SetJ8( end1 );
 	x86SetJ8( end2 );
 
-	xMOV(ptr32[&psxRegs.GPR.n.lo], eax);
-	xMOV(ptr32[&psxRegs.GPR.n.hi], edx);
+	xMOV(ptr32[&psxRegs.GPR.n.lo], eaxd);
+	xMOV(ptr32[&psxRegs.GPR.n.hi], edxd);
 }
 
 void rpsxDIV_consts(int info) { rpsxDIVsuper(info, 1, PROCESS_CONSTS); }
@@ -639,12 +639,12 @@ static void rpsxLB()
 	_psxOnWriteReg(_Rt_);
 	_psxDeleteReg(_Rt_, 0);
 
-	xMOV(ecx, ptr32[&psxRegs.GPR.r[_Rs_]]);
-	if (_Imm_) xADD(ecx, _Imm_);
-	xFastCall((void*)iopMemRead8, ecx );		// returns value in EAX
+	xMOV(ecxd, ptr32[&psxRegs.GPR.r[_Rs_]]);
+	if (_Imm_) xADD(ecxd, _Imm_);
+	xFastCall((void*)iopMemRead8, ecxd );		// returns value in eaxd
 	if (_Rt_) {
-		xMOVSX(eax, al);
-		xMOV(ptr32[&psxRegs.GPR.r[_Rt_]], eax);
+		xMOVSX(eaxd, al);
+		xMOV(ptr32[&psxRegs.GPR.r[_Rt_]], eaxd);
 	}
 	PSX_DEL_CONST(_Rt_);
 }
@@ -655,12 +655,12 @@ static void rpsxLBU()
 	_psxOnWriteReg(_Rt_);
 	_psxDeleteReg(_Rt_, 0);
 
-	xMOV(ecx, ptr32[&psxRegs.GPR.r[_Rs_]]);
-	if (_Imm_) xADD(ecx, _Imm_);
-	xFastCall((void*)iopMemRead8, ecx );		// returns value in EAX
+	xMOV(ecxd, ptr32[&psxRegs.GPR.r[_Rs_]]);
+	if (_Imm_) xADD(ecxd, _Imm_);
+	xFastCall((void*)iopMemRead8, ecxd );		// returns value in eaxd
 	if (_Rt_) {
-		xMOVZX(eax, al);
-		xMOV(ptr32[&psxRegs.GPR.r[_Rt_]], eax);
+		xMOVZX(eaxd, al);
+		xMOV(ptr32[&psxRegs.GPR.r[_Rt_]], eaxd);
 	}
 	PSX_DEL_CONST(_Rt_);
 }
@@ -671,12 +671,12 @@ static void rpsxLH()
 	_psxOnWriteReg(_Rt_);
 	_psxDeleteReg(_Rt_, 0);
 
-	xMOV(ecx, ptr32[&psxRegs.GPR.r[_Rs_]]);
-	if (_Imm_) xADD(ecx, _Imm_);
-	xFastCall((void*)iopMemRead16, ecx );		// returns value in EAX
+	xMOV(ecxd, ptr32[&psxRegs.GPR.r[_Rs_]]);
+	if (_Imm_) xADD(ecxd, _Imm_);
+	xFastCall((void*)iopMemRead16, ecxd );		// returns value in eaxd
 	if (_Rt_) {
-		xMOVSX(eax, ax);
-		xMOV(ptr32[&psxRegs.GPR.r[_Rt_]], eax);
+		xMOVSX(eaxd, ax);
+		xMOV(ptr32[&psxRegs.GPR.r[_Rt_]], eaxd);
 	}
 	PSX_DEL_CONST(_Rt_);
 }
@@ -687,12 +687,12 @@ static void rpsxLHU()
 	_psxOnWriteReg(_Rt_);
 	_psxDeleteReg(_Rt_, 0);
 
-	xMOV(ecx, ptr32[&psxRegs.GPR.r[_Rs_]]);
-	if (_Imm_) xADD(ecx, _Imm_);
-	xFastCall((void*)iopMemRead16, ecx );		// returns value in EAX
+	xMOV(ecxd, ptr32[&psxRegs.GPR.r[_Rs_]]);
+	if (_Imm_) xADD(ecxd, _Imm_);
+	xFastCall((void*)iopMemRead16, ecxd );		// returns value in eaxd
 	if (_Rt_) {
-		xMOVZX(eax, ax);
-		xMOV(ptr32[&psxRegs.GPR.r[_Rt_]], eax);
+		xMOVZX(eaxd, ax);
+		xMOV(ptr32[&psxRegs.GPR.r[_Rt_]], eaxd);
 	}
 	PSX_DEL_CONST(_Rt_);
 }
@@ -704,25 +704,31 @@ static void rpsxLW()
 	_psxDeleteReg(_Rt_, 0);
 
 	_psxFlushCall(FLUSH_EVERYTHING);
-	xMOV(ecx, ptr32[&psxRegs.GPR.r[_Rs_]]);
-	if (_Imm_) xADD(ecx, _Imm_);
+	xMOV(ecxd, ptr32[&psxRegs.GPR.r[_Rs_]]);
+	if (_Imm_) xADD(ecxd, _Imm_);
 
-	xTEST(ecx, 0x10000000);
+	xTEST(ecxd, 0x10000000);
 	j8Ptr[0] = JZ8(0);
 
-	xFastCall((void*)iopMemRead32, ecx );		// returns value in EAX
+	xFastCall((void*)iopMemRead32, ecxd );		// returns value in eaxd
 	if (_Rt_) {
-		xMOV(ptr32[&psxRegs.GPR.r[_Rt_]], eax);
+		xMOV(ptr32[&psxRegs.GPR.r[_Rt_]], eaxd);
 	}
 	j8Ptr[1] = JMP8(0);
 	x86SetJ8(j8Ptr[0]);
 
 	// read from psM directly
 	xAND(ecx, 0x1fffff);
+	#ifdef __M_X86_64
+	  xMOV64(rax,(uptr)iopMem->Main);
+	  xADD(rcx, rax);
+	#else
+	  xADD(ecx, (uptr)iopMem->Main);
+	#endif
 
-	xMOV(ecx, ptr32[xComplexAddress(rax, iopMem->Main, rcx)]);
+	xMOV(ecxd, ptr32[ecxd]);
 	if (_Rt_) {
-		xMOV(ptr32[&psxRegs.GPR.r[_Rt_]], ecx);
+		xMOV(ptr32[&psxRegs.GPR.r[_Rt_]], ecxd);
 	}
 
 	x86SetJ8(j8Ptr[1]);
@@ -734,10 +740,10 @@ static void rpsxSB()
 	_psxDeleteReg(_Rs_, 1);
 	_psxDeleteReg(_Rt_, 1);
 
-	xMOV(arg1regd, ptr32[&psxRegs.GPR.r[_Rs_]]);
-	if (_Imm_) xADD(arg1regd, _Imm_);
-	xMOV( arg2regd, ptr32[&psxRegs.GPR.r[_Rt_]] );
-	xFastCall((void*)iopMemWrite8, arg1regd, arg2regd );
+	xMOV(ecxd, ptr32[&psxRegs.GPR.r[_Rs_]]);
+	if (_Imm_) xADD(ecxd, _Imm_);
+	xMOV( edxd, ptr32[&psxRegs.GPR.r[_Rt_]] );
+	xFastCall((void*)iopMemWrite8, ecxd, edxd );
 }
 
 static void rpsxSH()
@@ -745,10 +751,10 @@ static void rpsxSH()
 	_psxDeleteReg(_Rs_, 1);
 	_psxDeleteReg(_Rt_, 1);
 
-	xMOV(arg1regd, ptr32[&psxRegs.GPR.r[_Rs_]]);
-	if (_Imm_) xADD(arg1regd, _Imm_);
-	xMOV( arg2regd, ptr32[&psxRegs.GPR.r[_Rt_]] );
-	xFastCall((void*)iopMemWrite16, arg1regd, arg2regd );
+	xMOV(ecxd, ptr32[&psxRegs.GPR.r[_Rs_]]);
+	if (_Imm_) xADD(ecxd, _Imm_);
+	xMOV( edxd, ptr32[&psxRegs.GPR.r[_Rt_]] );
+	xFastCall((void*)iopMemWrite16, ecxd, edxd );
 }
 
 static void rpsxSW()
@@ -756,10 +762,10 @@ static void rpsxSW()
 	_psxDeleteReg(_Rs_, 1);
 	_psxDeleteReg(_Rt_, 1);
 
-	xMOV(arg1regd, ptr32[&psxRegs.GPR.r[_Rs_]]);
-	if (_Imm_) xADD(arg1regd, _Imm_);
-	xMOV( arg2regd, ptr32[&psxRegs.GPR.r[_Rt_]] );
-	xFastCall((void*)iopMemWrite32, arg1regd, arg2regd );
+	xMOV(ecxd, ptr32[&psxRegs.GPR.r[_Rs_]]);
+	if (_Imm_) xADD(ecxd, _Imm_);
+	xMOV( edxd, ptr32[&psxRegs.GPR.r[_Rt_]] );
+	xFastCall((void*)iopMemWrite32, ecxd, edxd );
 }
 
 //// SLL
@@ -781,19 +787,19 @@ void rpsxShiftConst(int info, int rdreg, int rtreg, int imm, int shifttype)
 			}
 		}
 		else {
-			xMOV(eax, ptr32[&psxRegs.GPR.r[rtreg]]);
+			xMOV(eaxd, ptr32[&psxRegs.GPR.r[rtreg]]);
 			switch(shifttype) {
-				case 0: xSHL(eax, imm); break;
-				case 1: xSHR(eax, imm); break;
-				case 2: xSAR(eax, imm); break;
+				case 0: xSHL(eaxd, imm); break;
+				case 1: xSHR(eaxd, imm); break;
+				case 2: xSAR(eaxd, imm); break;
 			}
-			xMOV(ptr32[&psxRegs.GPR.r[rdreg]], eax);
+			xMOV(ptr32[&psxRegs.GPR.r[rdreg]], eaxd);
 		}
 	}
 	else {
 		if( rdreg != rtreg ) {
-			xMOV(eax, ptr32[&psxRegs.GPR.r[rtreg]]);
-			xMOV(ptr32[&psxRegs.GPR.r[rdreg]], eax);
+			xMOV(eaxd, ptr32[&psxRegs.GPR.r[rtreg]]);
+			xMOV(ptr32[&psxRegs.GPR.r[rdreg]], eaxd);
 		}
 	}
 }
@@ -832,24 +838,24 @@ void rpsxShiftVconsts(int info, int shifttype)
 
 void rpsxShiftVconstt(int info, int shifttype)
 {
-	xMOV(eax, g_psxConstRegs[_Rt_]);
-	xMOV(ecx, ptr32[&psxRegs.GPR.r[_Rs_]]);
+	xMOV(eaxd, g_psxConstRegs[_Rt_]);
+	xMOV(ecxd, ptr32[&psxRegs.GPR.r[_Rs_]]);
 	switch(shifttype) {
-		case 0: xSHL(eax, cl); break;
-		case 1: xSHR(eax, cl); break;
-		case 2: xSAR(eax, cl); break;
+		case 0: xSHL(eaxd, cl); break;
+		case 1: xSHR(eaxd, cl); break;
+		case 2: xSAR(eaxd, cl); break;
 	}
-	xMOV(ptr32[&psxRegs.GPR.r[_Rd_]], eax);
+	xMOV(ptr32[&psxRegs.GPR.r[_Rd_]], eaxd);
 }
 
 void rpsxSLLV_consts(int info) { rpsxShiftVconsts(info, 0); }
 void rpsxSLLV_constt(int info) { rpsxShiftVconstt(info, 0); }
 void rpsxSLLV_(int info)
 {
-	xMOV(eax, ptr32[&psxRegs.GPR.r[_Rt_]]);
-	xMOV(ecx, ptr32[&psxRegs.GPR.r[_Rs_]]);
-	xSHL(eax, cl);
-	xMOV(ptr32[&psxRegs.GPR.r[_Rd_]], eax);
+	xMOV(eaxd, ptr32[&psxRegs.GPR.r[_Rt_]]);
+	xMOV(ecxd, ptr32[&psxRegs.GPR.r[_Rs_]]);
+	xSHL(eaxd, cl);
+	xMOV(ptr32[&psxRegs.GPR.r[_Rd_]], eaxd);
 }
 
 PSXRECOMPILE_CONSTCODE0(SLLV);
@@ -864,10 +870,10 @@ void rpsxSRLV_consts(int info) { rpsxShiftVconsts(info, 1); }
 void rpsxSRLV_constt(int info) { rpsxShiftVconstt(info, 1); }
 void rpsxSRLV_(int info)
 {
-	xMOV(eax, ptr32[&psxRegs.GPR.r[_Rt_]]);
-	xMOV(ecx, ptr32[&psxRegs.GPR.r[_Rs_]]);
-	xSHR(eax, cl);
-	xMOV(ptr32[&psxRegs.GPR.r[_Rd_]], eax);
+	xMOV(eaxd, ptr32[&psxRegs.GPR.r[_Rt_]]);
+	xMOV(ecxd, ptr32[&psxRegs.GPR.r[_Rs_]]);
+	xSHR(eaxd, cl);
+	xMOV(ptr32[&psxRegs.GPR.r[_Rd_]], eaxd);
 }
 
 PSXRECOMPILE_CONSTCODE0(SRLV);
@@ -882,10 +888,10 @@ void rpsxSRAV_consts(int info) { rpsxShiftVconsts(info, 2); }
 void rpsxSRAV_constt(int info) { rpsxShiftVconstt(info, 2); }
 void rpsxSRAV_(int info)
 {
-	xMOV(eax, ptr32[&psxRegs.GPR.r[_Rt_]]);
-	xMOV(ecx, ptr32[&psxRegs.GPR.r[_Rs_]]);
-	xSAR(eax, cl);
-	xMOV(ptr32[&psxRegs.GPR.r[_Rd_]], eax);
+	xMOV(eaxd, ptr32[&psxRegs.GPR.r[_Rt_]]);
+	xMOV(ecxd, ptr32[&psxRegs.GPR.r[_Rs_]]);
+	xSAR(eaxd, cl);
+	xMOV(ptr32[&psxRegs.GPR.r[_Rd_]], eaxd);
 }
 
 PSXRECOMPILE_CONSTCODE0(SRAV);
@@ -899,8 +905,8 @@ void rpsxMFHI()
 
 	_psxOnWriteReg(_Rd_);
 	_psxDeleteReg(_Rd_, 0);
-	xMOV(eax, ptr32[&psxRegs.GPR.n.hi]);
-	xMOV(ptr32[&psxRegs.GPR.r[_Rd_]], eax);
+	xMOV(eaxd, ptr32[&psxRegs.GPR.n.hi]);
+	xMOV(ptr32[&psxRegs.GPR.r[_Rd_]], eaxd);
 }
 
 void rpsxMTHI()
@@ -910,8 +916,8 @@ void rpsxMTHI()
 	}
 	else {
 		_psxDeleteReg(_Rs_, 1);
-		xMOV(eax, ptr32[&psxRegs.GPR.r[_Rs_]]);
-		xMOV(ptr32[&psxRegs.GPR.n.hi], eax);
+		xMOV(eaxd, ptr32[&psxRegs.GPR.r[_Rs_]]);
+		xMOV(ptr32[&psxRegs.GPR.n.hi], eaxd);
 	}
 }
 
@@ -921,8 +927,8 @@ void rpsxMFLO()
 
 	_psxOnWriteReg(_Rd_);
 	_psxDeleteReg(_Rd_, 0);
-	xMOV(eax, ptr32[&psxRegs.GPR.n.lo]);
-	xMOV(ptr32[&psxRegs.GPR.r[_Rd_]], eax);
+	xMOV(eaxd, ptr32[&psxRegs.GPR.n.lo]);
+	xMOV(ptr32[&psxRegs.GPR.r[_Rd_]], eaxd);
 }
 
 void rpsxMTLO()
@@ -932,8 +938,8 @@ void rpsxMTLO()
 	}
 	else {
 		_psxDeleteReg(_Rs_, 1);
-		xMOV(eax, ptr32[&psxRegs.GPR.r[_Rs_]]);
-		xMOV(ptr32[&psxRegs.GPR.n.lo], eax);
+		xMOV(eaxd, ptr32[&psxRegs.GPR.r[_Rs_]]);
+		xMOV(ptr32[&psxRegs.GPR.n.lo], eaxd);
 	}
 }
 
@@ -986,15 +992,15 @@ void rpsxJALR()
 
 	}
 	else {
-		xMOV(eax, ptr32[&g_recWriteback]);
-		xMOV(ptr32[&psxRegs.pc], eax);
+		xMOV(eaxd, ptr32[&g_recWriteback]);
+		xMOV(ptr32[&psxRegs.pc], eaxd);
 		#ifdef PCSX2_DEBUG
-		xOR( eax, eax );
+		xOR( eaxd, eaxd );
 		#endif
 	}
 	#ifdef PCSX2_DEBUG
 	xForwardJNZ8 skipAssert;
-	xWrite8( 0xcc );
+	xWrite8( x86_Opcode_INT3 );
 	skipAssert.SetTarget();
 	#endif
 
@@ -1015,8 +1021,8 @@ void rpsxSetBranchEQ(int info, int process)
 		s_pbranchjmp = JNE32( 0 );
 	}
 	else {
-		xMOV(eax, ptr32[&psxRegs.GPR.r[ _Rs_ ] ]);
-		xCMP(eax, ptr32[&psxRegs.GPR.r[ _Rt_ ] ]);
+		xMOV(eaxd, ptr32[&psxRegs.GPR.r[ _Rs_ ] ]);
+		xCMP(eaxd, ptr32[&psxRegs.GPR.r[ _Rt_ ] ]);
 		s_pbranchjmp = JNE32( 0 );
 	}
 }
@@ -1341,8 +1347,8 @@ void rpsxMFC0()
 	if (!_Rt_) return;
 
 	_psxOnWriteReg(_Rt_);
-	xMOV(eax, ptr32[&psxRegs.CP0.r[_Rd_]]);
-	xMOV(ptr32[&psxRegs.GPR.r[_Rt_]], eax);
+	xMOV(eaxd, ptr32[&psxRegs.CP0.r[_Rd_]]);
+	xMOV(ptr32[&psxRegs.GPR.r[_Rt_]], eaxd);
 }
 
 void rpsxCFC0()
@@ -1351,8 +1357,8 @@ void rpsxCFC0()
 	if (!_Rt_) return;
 
 	_psxOnWriteReg(_Rt_);
-	xMOV(eax, ptr32[&psxRegs.CP0.r[_Rd_]]);
-	xMOV(ptr32[&psxRegs.GPR.r[_Rt_]], eax);
+	xMOV(eaxd, ptr32[&psxRegs.CP0.r[_Rd_]]);
+	xMOV(ptr32[&psxRegs.GPR.r[_Rt_]], eaxd);
 }
 
 void rpsxMTC0()
@@ -1363,8 +1369,8 @@ void rpsxMTC0()
 	}
 	else {
 		_psxDeleteReg(_Rt_, 1);
-		xMOV(eax, ptr32[&psxRegs.GPR.r[_Rt_]]);
-		xMOV(ptr32[&psxRegs.CP0.r[_Rd_]], eax);
+		xMOV(eaxd, ptr32[&psxRegs.GPR.r[_Rt_]]);
+		xMOV(ptr32[&psxRegs.CP0.r[_Rd_]], eaxd);
 	}
 }
 
@@ -1376,13 +1382,13 @@ void rpsxCTC0()
 
 void rpsxRFE()
 {
-	xMOV(eax, ptr32[&psxRegs.CP0.n.Status]);
-	xMOV(ecx, eax);
-	xAND(eax, 0xfffffff0);
-	xAND(ecx, 0x3c);
-	xSHR(ecx, 2);
-	xOR(eax, ecx);
-	xMOV(ptr32[&psxRegs.CP0.n.Status], eax);
+	xMOV(eaxd, ptr32[&psxRegs.CP0.n.Status]);
+	xMOV(ecxd, eaxd);
+	xAND(eaxd, 0xfffffff0);
+	xAND(ecxd, 0x3c);
+	xSHR(ecxd, 2);
+	xOR(eaxd, ecxd);
+	xMOV(ptr32[&psxRegs.CP0.n.Status], eaxd);
 
 	// Test the IOP's INTC status, so that any pending ints get raised.
 
diff --git a/pcsx2/pcsx2/x86/iR5900Misc.cpp b/pcsx2/pcsx2/x86/iR5900Misc.cpp
index fbb8250..0e796f2 100644
--- a/pcsx2/pcsx2/x86/iR5900Misc.cpp
+++ b/pcsx2/pcsx2/x86/iR5900Misc.cpp
@@ -99,9 +99,9 @@ void recMFSA()
 		xMOVL.PS(xRegisterSSE(mmreg), ptr[&cpuRegs.sa]);
 	}
 	else {
-		xMOV(eax, ptr[&cpuRegs.sa]);
+		xMOV(eaxd, ptr[&cpuRegs.sa]);
 		_deleteEEreg(_Rd_, 0);
-		xMOV(ptr[&cpuRegs.GPR.r[_Rd_].UL[0]], eax);
+		xMOV(ptr[&cpuRegs.GPR.r[_Rd_].UL[0]], eaxd);
 		xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].UL[1]], 0);
 	}
 }
@@ -119,8 +119,8 @@ void recMTSA()
 			xMOVSS(ptr[&cpuRegs.sa], xRegisterSSE(mmreg));
 		}
 		else {
-			xMOV(eax, ptr[&cpuRegs.GPR.r[_Rs_].UL[0]]);
-			xMOV(ptr[&cpuRegs.sa], eax);
+			xMOV(eaxd, ptr[&cpuRegs.GPR.r[_Rs_].UL[0]]);
+			xMOV(ptr[&cpuRegs.sa], eaxd);
 		}
 		xAND(ptr32[&cpuRegs.sa], 0xf);
 	}
@@ -132,10 +132,10 @@ void recMTSAB()
 		xMOV(ptr32[&cpuRegs.sa], ((g_cpuConstRegs[_Rs_].UL[0] & 0xF) ^ (_Imm_ & 0xF)));
 	}
 	else {
-		_eeMoveGPRtoR(eax, _Rs_);
-		xAND(eax, 0xF);
-		xXOR(eax, _Imm_&0xf);
-		xMOV(ptr[&cpuRegs.sa], eax);
+		_eeMoveGPRtoR(eaxd, _Rs_);
+		xAND(eaxd, 0xF);
+		xXOR(eaxd, _Imm_&0xf);
+		xMOV(ptr[&cpuRegs.sa], eaxd);
 	}
  }
 
@@ -145,11 +145,11 @@ void recMTSAH()
 		xMOV(ptr32[&cpuRegs.sa], ((g_cpuConstRegs[_Rs_].UL[0] & 0x7) ^ (_Imm_ & 0x7)) << 1);
 	}
 	else {
-		_eeMoveGPRtoR(eax, _Rs_);
-		xAND(eax, 0x7);
-		xXOR(eax, _Imm_&0x7);
-		xSHL(eax, 1);
-		xMOV(ptr[&cpuRegs.sa], eax);
+		_eeMoveGPRtoR(eaxd, _Rs_);
+		xAND(eaxd, 0x7);
+		xXOR(eaxd, _Imm_&0x7);
+		xSHL(eaxd, 1);
+		xMOV(ptr[&cpuRegs.sa], eaxd);
 	}
 }
 
diff --git a/pcsx2/pcsx2/x86/ix86-32/iCore-32.cpp b/pcsx2/pcsx2/x86/ix86-32/iCore-32.cpp
index 15dd78a..76deaa9 100644
--- a/pcsx2/pcsx2/x86/ix86-32/iCore-32.cpp
+++ b/pcsx2/pcsx2/x86/ix86-32/iCore-32.cpp
@@ -189,11 +189,11 @@ void _flushConstRegs()
 		if (g_cpuConstRegs[i].SL[j] != 0) continue;
 
 		if (eaxval != 0) {
-			xXOR(eax, eax);
+			xXOR(eaxd, eaxd);
 			eaxval = 0;
 		}
 
-		xMOV(ptr[&cpuRegs.GPR.r[i].SL[j]], eax);
+		xMOV(ptr[&cpuRegs.GPR.r[i].SL[j]], eaxd);
 		done[j] |= 1<<i;
 		zero_cnt++;
 	}
@@ -205,15 +205,15 @@ void _flushConstRegs()
 		if (g_cpuConstRegs[i].SL[j] != -1) continue;
 
 		if (eaxval > 0) {
-			xXOR(eax, eax);
+			xXOR(eaxd, eaxd);
 			eaxval = 0;
 		}
 		if (eaxval == 0) {
-			xNOT(eax);
+			xNOT(eaxd);
 			eaxval = -1;
 		}
 
-		xMOV(ptr[&cpuRegs.GPR.r[i].SL[j]], eax);
+		xMOV(ptr[&cpuRegs.GPR.r[i].SL[j]], eaxd);
 		done[j + 2] |= 1<<i;
 		minusone_cnt++;
 	}
@@ -240,11 +240,21 @@ void _flushConstRegs()
 	}
 }
 
+int _allocX86reg(xRegisterEmpty x86reg, int type, int reg, int mode)
+{
+	return _allocX86reg(xRegister32(x86reg), type, reg, mode);
+}
+
+int _allocX86reg(xRegister64 x86reg, int type, int reg, int mode)
+{
+	return _allocX86reg(xRegister32(x86reg.Id), type, reg, mode);
+}
+
 int _allocX86reg(xRegister32 x86reg, int type, int reg, int mode)
 {
 	uint i;
 	pxAssertDev( reg >= 0 && reg < 32, "Register index out of bounds." );
-	pxAssertDev( x86reg != esp && x86reg != ebp, "Allocation of ESP/EBP is not allowed!" );
+	pxAssertDev( x86reg != espd && x86reg != ebpd, "Allocation of ESP/EBP is not allowed!" );
 
 	// don't alloc EAX and ESP,EBP if MODE_NOFRAME
 	int oldmode = mode;
@@ -476,5 +486,5 @@ void _signExtendSFtoM(uptr mem)
 	xLAHF();
 	xSAR(ax, 15);
 	xCWDE();
-	xMOV(ptr[(void*)(mem)], eax);
+	xMOV(ptr[(void*)(mem)], eaxd);
 }
diff --git a/pcsx2/pcsx2/x86/ix86-32/iR5900-32.cpp b/pcsx2/pcsx2/x86/ix86-32/iR5900-32.cpp
index c513838..bba9245 100644
--- a/pcsx2/pcsx2/x86/ix86-32/iR5900-32.cpp
+++ b/pcsx2/pcsx2/x86/ix86-32/iR5900-32.cpp
@@ -182,8 +182,8 @@ void _eeMoveGPRtoM(uptr to, int fromgpr)
 			xMOVSS(ptr[(void*)(to)], xRegisterSSE(mmreg));
 		}
 		else {
-			xMOV(eax, ptr[&cpuRegs.GPR.r[ fromgpr ].UL[ 0 ] ]);
-			xMOV(ptr[(void*)(to)], eax);
+			xMOV(eaxd, ptr[&cpuRegs.GPR.r[ fromgpr ].UL[ 0 ] ]);
+			xMOV(ptr[(void*)(to)], eaxd);
 		}
 	}
 }
@@ -199,8 +199,8 @@ void _eeMoveGPRtoRm(x86IntRegType to, int fromgpr)
 			xMOVSS(ptr[xAddressReg(to)], xRegisterSSE(mmreg));
 		}
 		else {
-			xMOV(eax, ptr[&cpuRegs.GPR.r[ fromgpr ].UL[ 0 ] ]);
-			xMOV(ptr[xAddressReg(to)], eax);
+			xMOV(eaxd, ptr[&cpuRegs.GPR.r[ fromgpr ].UL[ 0 ] ]);
+			xMOV(ptr[xAddressReg(to)], eaxd);
 		}
 	}
 }
@@ -210,8 +210,8 @@ void eeSignExtendTo(int gpr, bool onlyupper)
 	// TODO: Use 64-bit registers (cdqe) on x86-64
 	xCDQ();
 	if (!onlyupper)
-		xMOV(ptr32[&cpuRegs.GPR.r[gpr].UL[0]], eax);
-	xMOV(ptr32[&cpuRegs.GPR.r[gpr].UL[1]], edx);
+		xMOV(ptr32[&cpuRegs.GPR.r[gpr].UL[0]], eaxd);
+	xMOV(ptr32[&cpuRegs.GPR.r[gpr].UL[1]], edxd);
 }
 
 int _flushXMMunused()
@@ -299,8 +299,8 @@ void recBranchCall( void (*func)() )
 	// In order to make sure a branch test is performed, the nextBranchCycle is set
 	// to the current cpu cycle.
 
-	xMOV(eax, ptr[&cpuRegs.cycle ]);
-	xMOV(ptr[&g_nextEventCycle], eax);
+	xMOV(eaxd, ptr[&cpuRegs.cycle ]);
+	xMOV(ptr[&g_nextEventCycle], eaxd);
 
 	recCall(func);
 	g_branch = 2;
@@ -353,9 +353,9 @@ static DynGenFunc* _DynGen_JITCompile()
 	// u32 addr = cpuRegs.pc;
 	// void(**base)() = (void(**)())recLUT[addr >> 16];
 	// base[addr >> 2]();
-	xMOV( eax, ptr[&cpuRegs.pc] );
-	xMOV( ebx, eax );
-	xSHR( eax, 16 );
+	xMOV( eaxd, ptr[&cpuRegs.pc] );
+	xMOV( ebxd, eaxd );
+	xSHR( eaxd, 16 );
 	xMOV( rcx, ptrNative[xComplexAddress(rcx, recLUT, rax*wordsize)] );
 	xJMP( ptrNative[rbx*(wordsize/4) + rcx] );
 
@@ -378,9 +378,9 @@ static DynGenFunc* _DynGen_DispatcherReg()
 	// u32 addr = cpuRegs.pc;
 	// void(**base)() = (void(**)())recLUT[addr >> 16];
 	// base[addr >> 2]();
-	xMOV( eax, ptr[&cpuRegs.pc] );
-	xMOV( ebx, eax );
-	xSHR( eax, 16 );
+	xMOV( eaxd, ptr[&cpuRegs.pc] );
+	xMOV( ebxd, eaxd );
+	xSHR( eaxd, 16 );
 	xMOV( rcx, ptrNative[xComplexAddress(rcx, recLUT, rax*wordsize)] );
 	xJMP( ptrNative[rbx*(wordsize/4) + rcx] );
 
@@ -489,7 +489,10 @@ static void recReserveCache()
 
 	while (!recMem->IsOk())
 	{
-		if (recMem->Reserve(GetVmMemory().MainMemory(), HostMemoryMap::EErecOffset, m_ConfiguredCacheReserve * _1mb) != NULL) break;
+		sptr requestedSize = m_ConfiguredCacheReserve * _1mb;
+		sptr actualSize = sizeof(HostMemoryMap::EErec);
+		pxAssert(requestedSize <= actualSize);
+		if (recMem->Assign((void*)HostMemoryMap::EErec, std::min(requestedSize, actualSize)) != NULL) break;
 
 		// If it failed, then try again (if possible):
 		if (m_ConfiguredCacheReserve < 16) break;
@@ -516,7 +519,7 @@ static void recAlloc()
 		recRAMCopy = (u8*)_aligned_malloc(Ps2MemSize::MainRam, 4096);
 	}
 
-	if (!recRAM)
+	if (!recLutReserve_RAM)
 	{
 		recLutReserve_RAM = (u8*)_aligned_malloc(recLutSize, 4096);
 	}
@@ -640,8 +643,52 @@ static void recShutdown()
 	Perf::dump();
 }
 
+void initEE()
+{
+    eeRecIsReset=false;
+    eeRecNeedsReset=false;
+    eeCpuExecuting = false;
+    g_resetEeScalingStats = false;
+    g_patchesNeedRedo = 0;
+    maxrecmem = 0;
+    s_nBlockCycles = 0; 
+    g_cpuConstRegs[32] = {0};
+    g_cpuHasConstReg = 0;
+    g_cpuFlushedConstReg = 0;
+    recMem = NULL;
+    recRAMCopy = NULL;
+    recLutReserve_RAM = NULL;
+    m_ConfiguredCacheReserve = 64;
+    recConstBuf = NULL;
+    recRAM = NULL;
+    recROM = NULL;
+    recROM1 = NULL;
+    recPtr = NULL;
+    recConstBufPtr = NULL;
+    s_pInstCache = NULL;
+    s_nInstCacheSize = 0;
+    s_pCurBlock = NULL;
+    s_pCurBlockEx = NULL;
+    s_nEndBlock = 0;
+    s_saveHasConstReg = 0; 
+    s_saveFlushedConstReg = 0;
+    s_psaveInstInfo = NULL;
+    s_savenBlockCycles = 0;
+    
+    DispatcherEvent		= NULL;
+    DispatcherReg		= NULL;
+    JITCompile			= NULL;
+    JITCompileInBlock	= NULL;
+    EnterRecompiledCode	= NULL;
+    ExitRecompiledCode	= NULL;
+    DispatchBlockDiscard = NULL;
+    DispatchPageReset    = NULL;
+}
+
 static void recResetEE()
 {
+    
+    
 	if (eeCpuExecuting)
 	{
 		eeRecNeedsReset = true;
@@ -869,9 +916,9 @@ void SetBranchReg( u32 reg )
 		_eeMoveGPRtoR(calleeSavedReg2d, reg);
 
 		if (EmuConfig.Gamefixes.GoemonTlbHack) {
-			xMOV(ecx, calleeSavedReg2d);
+			xMOV(ecxd, calleeSavedReg2d);
 			vtlb_DynV2P();
-			xMOV(calleeSavedReg2d, eax);
+			xMOV(calleeSavedReg2d, eaxd);
 		}
 
 		recompileNextInstruction(1);
@@ -882,8 +929,8 @@ void SetBranchReg( u32 reg )
 			x86regs[calleeSavedReg2d.GetId()].inuse = 0;
 		}
 		else {
-			xMOV(eax, ptr[&g_recWriteback]);
-			xMOV(ptr[&cpuRegs.pc], eax);
+			xMOV(eaxd, ptr[&g_recWriteback]);
+			xMOV(ptr[&cpuRegs.pc], eaxd);
 		}
 	}
 
@@ -935,9 +982,9 @@ void LoadBranchState()
 void iFlushCall(int flushtype)
 {
 	// Free registers that are not saved across function calls (x86-32 ABI):
-	_freeX86reg(eax);
-	_freeX86reg(ecx);
-	_freeX86reg(edx);
+	_freeX86reg(eaxd);
+	_freeX86reg(ecxd);
+	_freeX86reg(edxd);
 
 	if ((flushtype & FLUSH_PC) && !g_cpuFlushedPC) {
 		xMOV(ptr32[&cpuRegs.pc], pc);
@@ -1046,20 +1093,20 @@ static void iBranchTest(u32 newpc)
 
 	if (EmuConfig.Speedhacks.WaitLoop && s_nBlockFF && newpc == s_branchTo)
 	{
-		xMOV(eax, ptr32[&g_nextEventCycle]);
+		xMOV(eaxd, ptr32[&g_nextEventCycle]);
 		xADD(ptr32[&cpuRegs.cycle], scaleblockcycles());
-		xCMP(eax, ptr32[&cpuRegs.cycle]);
-		xCMOVS(eax, ptr32[&cpuRegs.cycle]);
-		xMOV(ptr32[&cpuRegs.cycle], eax);
+		xCMP(eaxd, ptr32[&cpuRegs.cycle]);
+		xCMOVS(eaxd, ptr32[&cpuRegs.cycle]);
+		xMOV(ptr32[&cpuRegs.cycle], eaxd);
 
 		xJMP( (void*)DispatcherEvent );
 	}
 	else
 	{
-		xMOV(eax, ptr[&cpuRegs.cycle]);
-		xADD(eax, scaleblockcycles());
-		xMOV(ptr[&cpuRegs.cycle], eax); // update cycles
-		xSUB(eax, ptr[&g_nextEventCycle]);
+		xMOV(eaxd, ptr[&cpuRegs.cycle]);
+		xADD(eaxd, scaleblockcycles());
+		xMOV(ptr[&cpuRegs.cycle], eaxd); // update cycles
+		xSUB(eaxd, ptr[&g_nextEventCycle]);
 
 		if (newpc == 0xffffffff)
 			xJS( DispatcherReg );
@@ -1141,21 +1188,21 @@ int cop2flags(u32 code)
 void dynarecCheckBreakpoint()
 {
 	u32 pc = cpuRegs.pc;
- 	if (CBreakPoints::CheckSkipFirst(pc) != 0)
+ 	if (PCBreakPoints::CheckSkipFirst(pc) != 0)
 		return;
 
 	int bpFlags = isBreakpointNeeded(pc);
 	bool hit = false;
 	//check breakpoint at current pc
 	if (bpFlags & 1) {
-		auto cond = CBreakPoints::GetBreakPointCondition(pc);
+		auto cond = PCBreakPoints::GetBreakPointCondition(pc);
 		if (cond == NULL || cond->Evaluate()) {
 			hit = true;
 		}
 	}
 	//check breakpoint in delay slot
 	if (bpFlags & 2) {
-		auto cond = CBreakPoints::GetBreakPointCondition(pc + 4);
+		auto cond = PCBreakPoints::GetBreakPointCondition(pc + 4);
 		if (cond == NULL || cond->Evaluate())
 			hit = true;
 	}
@@ -1163,7 +1210,7 @@ void dynarecCheckBreakpoint()
 	if (!hit)
 		return;
 
-	CBreakPoints::SetBreakpointTriggered(true);
+	PCBreakPoints::SetBreakpointTriggered(true);
 	GetCoreThread().PauseSelfDebug();
 	recExitExecution();
 }
@@ -1171,10 +1218,10 @@ void dynarecCheckBreakpoint()
 void dynarecMemcheck()
 {
 	u32 pc = cpuRegs.pc;
- 	if (CBreakPoints::CheckSkipFirst(pc) != 0)
+ 	if (PCBreakPoints::CheckSkipFirst(pc) != 0)
 		return;
 
-	CBreakPoints::SetBreakpointTriggered(true);
+	PCBreakPoints::SetBreakpointTriggered(true);
 	GetCoreThread().PauseSelfDebug();
 	recExitExecution();
 }
@@ -1192,21 +1239,21 @@ void recMemcheck(u32 op, u32 bits, bool store)
 	iFlushCall(FLUSH_EVERYTHING|FLUSH_PC);
 
 	// compute accessed address
-	_eeMoveGPRtoR(ecx, (op >> 21) & 0x1F);
+	_eeMoveGPRtoR(ecxd, (op >> 21) & 0x1F);
 	if ((s16)op != 0)
-		xADD(ecx, (s16)op);
+		xADD(ecxd, (s16)op);
 	if (bits == 128)
-		xAND(ecx, ~0x0F);
+		xAND(ecxd, ~0x0F);
 
-	xFastCall((void*)standardizeBreakpointAddress, ecx);
-	xMOV(ecx,eax);
-	xMOV(edx,eax);
-	xADD(edx,bits/8);
+	xFastCall((void*)standardizeBreakpointAddress, ecxd);
+	xMOV(ecxd,eaxd);
+	xMOV(edxd,eaxd);
+	xADD(edxd,bits/8);
 
 	// ecx = access address
 	// edx = access address+size
 
-	auto checks = CBreakPoints::GetMemChecks();
+	auto checks = PCBreakPoints::GetMemChecks();
 	for (size_t i = 0; i < checks.size(); i++)
 	{
 		if (checks[i].result == 0)
@@ -1218,18 +1265,18 @@ void recMemcheck(u32 op, u32 bits, bool store)
 
 		// logic: memAddress < bpEnd && bpStart < memAddress+memSize
 
-		xMOV(eax,standardizeBreakpointAddress(checks[i].end));
-		xCMP(ecx,eax);				// address < end
+		xMOV(eaxd,standardizeBreakpointAddress(checks[i].end));
+		xCMP(ecxd,eaxd);				// address < end
 		xForwardJGE8 next1;			// if address >= end then goto next1
 
-		xMOV(eax,standardizeBreakpointAddress(checks[i].start));
-		xCMP(eax,edx);				// start < address+size
+		xMOV(eaxd,standardizeBreakpointAddress(checks[i].start));
+		xCMP(eaxd,edxd);				// start < address+size
 		xForwardJGE8 next2;			// if start >= address+size then goto next2
 
 		// hit the breakpoint
 		if (checks[i].result & MEMCHECK_LOG) {
-			xMOV(edx, store);
-			xFastCall((void*)dynarecMemLogcheck, ecx, edx);
+			xMOV(edxd, store);
+			xFastCall((void*)dynarecMemLogcheck, ecxd, edxd);
 		}
 		if (checks[i].result & MEMCHECK_BREAK) {
 			xFastCall((void*)dynarecMemcheck);
@@ -1298,7 +1345,7 @@ void recompileNextInstruction(int delayslot)
 	if( IsDevBuild )
 		xNOP();
 	if( IsDebugBuild )
-		xMOV(eax, pc);
+		xMOV(eaxd, pc);
 
 	if (EmuCmp::shouldEmitAfterInstr() && EmuCmp::shouldCompareR5900())
 	{
@@ -1611,8 +1658,8 @@ bool skipMPEG_By_Pattern(u32 sPC) {
 		if (memRead32(sPC+8) != p2) return 0;
 		xMOV(ptr32[&cpuRegs.GPR.n.v0.UL[0]], 1);
 		xMOV(ptr32[&cpuRegs.GPR.n.v0.UL[1]], 0);
-		xMOV(eax, ptr32[&cpuRegs.GPR.n.ra.UL[0]]);
-		xMOV(ptr32[&cpuRegs.pc], eax);
+		xMOV(eaxd, ptr32[&cpuRegs.GPR.n.ra.UL[0]]);
+		xMOV(ptr32[&cpuRegs.pc], eaxd);
 		iBranchTest();
 		g_branch = 1;
 		pc = s_nEndBlock;
diff --git a/pcsx2/pcsx2/x86/ix86-32/iR5900Arit.cpp b/pcsx2/pcsx2/x86/ix86-32/iR5900Arit.cpp
index 464568c..c0619f1 100644
--- a/pcsx2/pcsx2/x86/ix86-32/iR5900Arit.cpp
+++ b/pcsx2/pcsx2/x86/ix86-32/iR5900Arit.cpp
@@ -67,9 +67,9 @@ void recADD_constv(int info, int creg, u32 vreg)
 
 	s32 cval = g_cpuConstRegs[creg].SL[0];
 
-	xMOV(eax, ptr32[&cpuRegs.GPR.r[vreg].SL[0]]);
+	xMOV(eaxd, ptr32[&cpuRegs.GPR.r[vreg].SL[0]]);
 	if (cval)
-		xADD(eax, cval);
+		xADD(eaxd, cval);
 	eeSignExtendTo(_Rd_, _Rd_ == vreg && !cval);
 }
 
@@ -90,11 +90,11 @@ void recADD_(int info)
 {
 	pxAssert( !(info&PROCESS_EE_XMM) );
 
-	xMOV(eax, ptr32[&cpuRegs.GPR.r[_Rs_].SL[0]]);
+	xMOV(eaxd, ptr32[&cpuRegs.GPR.r[_Rs_].SL[0]]);
 	if (_Rs_ == _Rt_)
-		xADD(eax, eax);
+		xADD(eaxd, eaxd);
 	else
-		xADD(eax, ptr32[&cpuRegs.GPR.r[_Rt_].SL[0]]);
+		xADD(eaxd, ptr32[&cpuRegs.GPR.r[_Rt_].SL[0]]);
 	eeSignExtendTo(_Rd_);
 }
 
@@ -124,14 +124,14 @@ void recDADD_constv(int info, int creg, u32 vreg)
 		xADD(ptr32[&cpuRegs.GPR.r[_Rd_].SL[0]], cval.SL[0]);
 		xADC(ptr32[&cpuRegs.GPR.r[_Rd_].SL[1]], cval.SL[1]);
 	} else {
-		xMOV(eax, ptr32[&cpuRegs.GPR.r[vreg].SL[0]]);
-		xMOV(edx, ptr32[&cpuRegs.GPR.r[vreg].SL[1]]);
+		xMOV(eaxd, ptr32[&cpuRegs.GPR.r[vreg].SL[0]]);
+		xMOV(edxd, ptr32[&cpuRegs.GPR.r[vreg].SL[1]]);
 		if (cval.SD[0]) {
-			xADD(eax, cval.SL[0]);
-			xADC(edx, cval.SL[1]);
+			xADD(eaxd, cval.SL[0]);
+			xADC(edxd, cval.SL[1]);
 		}
-		xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].SL[0]], eax);
-		xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].SL[1]], edx);
+		xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].SL[0]], eaxd);
+		xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].SL[1]], edxd);
 	}
 }
 
@@ -153,30 +153,30 @@ void recDADD_(int info)
 	if (_Rd_ == _Rt_)
 		rs = _Rt_, rt = _Rs_;
 
-	xMOV(eax, ptr32[&cpuRegs.GPR.r[rt].SL[0]]);
+	xMOV(eaxd, ptr32[&cpuRegs.GPR.r[rt].SL[0]]);
 
 	if (_Rd_ == _Rs_ && _Rs_ == _Rt_) {
-		xSHLD(ptr32[&cpuRegs.GPR.r[_Rd_].SL[1]], eax, 1);
+		xSHLD(ptr32[&cpuRegs.GPR.r[_Rd_].SL[1]], eaxd, 1);
 		xSHL(ptr32[&cpuRegs.GPR.r[_Rd_].SL[0]], 1);
 		return;
 	}
 
-	xMOV(edx, ptr32[&cpuRegs.GPR.r[rt].SL[1]]);
+	xMOV(edxd, ptr32[&cpuRegs.GPR.r[rt].SL[1]]);
 
 	if (_Rd_ == rs) {
-		xADD(ptr32[&cpuRegs.GPR.r[_Rd_].SL[0]], eax);
-		xADC(ptr32[&cpuRegs.GPR.r[_Rd_].SL[1]], edx);
+		xADD(ptr32[&cpuRegs.GPR.r[_Rd_].SL[0]], eaxd);
+		xADC(ptr32[&cpuRegs.GPR.r[_Rd_].SL[1]], edxd);
 		return;
 	} else if (rs == rt) {
-		xADD(eax, eax);
-		xADC(edx, edx);
+		xADD(eaxd, eaxd);
+		xADC(edxd, edxd);
 	} else {
-		xADD(eax, ptr32[&cpuRegs.GPR.r[rs].SL[0]]);
-		xADC(edx, ptr32[&cpuRegs.GPR.r[rs].SL[1]]);
+		xADD(eaxd, ptr32[&cpuRegs.GPR.r[rs].SL[0]]);
+		xADC(edxd, ptr32[&cpuRegs.GPR.r[rs].SL[1]]);
 	}
 
-	xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].SL[0]], eax);
-	xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].SL[1]], edx);
+	xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].SL[0]], eaxd);
+	xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].SL[1]], edxd);
 }
 
 EERECOMPILE_CODE0(DADD, XMMINFO_WRITED|XMMINFO_READS|XMMINFO_READT);
@@ -200,8 +200,8 @@ void recSUB_consts(int info)
 
 	s32 sval = g_cpuConstRegs[_Rs_].SL[0];
 
-	xMOV(eax, sval);
-	xSUB(eax, ptr32[&cpuRegs.GPR.r[_Rt_].SL[0]]);
+	xMOV(eaxd, sval);
+	xSUB(eaxd, ptr32[&cpuRegs.GPR.r[_Rt_].SL[0]]);
 	eeSignExtendTo(_Rd_);
 }
 
@@ -211,9 +211,9 @@ void recSUB_constt(int info)
 
 	s32 tval = g_cpuConstRegs[_Rt_].SL[0];
 
-	xMOV(eax, ptr32[&cpuRegs.GPR.r[_Rs_].SL[0]]);
+	xMOV(eaxd, ptr32[&cpuRegs.GPR.r[_Rs_].SL[0]]);
 	if (tval)
-		xSUB(eax, tval);
+		xSUB(eaxd, tval);
 	eeSignExtendTo(_Rd_, _Rd_ == _Rs_ && !tval);
 }
 
@@ -227,8 +227,8 @@ void recSUB_(int info)
 		return;
 	}
 
-	xMOV(eax, ptr32[&cpuRegs.GPR.r[_Rs_].SL[0]]);
-	xSUB(eax, ptr32[&cpuRegs.GPR.r[_Rt_].SL[0]]);
+	xMOV(eaxd, ptr32[&cpuRegs.GPR.r[_Rs_].SL[0]]);
+	xSUB(eaxd, ptr32[&cpuRegs.GPR.r[_Rt_].SL[0]]);
 	eeSignExtendTo(_Rd_);
 }
 
@@ -265,14 +265,14 @@ void recDSUB_consts(int info)
 		xNEG(ptr32[&cpuRegs.GPR.r[_Rd_].SL[1]]);
 		return;
 	} else {
-		xMOV(eax, sval.SL[0]);
-		xMOV(edx, sval.SL[1]);
+		xMOV(eaxd, sval.SL[0]);
+		xMOV(edxd, sval.SL[1]);
 	}
 
-	xSUB(eax, ptr32[&cpuRegs.GPR.r[_Rt_].SL[0]]);
-	xSBB(edx, ptr32[&cpuRegs.GPR.r[_Rt_].SL[1]]);
-	xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].SL[0]], eax);
-	xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].SL[1]], edx);
+	xSUB(eaxd, ptr32[&cpuRegs.GPR.r[_Rt_].SL[0]]);
+	xSBB(edxd, ptr32[&cpuRegs.GPR.r[_Rt_].SL[1]]);
+	xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].SL[0]], eaxd);
+	xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].SL[1]], edxd);
 }
 
 void recDSUB_constt(int info)
@@ -286,14 +286,14 @@ void recDSUB_constt(int info)
 		xSUB(ptr32[&cpuRegs.GPR.r[_Rd_].SL[0]], tval.SL[0]);
 		xSBB(ptr32[&cpuRegs.GPR.r[_Rd_].SL[1]], tval.SL[1]);
 	} else {
-		xMOV(eax, ptr32[&cpuRegs.GPR.r[_Rs_].SL[0]]);
-		xMOV(edx, ptr32[&cpuRegs.GPR.r[_Rs_].SL[1]]);
+		xMOV(eaxd, ptr32[&cpuRegs.GPR.r[_Rs_].SL[0]]);
+		xMOV(edxd, ptr32[&cpuRegs.GPR.r[_Rs_].SL[1]]);
 		if (tval.SD[0]) {
-			xSUB(eax, tval.SL[0]);
-			xSBB(edx, tval.SL[1]);
+			xSUB(eaxd, tval.SL[0]);
+			xSBB(edxd, tval.SL[1]);
 		}
-		xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].SL[0]], eax);
-		xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].SL[1]], edx);
+		xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].SL[0]], eaxd);
+		xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].SL[1]], edxd);
 	}
 }
 
@@ -306,17 +306,17 @@ void recDSUB_(int info)
 		xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].SL[0]], 0);
 		xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].SL[1]], 0);
 	} else if (_Rd_ == _Rs_) {
-		xMOV(eax, ptr32[&cpuRegs.GPR.r[_Rt_].SL[0]]);
-		xMOV(edx, ptr32[&cpuRegs.GPR.r[_Rt_].SL[1]]);
-		xSUB(ptr32[&cpuRegs.GPR.r[_Rd_].SL[0]], eax);
-		xSBB(ptr32[&cpuRegs.GPR.r[_Rd_].SL[1]], edx);
+		xMOV(eaxd, ptr32[&cpuRegs.GPR.r[_Rt_].SL[0]]);
+		xMOV(edxd, ptr32[&cpuRegs.GPR.r[_Rt_].SL[1]]);
+		xSUB(ptr32[&cpuRegs.GPR.r[_Rd_].SL[0]], eaxd);
+		xSBB(ptr32[&cpuRegs.GPR.r[_Rd_].SL[1]], edxd);
 	} else {
-		xMOV(eax, ptr32[&cpuRegs.GPR.r[_Rs_].SL[0]]);
-		xMOV(edx, ptr32[&cpuRegs.GPR.r[_Rs_].SL[1]]);
-		xSUB(eax, ptr32[&cpuRegs.GPR.r[_Rt_].SL[0]]);
-		xSBB(edx, ptr32[&cpuRegs.GPR.r[_Rt_].SL[1]]);
-		xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].SL[0]], eax);
-		xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].SL[1]], edx);
+		xMOV(eaxd, ptr32[&cpuRegs.GPR.r[_Rs_].SL[0]]);
+		xMOV(edxd, ptr32[&cpuRegs.GPR.r[_Rs_].SL[1]]);
+		xSUB(eaxd, ptr32[&cpuRegs.GPR.r[_Rt_].SL[0]]);
+		xSBB(edxd, ptr32[&cpuRegs.GPR.r[_Rt_].SL[1]]);
+		xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].SL[0]], eaxd);
+		xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].SL[1]], edxd);
 	}
 }
 
@@ -348,10 +348,10 @@ void recAND_constv(int info, int creg, u32 vreg)
 			if (cval.SL[i] != -1)
 				xAND(ptr32[&cpuRegs.GPR.r[_Rd_].UL[i]], cval.UL[i]);
 		} else {
-			xMOV(eax, ptr32[&cpuRegs.GPR.r[vreg].UL[i]]);
+			xMOV(eaxd, ptr32[&cpuRegs.GPR.r[vreg].UL[i]]);
 			if (cval.SL[i] != -1)
-				xAND(eax, cval.UL[i]);
-			xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].UL[i]], eax);
+				xAND(eaxd, cval.UL[i]);
+			xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].UL[i]], eaxd);
 		}
 	}
 }
@@ -379,13 +379,13 @@ void recAND_(int info)
 		if (_Rd_ == rs) {
 			if (rs == rt)
 				continue;
-			xMOV(eax, ptr32[&cpuRegs.GPR.r[rt].UL[i]]);
-			xAND(ptr32[&cpuRegs.GPR.r[_Rd_].UL[i]], eax);
+			xMOV(eaxd, ptr32[&cpuRegs.GPR.r[rt].UL[i]]);
+			xAND(ptr32[&cpuRegs.GPR.r[_Rd_].UL[i]], eaxd);
 		} else {
-			xMOV(eax, ptr32[&cpuRegs.GPR.r[rs].UL[i]]);
+			xMOV(eaxd, ptr32[&cpuRegs.GPR.r[rs].UL[i]]);
 			if (rs != rt)
-				xAND(eax, ptr32[&cpuRegs.GPR.r[rt].UL[i]]);
-			xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].UL[i]], eax);
+				xAND(eaxd, ptr32[&cpuRegs.GPR.r[rt].UL[i]]);
+			xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].UL[i]], eaxd);
 		}
 	}
 }
@@ -412,10 +412,10 @@ void recOR_constv(int info, int creg, u32 vreg)
 			if (cval.UL[i])
 				xOR(ptr32[&cpuRegs.GPR.r[_Rd_].UL[i]], cval.UL[i]);
 		} else {
-			xMOV(eax, ptr32[&cpuRegs.GPR.r[vreg].UL[i]]);
+			xMOV(eaxd, ptr32[&cpuRegs.GPR.r[vreg].UL[i]]);
 			if (cval.UL[i])
-				xOR(eax, cval.UL[i]);
-			xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].UL[i]], eax);
+				xOR(eaxd, cval.UL[i]);
+			xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].UL[i]], eaxd);
 		}
 	}
 }
@@ -443,13 +443,13 @@ void recOR_(int info)
 		if (_Rd_ == rs) {
 			if (rs == rt)
 				continue;
-			xMOV(eax, ptr32[&cpuRegs.GPR.r[rt].UL[i]]);
-			xOR(ptr32[&cpuRegs.GPR.r[_Rd_].UL[i]], eax);
+			xMOV(eaxd, ptr32[&cpuRegs.GPR.r[rt].UL[i]]);
+			xOR(ptr32[&cpuRegs.GPR.r[_Rd_].UL[i]], eaxd);
 		} else {
-			xMOV(eax, ptr32[&cpuRegs.GPR.r[rs].UL[i]]);
+			xMOV(eaxd, ptr32[&cpuRegs.GPR.r[rs].UL[i]]);
 			if (rs != rt)
-				xOR(eax, ptr32[&cpuRegs.GPR.r[rt].UL[i]]);
-			xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].UL[i]], eax);
+				xOR(eaxd, ptr32[&cpuRegs.GPR.r[rt].UL[i]]);
+			xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].UL[i]], eaxd);
 		}
 	}
 }
@@ -474,10 +474,10 @@ void recXOR_constv(int info, int creg, u32 vreg)
 			if (cval.UL[i])
 				xXOR(ptr32[&cpuRegs.GPR.r[_Rd_].UL[i]], cval.UL[i]);
 		} else {
-			xMOV(eax, ptr32[&cpuRegs.GPR.r[vreg].UL[i]]);
+			xMOV(eaxd, ptr32[&cpuRegs.GPR.r[vreg].UL[i]]);
 			if (cval.UL[i])
-				xXOR(eax, cval.UL[i]);
-			xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].UL[i]], eax);
+				xXOR(eaxd, cval.UL[i]);
+			xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].UL[i]], eaxd);
 		}
 	}
 }
@@ -505,12 +505,12 @@ void recXOR_(int info)
 		if (rs == rt) {
 			xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].UL[i]], 0);
 		} else if (_Rd_ == rs) {
-			xMOV(eax, ptr32[&cpuRegs.GPR.r[rt].UL[i]]);
-			xXOR(ptr32[&cpuRegs.GPR.r[_Rd_].UL[i]], eax);
+			xMOV(eaxd, ptr32[&cpuRegs.GPR.r[rt].UL[i]]);
+			xXOR(ptr32[&cpuRegs.GPR.r[_Rd_].UL[i]], eaxd);
 		} else {
-			xMOV(eax, ptr32[&cpuRegs.GPR.r[rs].UL[i]]);
-			xXOR(eax, ptr32[&cpuRegs.GPR.r[rt].UL[i]]);
-			xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].UL[i]], eax);
+			xMOV(eaxd, ptr32[&cpuRegs.GPR.r[rs].UL[i]]);
+			xXOR(eaxd, ptr32[&cpuRegs.GPR.r[rt].UL[i]]);
+			xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].UL[i]], eaxd);
 		}
 	}
 }
@@ -536,11 +536,11 @@ void recNOR_constv(int info, int creg, u32 vreg)
 				xOR(ptr32[&cpuRegs.GPR.r[_Rd_].UL[i]], cval.UL[i]);
 			xNOT(ptr32[&cpuRegs.GPR.r[_Rd_].UL[i]]);
 		} else {
-			xMOV(eax, ptr32[&cpuRegs.GPR.r[vreg].UL[i]]);
+			xMOV(eaxd, ptr32[&cpuRegs.GPR.r[vreg].UL[i]]);
 			if (cval.UL[i])
-				xOR(eax, cval.UL[i]);
-			xNOT(eax);
-			xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].UL[i]], eax);
+				xOR(eaxd, cval.UL[i]);
+			xNOT(eaxd);
+			xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].UL[i]], eaxd);
 		}
 	}
 }
@@ -570,15 +570,15 @@ void recNOR_(int info)
 				xNOT(ptr32[&cpuRegs.GPR.r[_Rd_].UL[i]]);
 				continue;
 			}
-			xMOV(eax, ptr32[&cpuRegs.GPR.r[rt].UL[i]]);
-			xOR(ptr32[&cpuRegs.GPR.r[_Rd_].UL[i]], eax);
+			xMOV(eaxd, ptr32[&cpuRegs.GPR.r[rt].UL[i]]);
+			xOR(ptr32[&cpuRegs.GPR.r[_Rd_].UL[i]], eaxd);
 			xNOT(ptr32[&cpuRegs.GPR.r[_Rd_].UL[i]]);
 		} else {
-			xMOV(eax, ptr32[&cpuRegs.GPR.r[rs].UL[i]]);
+			xMOV(eaxd, ptr32[&cpuRegs.GPR.r[rs].UL[i]]);
 			if (rs != rt)
-				xOR(eax, ptr32[&cpuRegs.GPR.r[rt].UL[i]]);
-			xNOT(eax);
-			xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].UL[i]], eax);
+				xOR(eaxd, ptr32[&cpuRegs.GPR.r[rt].UL[i]]);
+			xNOT(eaxd);
+			xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].UL[i]], eaxd);
 		}
 	}
 }
@@ -599,7 +599,7 @@ void recSLTs_const(int info, int sign, int st)
 
 	GPR_reg64 cval = g_cpuConstRegs[st ? _Rt_ : _Rs_];
 
-	xMOV(eax, 1);
+	xMOV(eaxd, 1);
 
 	xCMP(ptr32[&cpuRegs.GPR.r[st ? _Rs_ : _Rt_].UL[1]], cval.UL[1]);
 	xForwardJump8 pass1(st ? (sign ? Jcc_Less : Jcc_Below) : (sign ? Jcc_Greater : Jcc_Above));
@@ -609,12 +609,12 @@ void recSLTs_const(int info, int sign, int st)
 		xForwardJump8 pass2(st ? Jcc_Below : Jcc_Above);
 
 		fail.SetTarget();
-		xMOV(eax, 0);
+		xMOV(eaxd, 0);
 		pass2.SetTarget();
 	}
 	pass1.SetTarget();
 
-	xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].UL[0]], eax);
+	xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].UL[0]], eaxd);
 	xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].UL[1]], 0);
 }
 
@@ -624,24 +624,24 @@ void recSLTs_(int info, int sign)
 	// TODO: Try cmov on x86-64
 	pxAssert( !(info & PROCESS_EE_XMM) );
 
-	xMOV(eax, 1);
+	xMOV(eaxd, 1);
 
-	xMOV(edx, ptr32[&cpuRegs.GPR.r[_Rs_].UL[1]]);
-	xCMP(edx, ptr32[&cpuRegs.GPR.r[_Rt_].UL[1]]);
+	xMOV(edxd, ptr32[&cpuRegs.GPR.r[_Rs_].UL[1]]);
+	xCMP(edxd, ptr32[&cpuRegs.GPR.r[_Rt_].UL[1]]);
 	xForwardJump8 pass1(sign ? Jcc_Less : Jcc_Below);
 	xForwardJump8 fail(sign ? Jcc_Greater : Jcc_Above);
 	{
-		xMOV(edx, ptr32[&cpuRegs.GPR.r[_Rs_].UL[0]]);
-		xCMP(edx, ptr32[&cpuRegs.GPR.r[_Rt_].UL[0]]);
+		xMOV(edxd, ptr32[&cpuRegs.GPR.r[_Rs_].UL[0]]);
+		xCMP(edxd, ptr32[&cpuRegs.GPR.r[_Rt_].UL[0]]);
 		xForwardJump8 pass2(Jcc_Below);
 
 		fail.SetTarget();
-		xMOV(eax, 0);
+		xMOV(eaxd, 0);
 		pass2.SetTarget();
 	}
 	pass1.SetTarget();
 
-	xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].UL[0]], eax);
+	xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].UL[0]], eaxd);
 	xMOV(ptr32[&cpuRegs.GPR.r[_Rd_].UL[1]], 0);
 }
 
diff --git a/pcsx2/pcsx2/x86/ix86-32/iR5900AritImm.cpp b/pcsx2/pcsx2/x86/ix86-32/iR5900AritImm.cpp
index 31c0b58..5a73f34 100644
--- a/pcsx2/pcsx2/x86/ix86-32/iR5900AritImm.cpp
+++ b/pcsx2/pcsx2/x86/ix86-32/iR5900AritImm.cpp
@@ -66,13 +66,13 @@ void recADDI_(int info)
 		_signExtendSFtoM( (uptr)&cpuRegs.GPR.r[ _Rt_ ].UL[ 1 ]);
 	}
 	else {
-		xMOV(eax, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
+		xMOV(eaxd, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
 
-		if ( _Imm_ != 0 ) xADD(eax, _Imm_ );
+		if ( _Imm_ != 0 ) xADD(eaxd, _Imm_ );
 
 		xCDQ( );
-		xMOV(ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ]], eax);
-		xMOV(ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 1 ]], edx);
+		xMOV(ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ]], eaxd);
+		xMOV(ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 1 ]], edxd);
 	}
 }
 
@@ -100,19 +100,19 @@ void recDADDI_(int info)
 		xADC(ptr32[&cpuRegs.GPR.r[ _Rt_ ].UL[ 1 ]], _Imm_<0?0xffffffff:0);
 	}
 	else {
-		xMOV(eax, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
+		xMOV(eaxd, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
 
-		xMOV(edx, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 1 ] ]);
+		xMOV(edxd, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 1 ] ]);
 
 		if ( _Imm_ != 0 )
 		{
-			xADD(eax, _Imm_ );
-			xADC(edx, _Imm_ < 0?0xffffffff:0);
+			xADD(eaxd, _Imm_ );
+			xADC(edxd, _Imm_ < 0?0xffffffff:0);
 		}
 
-		xMOV(ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ]], eax);
+		xMOV(ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ]], eaxd);
 
-		xMOV(ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 1 ]], edx);
+		xMOV(ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 1 ]], edxd);
 	}
 }
 
@@ -136,7 +136,7 @@ extern u32 s_sltone;
 void recSLTIU_(int info)
 {
 	// TODO: Use 64-bit math on x86-64
-	xMOV(eax, 1);
+	xMOV(eaxd, 1);
 
 	xCMP(ptr32[&cpuRegs.GPR.r[ _Rs_ ].UL[ 1 ]], _Imm_ >= 0 ? 0 : 0xffffffff);
 	j8Ptr[0] = JB8( 0 );
@@ -146,12 +146,12 @@ void recSLTIU_(int info)
 	j8Ptr[1] = JB8(0);
 
 	x86SetJ8(j8Ptr[2]);
-	xXOR(eax, eax);
+	xXOR(eaxd, eaxd);
 
 	x86SetJ8(j8Ptr[0]);
 	x86SetJ8(j8Ptr[1]);
 
-	xMOV(ptr32[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ]], eax);
+	xMOV(ptr32[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ]], eaxd);
 	xMOV(ptr32[&cpuRegs.GPR.r[ _Rt_ ].UL[ 1 ]], 0 );
 }
 
@@ -167,7 +167,7 @@ void recSLTI_(int info)
 {
 	// TODO: Use 64-bit math on x86-64
 	// test silent hill if modding
-	xMOV(eax, 1);
+	xMOV(eaxd, 1);
 
 	xCMP(ptr32[&cpuRegs.GPR.r[ _Rs_ ].UL[ 1 ]], _Imm_ >= 0 ? 0 : 0xffffffff);
 	j8Ptr[0] = JL8( 0 );
@@ -177,12 +177,12 @@ void recSLTI_(int info)
 	j8Ptr[1] = JB8(0);
 
 	x86SetJ8(j8Ptr[2]);
-	xXOR(eax, eax);
+	xXOR(eaxd, eaxd);
 
 	x86SetJ8(j8Ptr[0]);
 	x86SetJ8(j8Ptr[1]);
 
-	xMOV(ptr32[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ]], eax);
+	xMOV(ptr32[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ]], eaxd);
 	xMOV(ptr32[&cpuRegs.GPR.r[ _Rt_ ].UL[ 1 ]], 0 );
 }
 
@@ -208,20 +208,20 @@ void recLogicalOpI(int info, int op)
 			}
 		}
 		else {
-			xMOV(eax, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
+			xMOV(eaxd, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
 			if( op != 0 )
-				xMOV(edx, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 1 ] ]);
+				xMOV(edxd, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 1 ] ]);
 
 			switch(op) {
-				case 0: xAND(eax, _ImmU_); break;
-				case 1: xOR(eax, _ImmU_); break;
-				case 2: xXOR(eax, _ImmU_); break;
+				case 0: xAND(eaxd, _ImmU_); break;
+				case 1: xOR(eaxd, _ImmU_); break;
+				case 2: xXOR(eaxd, _ImmU_); break;
 				default: pxAssert(0);
 			}
 
 			if( op != 0 )
-				xMOV(ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 1 ]], edx);
-			xMOV(ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ]], eax);
+				xMOV(ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 1 ]], edxd);
+			xMOV(ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ]], eaxd);
 		}
 
 		if( op == 0 ) {
@@ -236,10 +236,10 @@ void recLogicalOpI(int info, int op)
 		}
 		else {
 			if( _Rt_ != _Rs_ ) {
-				xMOV(eax, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
-				xMOV(edx, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 1 ] ]);
-				xMOV(ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ]], eax);
-				xMOV(ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 1 ]], edx);
+				xMOV(eaxd, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
+				xMOV(edxd, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 1 ] ]);
+				xMOV(ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ]], eaxd);
+				xMOV(ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 1 ]], edxd);
 			}
 		}
 	}
diff --git a/pcsx2/pcsx2/x86/ix86-32/iR5900Branch.cpp b/pcsx2/pcsx2/x86/ix86-32/iR5900Branch.cpp
index 2877ad5..3d79a7c 100644
--- a/pcsx2/pcsx2/x86/ix86-32/iR5900Branch.cpp
+++ b/pcsx2/pcsx2/x86/ix86-32/iR5900Branch.cpp
@@ -117,7 +117,7 @@ void recSetBranchEQ(int info, int bne, int process)
 			if( t0reg != EEREC_S && t0reg != EEREC_T ) _freeXMMreg(t0reg);
 		}
 
-		xMOVMSKPS(eax, xRegisterSSE(t0reg));
+		xMOVMSKPS(eaxd, xRegisterSSE(t0reg));
 
 		_eeFlushAllUnused();
 
@@ -147,12 +147,12 @@ void recSetBranchEQ(int info, int bne, int process)
 				j32Ptr[ 1 ] = JE32( 0 );
 			}
 			else {
-				xMOV(eax, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
-				xCMP(eax, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
+				xMOV(eaxd, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
+				xCMP(eaxd, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
 				j8Ptr[ 0 ] = JNE8( 0 );
 
-				xMOV(eax, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 1 ] ]);
-				xCMP(eax, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 1 ] ]);
+				xMOV(eaxd, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 1 ] ]);
+				xCMP(eaxd, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 1 ] ]);
 				j32Ptr[ 1 ] = JE32( 0 );
 			}
 
@@ -175,12 +175,12 @@ void recSetBranchEQ(int info, int bne, int process)
 				j32Ptr[ 1 ] = JNE32( 0 );
 			}
 			else {
-				xMOV(eax, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
-				xCMP(eax, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
+				xMOV(eaxd, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
+				xCMP(eaxd, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
 				j32Ptr[ 0 ] = JNE32( 0 );
 
-				xMOV(eax, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 1 ] ]);
-				xCMP(eax, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 1 ] ]);
+				xMOV(eaxd, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 1 ] ]);
+				xCMP(eaxd, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 1 ] ]);
 				j32Ptr[ 1 ] = JNE32( 0 );
 			}
 		}
@@ -194,7 +194,7 @@ void recSetBranchL(int ltz)
 	int regs = _checkXMMreg(XMMTYPE_GPRREG, _Rs_, MODE_READ);
 
 	if( regs >= 0 ) {
-		xMOVMSKPS(eax, xRegisterSSE(regs));
+		xMOVMSKPS(eaxd, xRegisterSSE(regs));
 
 		_eeFlushAllUnused();
 
diff --git a/pcsx2/pcsx2/x86/ix86-32/iR5900Jump.cpp b/pcsx2/pcsx2/x86/ix86-32/iR5900Jump.cpp
index 3475639..e9add12 100644
--- a/pcsx2/pcsx2/x86/ix86-32/iR5900Jump.cpp
+++ b/pcsx2/pcsx2/x86/ix86-32/iR5900Jump.cpp
@@ -107,9 +107,9 @@ void recJALR()
 	_eeMoveGPRtoR(calleeSavedReg2d, _Rs_);
 
 	if (EmuConfig.Gamefixes.GoemonTlbHack) {
-		xMOV(ecx, calleeSavedReg2d);
+		xMOV(ecxd, calleeSavedReg2d);
 		vtlb_DynV2P();
-		xMOV(calleeSavedReg2d, eax);
+		xMOV(calleeSavedReg2d, eaxd);
 	}
 	// uncomment when there are NO instructions that need to call interpreter
 //	int mmreg;
@@ -153,8 +153,8 @@ void recJALR()
 		x86regs[calleeSavedReg2d.GetId()].inuse = 0;
 	}
 	else {
-		xMOV(eax, ptr[&g_recWriteback]);
-		xMOV(ptr[&cpuRegs.pc], eax);
+		xMOV(eaxd, ptr[&g_recWriteback]);
+		xMOV(ptr[&cpuRegs.pc], eaxd);
 	}
 
 	SetBranchReg(0xffffffff);
diff --git a/pcsx2/pcsx2/x86/ix86-32/iR5900LoadStore.cpp b/pcsx2/pcsx2/x86/ix86-32/iR5900LoadStore.cpp
index 3e4ec4c..7ce4a4c 100644
--- a/pcsx2/pcsx2/x86/ix86-32/iR5900LoadStore.cpp
+++ b/pcsx2/pcsx2/x86/ix86-32/iR5900LoadStore.cpp
@@ -172,9 +172,9 @@ void recLoad32( u32 bits, bool sign )
 		if (sign)
 			xCDQ();
 
-		xMOV(ptr32[&cpuRegs.GPR.r[_Rt_].UL[0]], eax);
+		xMOV(ptr32[&cpuRegs.GPR.r[_Rt_].UL[0]], eaxd);
 		if (sign)
-			xMOV(ptr32[&cpuRegs.GPR.r[_Rt_].UL[1]], edx);
+			xMOV(ptr32[&cpuRegs.GPR.r[_Rt_].UL[1]], edxd);
 		else
 			xMOV(ptr32[&cpuRegs.GPR.r[_Rt_].UL[1]], 0);
 	}
@@ -269,20 +269,20 @@ void recLWL()
 		return;
 
 	// mask off bytes loaded
-	xMOV(ecx, calleeSavedReg1d);
-	xMOV(edx, 0xffffff);
-	xSHR(edx, cl);
-	xAND(ptr32[&cpuRegs.GPR.r[_Rt_].UL[0]], edx);
+	xMOV(ecxd, calleeSavedReg1d);
+	xMOV(edxd, 0xffffff);
+	xSHR(edxd, cl);
+	xAND(ptr32[&cpuRegs.GPR.r[_Rt_].UL[0]], edxd);
 
 	// OR in bytes loaded
-	xNEG(ecx);
-	xADD(ecx, 24);
-	xSHL(eax, cl);
-	xOR(ptr32[&cpuRegs.GPR.r[_Rt_].UL[0]], eax);
+	xNEG(ecxd);
+	xADD(ecxd, 24);
+	xSHL(eaxd, cl);
+	xOR(ptr32[&cpuRegs.GPR.r[_Rt_].UL[0]], eaxd);
 
 	// eax will always have the sign bit
 	xCDQ();
-	xMOV(ptr32[&cpuRegs.GPR.r[_Rt_].UL[1]], edx);
+	xMOV(ptr32[&cpuRegs.GPR.r[_Rt_].UL[1]], edxd);
 #else
 	iFlushCall(FLUSH_INTERPRETER);
 	_deleteEEreg(_Rs_, 1);
@@ -317,22 +317,22 @@ void recLWR()
 		return;
 
 	// mask off bytes loaded
-	xMOV(ecx, 24);
-	xSUB(ecx, calleeSavedReg1d);
-	xMOV(edx, 0xffffff00);
-	xSHL(edx, cl);
-	xAND(ptr32[&cpuRegs.GPR.r[_Rt_].UL[0]], edx);
+	xMOV(ecxd, 24);
+	xSUB(ecxd, calleeSavedReg1d);
+	xMOV(edxd, 0xffffff00);
+	xSHL(edxd, cl);
+	xAND(ptr32[&cpuRegs.GPR.r[_Rt_].UL[0]], edxd);
 
 	// OR in bytes loaded
-	xMOV(ecx, calleeSavedReg1d);
-	xSHR(eax, cl);
-	xOR(ptr32[&cpuRegs.GPR.r[_Rt_].UL[0]], eax);
+	xMOV(ecxd, calleeSavedReg1d);
+	xSHR(eaxd, cl);
+	xOR(ptr32[&cpuRegs.GPR.r[_Rt_].UL[0]], eaxd);
 
-	xCMP(ecx, 0);
+	xCMP(ecxd, 0);
 	xForwardJump8 nosignextend(Jcc_NotEqual);
 	// if ((addr & 3) == 0)
 	xCDQ();
-	xMOV(ptr32[&cpuRegs.GPR.r[_Rt_].UL[1]], edx);
+	xMOV(ptr32[&cpuRegs.GPR.r[_Rt_].UL[1]], edxd);
 	nosignextend.SetTarget();
 #else
 	iFlushCall(FLUSH_INTERPRETER);
@@ -364,19 +364,19 @@ void recSWL()
 	vtlb_DynGenRead32(32, false);
 
 	// mask read -> arg2
-	xMOV(ecx, calleeSavedReg1d);
+	xMOV(ecxd, calleeSavedReg1d);
 	xMOV(arg2regd, 0xffffff00);
 	xSHL(arg2regd, cl);
-	xAND(arg2regd, eax);
+	xAND(arg2regd, eaxd);
 
 	if (_Rt_)
 	{
 		// mask write and OR -> edx
-		xNEG(ecx);
-		xADD(ecx, 24);
-		_eeMoveGPRtoR(eax, _Rt_);
-		xSHR(eax, cl);
-		xOR(arg2regd, eax);
+		xNEG(ecxd);
+		xADD(ecxd, 24);
+		_eeMoveGPRtoR(eaxd, _Rt_);
+		xSHR(eaxd, cl);
+		xOR(arg2regd, eaxd);
 	}
 
 	_eeMoveGPRtoR(arg1regd, _Rs_);
@@ -414,19 +414,19 @@ void recSWR()
 	vtlb_DynGenRead32(32, false);
 
 	// mask read -> edx
-	xMOV(ecx, 24);
-	xSUB(ecx, calleeSavedReg1d);
+	xMOV(ecxd, 24);
+	xSUB(ecxd, calleeSavedReg1d);
 	xMOV(arg2regd, 0xffffff);
 	xSHR(arg2regd, cl);
-	xAND(arg2regd, eax);
+	xAND(arg2regd, eaxd);
 
 	if (_Rt_)
 	{
 		// mask write and OR -> edx
-		xMOV(ecx, calleeSavedReg1d);
-		_eeMoveGPRtoR(eax, _Rt_);
-		xSHL(eax, cl);
-		xOR(arg2regd, eax);
+		xMOV(ecxd, calleeSavedReg1d);
+		_eeMoveGPRtoR(eaxd, _Rt_);
+		xSHL(eaxd, cl);
+		xOR(arg2regd, eaxd);
 	}
 
 	_eeMoveGPRtoR(arg1regd, _Rs_);
@@ -521,7 +521,7 @@ void recLWC1()
 		vtlb_DynGenRead32(32, false);
 	}
 
-	xMOV(ptr32[&fpuRegs.fpr[_Rt_].UL], eax);
+	xMOV(ptr32[&fpuRegs.fpr[_Rt_].UL], eaxd);
 
 	EE::Profiler.EmitOp(eeOpcode::LWC1);
 #endif
diff --git a/pcsx2/pcsx2/x86/ix86-32/iR5900Move.cpp b/pcsx2/pcsx2/x86/ix86-32/iR5900Move.cpp
index 43d2e38..a53f72a 100644
--- a/pcsx2/pcsx2/x86/ix86-32/iR5900Move.cpp
+++ b/pcsx2/pcsx2/x86/ix86-32/iR5900Move.cpp
@@ -80,10 +80,10 @@ void recLUI()
 	}
 	else
 	{
-		xMOV(eax, (s32)(cpuRegs.code << 16));
+		xMOV(eaxd, (s32)(cpuRegs.code << 16));
 		xCDQ();
-		xMOV(ptr[&cpuRegs.GPR.r[_Rt_].UL[0]], eax);
-		xMOV(ptr[&cpuRegs.GPR.r[_Rt_].UL[1]], edx);
+		xMOV(ptr[&cpuRegs.GPR.r[_Rt_].UL[0]], eaxd);
+		xMOV(ptr[&cpuRegs.GPR.r[_Rt_].UL[1]], edxd);
 	}
 
 	EE::Profiler.EmitOp(eeOpcode::LUI);
@@ -127,10 +127,10 @@ void recMFHILO(int hi)
 		}
 		else {
 			_deleteEEreg(_Rd_, 0);
-			xMOV(eax, ptr[(void*)(hi ? (uptr)&cpuRegs.HI.UL[ 0 ] : (uptr)&cpuRegs.LO.UL[ 0 ])]);
-			xMOV(edx, ptr[(void*)(hi ? (uptr)&cpuRegs.HI.UL[ 1 ] : (uptr)&cpuRegs.LO.UL[ 1 ])]);
-			xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eax);
-			xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edx);
+			xMOV(eaxd, ptr[(void*)(hi ? (uptr)&cpuRegs.HI.UL[ 0 ] : (uptr)&cpuRegs.LO.UL[ 0 ])]);
+			xMOV(edxd, ptr[(void*)(hi ? (uptr)&cpuRegs.HI.UL[ 1 ] : (uptr)&cpuRegs.LO.UL[ 1 ])]);
+			xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eaxd);
+			xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edxd);
 		}
 	}
 }
@@ -176,12 +176,12 @@ void recMTHILO(int hi)
 				xMOV(ptr32[(u32*)(addrhilo+4)], g_cpuConstRegs[_Rs_].UL[1] );
 			}
 			else {
-				_eeMoveGPRtoR(ecx, _Rs_);
+				_eeMoveGPRtoR(ecxd, _Rs_);
 				_flushEEreg(_Rs_);
-				xMOV(eax, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ]]);
-				xMOV(edx, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 1 ]]);
-				xMOV(ptr[(void*)(addrhilo)], eax);
-				xMOV(ptr[(void*)(addrhilo+4)], edx);
+				xMOV(eaxd, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ]]);
+				xMOV(edxd, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 1 ]]);
+				xMOV(ptr[(void*)(addrhilo)], eaxd);
+				xMOV(ptr[(void*)(addrhilo+4)], edxd);
 			}
 		}
 	}
@@ -249,10 +249,10 @@ void recMFHILO1(int hi)
 		}
 		else {
 			_deleteEEreg(_Rd_, 0);
-			xMOV(eax, ptr[(void*)(hi ? (uptr)&cpuRegs.HI.UL[ 2 ] : (uptr)&cpuRegs.LO.UL[ 2 ])]);
-			xMOV(edx, ptr[(void*)(hi ? (uptr)&cpuRegs.HI.UL[ 3 ] : (uptr)&cpuRegs.LO.UL[ 3 ])]);
-			xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eax);
-			xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edx);
+			xMOV(eaxd, ptr[(void*)(hi ? (uptr)&cpuRegs.HI.UL[ 2 ] : (uptr)&cpuRegs.LO.UL[ 2 ])]);
+			xMOV(edxd, ptr[(void*)(hi ? (uptr)&cpuRegs.HI.UL[ 3 ] : (uptr)&cpuRegs.LO.UL[ 3 ])]);
+			xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eaxd);
+			xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edxd);
 		}
 	}
 }
@@ -288,10 +288,10 @@ void recMTHILO1(int hi)
 			}
 			else {
 				_flushEEreg(_Rs_);
-				xMOV(eax, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ]]);
-				xMOV(edx, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 1 ]]);
-				xMOV(ptr[(void*)(addrhilo+8)], eax);
-				xMOV(ptr[(void*)(addrhilo+12)], edx);
+				xMOV(eaxd, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ]]);
+				xMOV(edxd, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 1 ]]);
+				xMOV(ptr[(void*)(addrhilo+8)], eaxd);
+				xMOV(ptr[(void*)(addrhilo+12)], edxd);
 			}
 		}
 	}
@@ -331,8 +331,8 @@ void recMOVZtemp_const()
 
 void recMOVZtemp_consts(int info)
 {
-	xMOV(eax, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
-	xOR(eax, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 1 ] ]);
+	xMOV(eaxd, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
+	xOR(eaxd, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 1 ] ]);
 	j8Ptr[ 0 ] = JNZ8( 0 );
 
 	xMOV(ptr32[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], g_cpuConstRegs[_Rs_].UL[0] );
@@ -343,22 +343,22 @@ void recMOVZtemp_consts(int info)
 
 void recMOVZtemp_constt(int info)
 {
-	xMOV(eax, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ]]);
-	xMOV(edx, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 1 ]]);
-	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eax);
-	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edx);
+	xMOV(eaxd, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ]]);
+	xMOV(edxd, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 1 ]]);
+	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eaxd);
+	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edxd);
 }
 
 void recMOVZtemp_(int info)
 {
-	xMOV(eax, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
-	xOR(eax, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 1 ] ]);
+	xMOV(eaxd, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
+	xOR(eaxd, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 1 ] ]);
 	j8Ptr[ 0 ] = JNZ8( 0 );
 
-	xMOV(eax, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ]]);
-	xMOV(edx, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 1 ]]);
-	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eax);
-	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edx);
+	xMOV(eaxd, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ]]);
+	xMOV(edxd, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 1 ]]);
+	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eaxd);
+	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edxd);
 
 	x86SetJ8( j8Ptr[ 0 ] );
 }
@@ -387,8 +387,8 @@ void recMOVNtemp_const()
 
 void recMOVNtemp_consts(int info)
 {
-	xMOV(eax, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
-	xOR(eax, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 1 ] ]);
+	xMOV(eaxd, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
+	xOR(eaxd, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 1 ] ]);
 	j8Ptr[ 0 ] = JZ8( 0 );
 
 	xMOV(ptr32[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], g_cpuConstRegs[_Rs_].UL[0] );
@@ -399,22 +399,22 @@ void recMOVNtemp_consts(int info)
 
 void recMOVNtemp_constt(int info)
 {
-	xMOV(eax, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ]]);
-	xMOV(edx, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 1 ]]);
-	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eax);
-	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edx);
+	xMOV(eaxd, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ]]);
+	xMOV(edxd, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 1 ]]);
+	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eaxd);
+	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edxd);
 }
 
 void recMOVNtemp_(int info)
 {
-	xMOV(eax, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
-	xOR(eax, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 1 ] ]);
+	xMOV(eaxd, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
+	xOR(eaxd, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 1 ] ]);
 	j8Ptr[ 0 ] = JZ8( 0 );
 
-	xMOV(eax, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ]]);
-	xMOV(edx, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 1 ]]);
-	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eax);
-	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edx);
+	xMOV(eaxd, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ]]);
+	xMOV(edxd, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 1 ]]);
+	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eaxd);
+	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edxd);
 
 	x86SetJ8( j8Ptr[ 0 ] );
 }
diff --git a/pcsx2/pcsx2/x86/ix86-32/iR5900MultDiv.cpp b/pcsx2/pcsx2/x86/ix86-32/iR5900MultDiv.cpp
index a93aade..157bdfd 100644
--- a/pcsx2/pcsx2/x86/ix86-32/iR5900MultDiv.cpp
+++ b/pcsx2/pcsx2/x86/ix86-32/iR5900MultDiv.cpp
@@ -61,7 +61,7 @@ void recWritebackHILO(int info, int writed, int upper)
 	u8 testlive = upper?EEINST_LIVE2:EEINST_LIVE0;
 
 	if( g_pCurInstInfo->regs[XMMGPR_HI] & testlive )
-		xMOV(ecx, edx);
+		xMOV(ecxd, edxd);
 
 	if( g_pCurInstInfo->regs[XMMGPR_LO] & testlive ) {
 
@@ -76,8 +76,8 @@ void recWritebackHILO(int info, int writed, int upper)
 		}
 
 		xCDQ();
-		xMOV(ptr[(void*)(loaddr)], eax);
-		xMOV(ptr[(void*)(loaddr+4)], edx);
+		xMOV(ptr[(void*)(loaddr)], eaxd);
+		xMOV(ptr[(void*)(loaddr+4)], edxd);
 		savedlo = 1;
 	}
 
@@ -99,8 +99,8 @@ void recWritebackHILO(int info, int writed, int upper)
 			_deleteEEreg(_Rd_, 0);
 
 			if( !savedlo ) xCDQ();
-			xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eax);
-			xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edx);
+			xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eaxd);
+			xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edxd);
 		}
 	}
 
@@ -115,9 +115,9 @@ void recWritebackHILO(int info, int writed, int upper)
 			reghi = -1;
 		}
 
-		xMOV(ptr[(void*)(hiaddr)], ecx);
-		xSAR(ecx, 31);
-		xMOV(ptr[(void*)(hiaddr+4)], ecx);
+		xMOV(ptr[(void*)(hiaddr)], ecxd);
+		xSAR(ecxd, 31);
+		xMOV(ptr[(void*)(hiaddr+4)], ecxd);
 	}
 }
 
@@ -174,15 +174,15 @@ void recMULTUsuper(int info, int upper, int process);
 void recMULTsuper(int info, int upper, int process)
 {
 	if( process & PROCESS_CONSTS ) {
-		xMOV(eax, g_cpuConstRegs[_Rs_].UL[0] );
+		xMOV(eaxd, g_cpuConstRegs[_Rs_].UL[0] );
 		xMUL(ptr32[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
 	}
 	else if( process & PROCESS_CONSTT) {
-		xMOV(eax, g_cpuConstRegs[_Rt_].UL[0] );
+		xMOV(eaxd, g_cpuConstRegs[_Rt_].UL[0] );
 		xMUL(ptr32[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
 	}
 	else {
-		xMOV(eax, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
+		xMOV(eaxd, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
 		xMUL(ptr32[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
 	}
 
@@ -218,15 +218,15 @@ void recMULTU_const()
 void recMULTUsuper(int info, int upper, int process)
 {
 	if( process & PROCESS_CONSTS ) {
-		xMOV(eax, g_cpuConstRegs[_Rs_].UL[0] );
+		xMOV(eaxd, g_cpuConstRegs[_Rs_].UL[0] );
 		xUMUL(ptr32[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
 	}
 	else if( process & PROCESS_CONSTT) {
-		xMOV(eax, g_cpuConstRegs[_Rt_].UL[0] );
+		xMOV(eaxd, g_cpuConstRegs[_Rt_].UL[0] );
 		xUMUL(ptr32[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
 	}
 	else {
-		xMOV(eax, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
+		xMOV(eaxd, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
 		xUMUL(ptr32[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
 	}
 
@@ -332,52 +332,52 @@ void recDIV_const()
 void recDIVsuper(int info, int sign, int upper, int process)
 {
 	if( process & PROCESS_CONSTT )
-		xMOV(ecx, g_cpuConstRegs[_Rt_].UL[0] );
+		xMOV(ecxd, g_cpuConstRegs[_Rt_].UL[0] );
 	else
-		xMOV(ecx, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
+		xMOV(ecxd, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
 
 	if( process & PROCESS_CONSTS )
-		xMOV(eax, g_cpuConstRegs[_Rs_].UL[0] );
+		xMOV(eaxd, g_cpuConstRegs[_Rs_].UL[0] );
 	else
-		xMOV(eax, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
+		xMOV(eaxd, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
 
 	u8 *end1;
 	if (sign)  //test for overflow (x86 will just throw an exception)
 	{
-		xCMP(eax, 0x80000000 );
+		xCMP(eaxd, 0x80000000 );
 		u8 *cont1 = JNE8(0);
-		xCMP(ecx, 0xffffffff );
+		xCMP(ecxd, 0xffffffff );
 		u8 *cont2 = JNE8(0);
 		//overflow case:
-		xXOR(edx, edx); //EAX remains 0x80000000
+		xXOR(edxd, edxd); //EAX remains 0x80000000
 		end1 = JMP8(0);
 
 		x86SetJ8(cont1);
 		x86SetJ8(cont2);
 	}
 
-	xCMP(ecx, 0 );
+	xCMP(ecxd, 0 );
 	u8 *cont3 = JNE8(0);
 	//divide by zero
-	xMOV(edx, eax);
+	xMOV(edxd, eaxd);
 	if (sign) //set EAX to (EAX < 0)?1:-1
 	{
-		xSAR(eax, 31 ); //(EAX < 0)?-1:0
-		xSHL(eax, 1 ); //(EAX < 0)?-2:0
-		xNOT(eax); //(EAX < 0)?1:-1
+		xSAR(eaxd, 31 ); //(EAX < 0)?-1:0
+		xSHL(eaxd, 1 ); //(EAX < 0)?-2:0
+		xNOT(eaxd); //(EAX < 0)?1:-1
 	}
 	else
-		xMOV(eax, 0xffffffff );
+		xMOV(eaxd, 0xffffffff );
 	u8 *end2 = JMP8(0);
 
 	x86SetJ8(cont3);
 	if( sign ) {
 		xCDQ();
-		xDIV(ecx);
+		xDIV(ecxd);
 	}
 	else {
-		xXOR(edx, edx);
-		xUDIV(ecx);
+		xXOR(edxd, edxd);
+		xUDIV(ecxd);
 	}
 
 	if (sign) x86SetJ8( end1 );
@@ -495,25 +495,25 @@ void recMADD()
 		_deleteEEreg(XMMGPR_HI, 1);
 
 		// dadd
-		xMOV(eax, ptr[&cpuRegs.LO.UL[ 0 ] ]);
-		xMOV(ecx, ptr[&cpuRegs.HI.UL[ 0 ] ]);
-		xADD(eax, (u32)result&0xffffffff );
-		xADC(ecx, (u32)(result>>32) );
+		xMOV(eaxd, ptr[&cpuRegs.LO.UL[ 0 ] ]);
+		xMOV(ecxd, ptr[&cpuRegs.HI.UL[ 0 ] ]);
+		xADD(eaxd, (u32)result&0xffffffff );
+		xADC(ecxd, (u32)(result>>32) );
 		xCDQ();
 		if( _Rd_) {
 			_eeOnWriteReg(_Rd_, 1);
 			_deleteEEreg(_Rd_, 0);
-			xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eax);
-			xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edx);
+			xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eaxd);
+			xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edxd);
 		}
 
-		xMOV(ptr[&cpuRegs.LO.UL[0]], eax);
-		xMOV(ptr[&cpuRegs.LO.UL[1]], edx);
+		xMOV(ptr[&cpuRegs.LO.UL[0]], eaxd);
+		xMOV(ptr[&cpuRegs.LO.UL[1]], edxd);
 
-		xMOV(ptr[&cpuRegs.HI.UL[0]], ecx);
-		xMOV(eax, ecx);
+		xMOV(ptr[&cpuRegs.HI.UL[0]], ecxd);
+		xMOV(eaxd, ecxd);
 		xCDQ();
-		xMOV(ptr[&cpuRegs.HI.UL[1]], edx);
+		xMOV(ptr[&cpuRegs.HI.UL[1]], edxd);
 		return;
 	}
 
@@ -523,36 +523,36 @@ void recMADD()
 	_deleteGPRtoXMMreg(_Rt_, 1);
 
 	if( GPR_IS_CONST1(_Rs_) ) {
-		xMOV(eax, g_cpuConstRegs[_Rs_].UL[0] );
+		xMOV(eaxd, g_cpuConstRegs[_Rs_].UL[0] );
 		xMUL(ptr32[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
 	}
 	else if ( GPR_IS_CONST1(_Rt_) ) {
-		xMOV(eax, g_cpuConstRegs[_Rt_].UL[0] );
+		xMOV(eaxd, g_cpuConstRegs[_Rt_].UL[0] );
 		xMUL(ptr32[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
 	}
 	else {
-		xMOV(eax, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
+		xMOV(eaxd, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
 		xMUL(ptr32[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
 	}
 
-	xMOV(ecx, edx);
-	xADD(eax, ptr[&cpuRegs.LO.UL[0] ]);
-	xADC(ecx, ptr[&cpuRegs.HI.UL[0] ]);
+	xMOV(ecxd, edxd);
+	xADD(eaxd, ptr[&cpuRegs.LO.UL[0] ]);
+	xADC(ecxd, ptr[&cpuRegs.HI.UL[0] ]);
 	xCDQ();
 	if( _Rd_ ) {
 		_eeOnWriteReg(_Rd_, 1);
 		_deleteEEreg(_Rd_, 0);
-		xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eax);
-		xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edx);
+		xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eaxd);
+		xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edxd);
 	}
 
-	xMOV(ptr[&cpuRegs.LO.UL[0]], eax);
-	xMOV(ptr[&cpuRegs.LO.UL[1]], edx);
+	xMOV(ptr[&cpuRegs.LO.UL[0]], eaxd);
+	xMOV(ptr[&cpuRegs.LO.UL[1]], edxd);
 
-	xMOV(ptr[&cpuRegs.HI.UL[0]], ecx);
-	xMOV(eax, ecx);
+	xMOV(ptr[&cpuRegs.HI.UL[0]], ecxd);
+	xMOV(eaxd, ecxd);
 	xCDQ();
-	xMOV(ptr[&cpuRegs.HI.UL[1]], edx);
+	xMOV(ptr[&cpuRegs.HI.UL[1]], edxd);
 }
 
 //static PCSX2_ALIGNED16(u32 s_MaddMask[]) = { 0x80000000, 0, 0x80000000, 0 };
@@ -565,25 +565,25 @@ void recMADDU()
 		_deleteEEreg(XMMGPR_HI, 1);
 
 		// dadd
-		xMOV(eax, ptr[&cpuRegs.LO.UL[ 0 ] ]);
-		xMOV(ecx, ptr[&cpuRegs.HI.UL[ 0 ] ]);
-		xADD(eax, (u32)result&0xffffffff );
-		xADC(ecx, (u32)(result>>32) );
+		xMOV(eaxd, ptr[&cpuRegs.LO.UL[ 0 ] ]);
+		xMOV(ecxd, ptr[&cpuRegs.HI.UL[ 0 ] ]);
+		xADD(eaxd, (u32)result&0xffffffff );
+		xADC(ecxd, (u32)(result>>32) );
 		xCDQ();
 		if( _Rd_) {
 			_eeOnWriteReg(_Rd_, 1);
 			_deleteEEreg(_Rd_, 0);
-			xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eax);
-			xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edx);
+			xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eaxd);
+			xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edxd);
 		}
 
-		xMOV(ptr[&cpuRegs.LO.UL[0]], eax);
-		xMOV(ptr[&cpuRegs.LO.UL[1]], edx);
+		xMOV(ptr[&cpuRegs.LO.UL[0]], eaxd);
+		xMOV(ptr[&cpuRegs.LO.UL[1]], edxd);
 
-		xMOV(ptr[&cpuRegs.HI.UL[0]], ecx);
-		xMOV(eax, ecx);
+		xMOV(ptr[&cpuRegs.HI.UL[0]], ecxd);
+		xMOV(eaxd, ecxd);
 		xCDQ();
-		xMOV(ptr[&cpuRegs.HI.UL[1]], edx);
+		xMOV(ptr[&cpuRegs.HI.UL[1]], edxd);
 		return;
 	}
 
@@ -593,36 +593,36 @@ void recMADDU()
 	_deleteGPRtoXMMreg(_Rt_, 1);
 
 	if( GPR_IS_CONST1(_Rs_) ) {
-		xMOV(eax, g_cpuConstRegs[_Rs_].UL[0] );
+		xMOV(eaxd, g_cpuConstRegs[_Rs_].UL[0] );
 		xUMUL(ptr32[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
 	}
 	else if ( GPR_IS_CONST1(_Rt_) ) {
-		xMOV(eax, g_cpuConstRegs[_Rt_].UL[0] );
+		xMOV(eaxd, g_cpuConstRegs[_Rt_].UL[0] );
 		xUMUL(ptr32[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
 	}
 	else {
-		xMOV(eax, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
+		xMOV(eaxd, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
 		xUMUL(ptr32[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
 	}
 
-	xMOV(ecx, edx);
-	xADD(eax, ptr[&cpuRegs.LO.UL[0] ]);
-	xADC(ecx, ptr[&cpuRegs.HI.UL[0] ]);
+	xMOV(ecxd, edxd);
+	xADD(eaxd, ptr[&cpuRegs.LO.UL[0] ]);
+	xADC(ecxd, ptr[&cpuRegs.HI.UL[0] ]);
 	xCDQ();
 	if( _Rd_ ) {
 		_eeOnWriteReg(_Rd_, 1);
 		_deleteEEreg(_Rd_, 0);
-		xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eax);
-		xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edx);
+		xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eaxd);
+		xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edxd);
 	}
 
-	xMOV(ptr[&cpuRegs.LO.UL[0]], eax);
-	xMOV(ptr[&cpuRegs.LO.UL[1]], edx);
+	xMOV(ptr[&cpuRegs.LO.UL[0]], eaxd);
+	xMOV(ptr[&cpuRegs.LO.UL[1]], edxd);
 
-	xMOV(ptr[&cpuRegs.HI.UL[0]], ecx);
-	xMOV(eax, ecx);
+	xMOV(ptr[&cpuRegs.HI.UL[0]], ecxd);
+	xMOV(eaxd, ecxd);
 	xCDQ();
-	xMOV(ptr[&cpuRegs.HI.UL[1]], edx);
+	xMOV(ptr[&cpuRegs.HI.UL[1]], edxd);
 }
 
 void recMADD1()
@@ -633,25 +633,25 @@ void recMADD1()
 		_deleteEEreg(XMMGPR_HI, 1);
 
 		// dadd
-		xMOV(eax, ptr[&cpuRegs.LO.UL[ 2 ] ]);
-		xMOV(ecx, ptr[&cpuRegs.HI.UL[ 2 ] ]);
-		xADD(eax, (u32)result&0xffffffff );
-		xADC(ecx, (u32)(result>>32) );
+		xMOV(eaxd, ptr[&cpuRegs.LO.UL[ 2 ] ]);
+		xMOV(ecxd, ptr[&cpuRegs.HI.UL[ 2 ] ]);
+		xADD(eaxd, (u32)result&0xffffffff );
+		xADC(ecxd, (u32)(result>>32) );
 		xCDQ();
 		if( _Rd_) {
 			_eeOnWriteReg(_Rd_, 1);
 			_deleteEEreg(_Rd_, 0);
-			xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eax);
-			xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edx);
+			xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eaxd);
+			xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edxd);
 		}
 
-		xMOV(ptr[&cpuRegs.LO.UL[2]], eax);
-		xMOV(ptr[&cpuRegs.LO.UL[3]], edx);
+		xMOV(ptr[&cpuRegs.LO.UL[2]], eaxd);
+		xMOV(ptr[&cpuRegs.LO.UL[3]], edxd);
 
-		xMOV(ptr[&cpuRegs.HI.UL[2]], ecx);
-		xMOV(eax, ecx);
+		xMOV(ptr[&cpuRegs.HI.UL[2]], ecxd);
+		xMOV(eaxd, ecxd);
 		xCDQ();
-		xMOV(ptr[&cpuRegs.HI.UL[3]], edx);
+		xMOV(ptr[&cpuRegs.HI.UL[3]], edxd);
 		return;
 	}
 
@@ -661,36 +661,36 @@ void recMADD1()
 	_deleteGPRtoXMMreg(_Rt_, 1);
 
 	if( GPR_IS_CONST1(_Rs_) ) {
-		xMOV(eax, g_cpuConstRegs[_Rs_].UL[0] );
+		xMOV(eaxd, g_cpuConstRegs[_Rs_].UL[0] );
 		xMUL(ptr32[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
 	}
 	else if ( GPR_IS_CONST1(_Rt_) ) {
-		xMOV(eax, g_cpuConstRegs[_Rt_].UL[0] );
+		xMOV(eaxd, g_cpuConstRegs[_Rt_].UL[0] );
 		xMUL(ptr32[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
 	}
 	else {
-		xMOV(eax, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
+		xMOV(eaxd, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
 		xMUL(ptr32[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
 	}
 
-	xMOV(ecx, edx);
-	xADD(eax, ptr[&cpuRegs.LO.UL[2] ]);
-	xADC(ecx, ptr[&cpuRegs.HI.UL[2] ]);
+	xMOV(ecxd, edxd);
+	xADD(eaxd, ptr[&cpuRegs.LO.UL[2] ]);
+	xADC(ecxd, ptr[&cpuRegs.HI.UL[2] ]);
 	xCDQ();
 	if( _Rd_ ) {
 		_eeOnWriteReg(_Rd_, 1);
 		_deleteEEreg(_Rd_, 0);
-		xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eax);
-		xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edx);
+		xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eaxd);
+		xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edxd);
 	}
 
-	xMOV(ptr[&cpuRegs.LO.UL[2]], eax);
-	xMOV(ptr[&cpuRegs.LO.UL[3]], edx);
+	xMOV(ptr[&cpuRegs.LO.UL[2]], eaxd);
+	xMOV(ptr[&cpuRegs.LO.UL[3]], edxd);
 
-	xMOV(ptr[&cpuRegs.HI.UL[2]], ecx);
-	xMOV(eax, ecx);
+	xMOV(ptr[&cpuRegs.HI.UL[2]], ecxd);
+	xMOV(eaxd, ecxd);
 	xCDQ();
-	xMOV(ptr[&cpuRegs.HI.UL[3]], edx);
+	xMOV(ptr[&cpuRegs.HI.UL[3]], edxd);
 }
 
 //static PCSX2_ALIGNED16(u32 s_MaddMask[]) = { 0x80000000, 0, 0x80000000, 0 };
@@ -703,25 +703,25 @@ void recMADDU1()
 		_deleteEEreg(XMMGPR_HI, 1);
 
 		// dadd
-		xMOV(eax, ptr[&cpuRegs.LO.UL[ 2 ] ]);
-		xMOV(ecx, ptr[&cpuRegs.HI.UL[ 2 ] ]);
-		xADD(eax, (u32)result&0xffffffff );
-		xADC(ecx, (u32)(result>>32) );
+		xMOV(eaxd, ptr[&cpuRegs.LO.UL[ 2 ] ]);
+		xMOV(ecxd, ptr[&cpuRegs.HI.UL[ 2 ] ]);
+		xADD(eaxd, (u32)result&0xffffffff );
+		xADC(ecxd, (u32)(result>>32) );
 		xCDQ();
 		if( _Rd_) {
 			_eeOnWriteReg(_Rd_, 1);
 			_deleteEEreg(_Rd_, 0);
-			xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eax);
-			xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edx);
+			xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eaxd);
+			xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edxd);
 		}
 
-		xMOV(ptr[&cpuRegs.LO.UL[2]], eax);
-		xMOV(ptr[&cpuRegs.LO.UL[3]], edx);
+		xMOV(ptr[&cpuRegs.LO.UL[2]], eaxd);
+		xMOV(ptr[&cpuRegs.LO.UL[3]], edxd);
 
-		xMOV(ptr[&cpuRegs.HI.UL[2]], ecx);
-		xMOV(eax, ecx);
+		xMOV(ptr[&cpuRegs.HI.UL[2]], ecxd);
+		xMOV(eaxd, ecxd);
 		xCDQ();
-		xMOV(ptr[&cpuRegs.HI.UL[3]], edx);
+		xMOV(ptr[&cpuRegs.HI.UL[3]], edxd);
 		return;
 	}
 
@@ -731,36 +731,36 @@ void recMADDU1()
 	_deleteGPRtoXMMreg(_Rt_, 1);
 
 	if( GPR_IS_CONST1(_Rs_) ) {
-		xMOV(eax, g_cpuConstRegs[_Rs_].UL[0] );
+		xMOV(eaxd, g_cpuConstRegs[_Rs_].UL[0] );
 		xUMUL(ptr32[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
 	}
 	else if ( GPR_IS_CONST1(_Rt_) ) {
-		xMOV(eax, g_cpuConstRegs[_Rt_].UL[0] );
+		xMOV(eaxd, g_cpuConstRegs[_Rt_].UL[0] );
 		xUMUL(ptr32[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
 	}
 	else {
-		xMOV(eax, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
+		xMOV(eaxd, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
 		xUMUL(ptr32[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
 	}
 
-	xMOV(ecx, edx);
-	xADD(eax, ptr[&cpuRegs.LO.UL[2] ]);
-	xADC(ecx, ptr[&cpuRegs.HI.UL[2] ]);
+	xMOV(ecxd, edxd);
+	xADD(eaxd, ptr[&cpuRegs.LO.UL[2] ]);
+	xADC(ecxd, ptr[&cpuRegs.HI.UL[2] ]);
 	xCDQ();
 	if( _Rd_ ) {
 		_eeOnWriteReg(_Rd_, 1);
 		_deleteEEreg(_Rd_, 0);
-		xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eax);
-		xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edx);
+		xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eaxd);
+		xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edxd);
 	}
 
-	xMOV(ptr[&cpuRegs.LO.UL[2]], eax);
-	xMOV(ptr[&cpuRegs.LO.UL[3]], edx);
+	xMOV(ptr[&cpuRegs.LO.UL[2]], eaxd);
+	xMOV(ptr[&cpuRegs.LO.UL[3]], edxd);
 
-	xMOV(ptr[&cpuRegs.HI.UL[2]], ecx);
-	xMOV(eax, ecx);
+	xMOV(ptr[&cpuRegs.HI.UL[2]], ecxd);
+	xMOV(eaxd, ecxd);
 	xCDQ();
-	xMOV(ptr[&cpuRegs.HI.UL[3]], edx);
+	xMOV(ptr[&cpuRegs.HI.UL[3]], edxd);
 }
 
 
diff --git a/pcsx2/pcsx2/x86/ix86-32/iR5900Shift.cpp b/pcsx2/pcsx2/x86/ix86-32/iR5900Shift.cpp
index 4bfbc13..e9e76dc 100644
--- a/pcsx2/pcsx2/x86/ix86-32/iR5900Shift.cpp
+++ b/pcsx2/pcsx2/x86/ix86-32/iR5900Shift.cpp
@@ -64,15 +64,15 @@ void recSLLs_(int info, int sa)
 {
 	pxAssert( !(info & PROCESS_EE_XMM) );
 
-	xMOV(eax, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
+	xMOV(eaxd, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
 	if ( sa != 0 )
 	{
-		xSHL(eax, sa );
+		xSHL(eaxd, sa );
 	}
 
 	xCDQ( );
-	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eax);
-	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edx);
+	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eaxd);
+	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edxd);
 }
 
 void recSLL_(int info)
@@ -92,12 +92,12 @@ void recSRLs_(int info, int sa)
 {
 	pxAssert( !(info & PROCESS_EE_XMM) );
 
-	xMOV(eax, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
-	if ( sa != 0 ) xSHR(eax, sa);
+	xMOV(eaxd, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
+	if ( sa != 0 ) xSHR(eaxd, sa);
 
 	xCDQ( );
-	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eax);
-	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edx);
+	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eaxd);
+	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edxd);
 }
 
 void recSRL_(int info)
@@ -117,12 +117,12 @@ void recSRAs_(int info, int sa)
 {
 	pxAssert( !(info & PROCESS_EE_XMM) );
 
-	xMOV(eax, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
-	if ( sa != 0 ) xSAR(eax, sa);
+	xMOV(eaxd, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
+	if ( sa != 0 ) xSAR(eaxd, sa);
 
 	xCDQ();
-	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eax);
-	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edx);
+	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eaxd);
+	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edxd);
 }
 
 void recSRA_(int info)
@@ -266,13 +266,13 @@ void recDSLL32s_(int info, int sa)
 {
 	pxAssert( !(info & PROCESS_EE_XMM) );
 
-	xMOV(eax, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
+	xMOV(eaxd, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
 	if ( sa != 0 )
 	{
-		xSHL(eax, sa );
+		xSHL(eaxd, sa );
 	}
 	xMOV(ptr32[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], 0 );
-	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], eax);
+	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], eaxd);
 
 }
 
@@ -293,10 +293,10 @@ void recDSRL32s_(int info, int sa)
 {
 	pxAssert( !(info & PROCESS_EE_XMM) );
 
-	xMOV(eax, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 1 ] ]);
-	if ( sa != 0 ) xSHR(eax, sa );
+	xMOV(eaxd, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 1 ] ]);
+	if ( sa != 0 ) xSHR(eaxd, sa );
 
-	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eax);
+	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eaxd);
 	xMOV(ptr32[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], 0 );
 }
 
@@ -317,12 +317,12 @@ void recDSRA32s_(int info, int sa)
 {
 	pxAssert( !(info & PROCESS_EE_XMM) );
 
-	xMOV(eax, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 1 ] ]);
+	xMOV(eaxd, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 1 ] ]);
 	xCDQ( );
-	if ( sa != 0 ) xSAR(eax, sa );
+	if ( sa != 0 ) xSAR(eaxd, sa );
 
-	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eax);
-	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edx);
+	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eaxd);
+	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edxd);
 
 }
 
@@ -351,9 +351,9 @@ void recSetShiftV(int info, int* rsreg, int* rtreg, int* rdreg, int* rstemp)
 
 	*rstemp = _allocTempXMMreg(XMMT_INT, -1);
 
-	xMOV(eax, ptr[&cpuRegs.GPR.r[_Rs_].UL[0]]);
-	xAND(eax, 0x3f);
-	xMOVDZX(xRegisterSSE(*rstemp), eax);
+	xMOV(eaxd, ptr[&cpuRegs.GPR.r[_Rs_].UL[0]]);
+	xAND(eaxd, 0x3f);
+	xMOVDZX(xRegisterSSE(*rstemp), eaxd);
 	*rsreg = *rstemp;
 
 	if( *rtreg != *rdreg ) xMOVDQA(xRegisterSSE(*rdreg), xRegisterSSE(*rtreg));
@@ -372,9 +372,9 @@ void recSetConstShiftV(int info, int* rsreg, int* rdreg, int* rstemp)
 
 	*rstemp = _allocTempXMMreg(XMMT_INT, -1);
 
-	xMOV(eax, ptr[&cpuRegs.GPR.r[_Rs_].UL[0]]);
-	xAND(eax, 0x3f);
-	xMOVDZX(xRegisterSSE(*rstemp), eax);
+	xMOV(eaxd, ptr[&cpuRegs.GPR.r[_Rs_].UL[0]]);
+	xAND(eaxd, 0x3f);
+	xMOVDZX(xRegisterSSE(*rstemp), eaxd);
 	*rsreg = *rstemp;
 }
 
@@ -391,27 +391,27 @@ void recSLLV_consts(int info)
 
 void recSLLV_constt(int info)
 {
-	xMOV(ecx, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
+	xMOV(ecxd, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
 
-	xMOV(eax, g_cpuConstRegs[_Rt_].UL[0] );
-	xAND(ecx, 0x1f );
-	xSHL(eax, cl);
+	xMOV(eaxd, g_cpuConstRegs[_Rt_].UL[0] );
+	xAND(ecxd, 0x1f );
+	xSHL(eaxd, cl);
 
 	eeSignExtendTo(_Rd_);
 }
 
 void recSLLV_(int info)
 {
-	xMOV(eax, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
+	xMOV(eaxd, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
 	if ( _Rs_ != 0 )
 	{
-		xMOV(ecx, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
-		xAND(ecx, 0x1f );
-		xSHL(eax, cl);
+		xMOV(ecxd, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
+		xAND(ecxd, 0x1f );
+		xSHL(eaxd, cl);
 	}
 	xCDQ();
-	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eax);
-	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edx);
+	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eaxd);
+	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edxd);
 }
 
 EERECOMPILE_CODE0(SLLV, XMMINFO_READS|XMMINFO_READT|XMMINFO_WRITED);
@@ -429,27 +429,27 @@ void recSRLV_consts(int info)
 
 void recSRLV_constt(int info)
 {
-	xMOV(ecx, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
+	xMOV(ecxd, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
 
-	xMOV(eax, g_cpuConstRegs[_Rt_].UL[0] );
-	xAND(ecx, 0x1f );
-	xSHR(eax, cl);
+	xMOV(eaxd, g_cpuConstRegs[_Rt_].UL[0] );
+	xAND(ecxd, 0x1f );
+	xSHR(eaxd, cl);
 
 	eeSignExtendTo(_Rd_);
 }
 
 void recSRLV_(int info)
 {
-	xMOV(eax, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
+	xMOV(eaxd, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
 	if ( _Rs_ != 0 )
 	{
-		xMOV(ecx, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
-		xAND(ecx, 0x1f );
-		xSHR(eax, cl);
+		xMOV(ecxd, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
+		xAND(ecxd, 0x1f );
+		xSHR(eaxd, cl);
 	}
 	xCDQ( );
-	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eax);
-	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edx);
+	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eaxd);
+	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edxd);
 }
 
 EERECOMPILE_CODE0(SRLV, XMMINFO_READS|XMMINFO_READT|XMMINFO_WRITED);
@@ -467,27 +467,27 @@ void recSRAV_consts(int info)
 
 void recSRAV_constt(int info)
 {
-	xMOV(ecx, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
+	xMOV(ecxd, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
 
-	xMOV(eax, g_cpuConstRegs[_Rt_].UL[0] );
-	xAND(ecx, 0x1f );
-	xSAR(eax, cl);
+	xMOV(eaxd, g_cpuConstRegs[_Rt_].UL[0] );
+	xAND(ecxd, 0x1f );
+	xSAR(eaxd, cl);
 
 	eeSignExtendTo(_Rd_);
 }
 
 void recSRAV_(int info)
 {
-	xMOV(eax, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
+	xMOV(eaxd, ptr[&cpuRegs.GPR.r[ _Rt_ ].UL[ 0 ] ]);
 	if ( _Rs_ != 0 )
 	{
-		xMOV(ecx, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
-		xAND(ecx, 0x1f );
-		xSAR(eax, cl);
+		xMOV(ecxd, ptr[&cpuRegs.GPR.r[ _Rs_ ].UL[ 0 ] ]);
+		xAND(ecxd, 0x1f );
+		xSAR(eaxd, cl);
 	}
 	xCDQ( );
-	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eax);
-	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edx);
+	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 0 ]], eaxd);
+	xMOV(ptr[&cpuRegs.GPR.r[ _Rd_ ].UL[ 1 ]], edxd);
 }
 
 EERECOMPILE_CODE0(SRAV, XMMINFO_READS|XMMINFO_READT|XMMINFO_WRITED);
@@ -617,8 +617,8 @@ void recDSRAV_constt(int info)
 	xPSHUF.D(xRegisterSSE(t0reg), xRegisterSSE(t0reg), 0x55);
 
 	// shift highest bit, 64 - eax
-	xMOV(eax, 64);
-	xMOVDZX(xRegisterSSE(t1reg), eax);
+	xMOV(eaxd, 64);
+	xMOVDZX(xRegisterSSE(t1reg), eaxd);
 	xPSUB.D(xRegisterSSE(t1reg), xRegisterSSE(rsreg));
 
 	// right logical shift
@@ -653,8 +653,8 @@ void recDSRAV_(int info)
 	xPSHUF.D(xRegisterSSE(t0reg), xRegisterSSE(t0reg), 0x55);
 
 	// shift highest bit, 64 - eax
-	xMOV(eax, 64);
-	xMOVDZX(xRegisterSSE(t1reg), eax);
+	xMOV(eaxd, 64);
+	xMOVDZX(xRegisterSSE(t1reg), eaxd);
 	xPSUB.D(xRegisterSSE(t1reg), xRegisterSSE(rsreg));
 
 	// right logical shift
diff --git a/pcsx2/pcsx2/x86/ix86-32/recVTLB.cpp b/pcsx2/pcsx2/x86/ix86-32/recVTLB.cpp
index ef4d2a4..8fa1aca 100644
--- a/pcsx2/pcsx2/x86/ix86-32/recVTLB.cpp
+++ b/pcsx2/pcsx2/x86/ix86-32/recVTLB.cpp
@@ -159,11 +159,10 @@ namespace vtlb_private
 		// Warning dirty ebx (in case someone got the very bad idea to move this code)
 		EE::Profiler.EmitMem();
 
-		xMOV( eax, arg1regd );
-		xSHR( eax, VTLB_PAGE_BITS );
+		xMOV( eaxd, arg1regd );
+		xSHR( eaxd, VTLB_PAGE_BITS );
 		xMOV( rax, ptrNative[xComplexAddress(rbx, vtlbdata.vmap, rax*wordsize)] );
-		xLEA( rbx, ptr[(void*)(0xdcdcdcd + (wordsize == 8 ? (uptr)xGetPtr() + 7 : 0))] );
-		u32* writeback = ((u32*)xGetPtr()) - 1;
+		u32* writeback = xLEA_Writeback( rbx );
 		xADD( arg1reg, rax );
 
 		return writeback;
@@ -176,20 +175,20 @@ namespace vtlb_private
 		{
 			case 8:
 				if( sign )
-					xMOVSX( eax, ptr8[arg1reg] );
+					xMOVSX( eaxd, ptr8[arg1reg] );
 				else
-					xMOVZX( eax, ptr8[arg1reg] );
+					xMOVZX( eaxd, ptr8[arg1reg] );
 			break;
 
 			case 16:
 				if( sign )
-					xMOVSX( eax, ptr16[arg1reg] );
+					xMOVSX( eaxd, ptr16[arg1reg] );
 				else
-					xMOVZX( eax, ptr16[arg1reg] );
+					xMOVZX( eaxd, ptr16[arg1reg] );
 			break;
 
 			case 32:
-				xMOV( eax, ptr[arg1reg] );
+				xMOV( eaxd, ptr[arg1reg] );
 			break;
 
 			case 64:
@@ -212,7 +211,7 @@ namespace vtlb_private
 		{
 			//8 , 16, 32 : data on EDX
 			case 8:
-				xMOV( edx, arg2regd );
+				xMOV( edxd, arg2regd );
 				xMOV( ptr[arg1reg], dl );
 			break;
 
@@ -288,9 +287,9 @@ static void DynGen_IndirectDispatch( int mode, int bits, bool sign = false )
 // Out: eax: result (if mode < 64)
 static void DynGen_IndirectTlbDispatcher( int mode, int bits, bool sign )
 {
-	xMOVZX( eax, al );
+	xMOVZX( eaxd, al );
 	if (wordsize != 8) xSUB( arg1regd, 0x80000000 );
-	xSUB( arg1regd, eax );
+	xSUB( arg1regd, eaxd );
 
 	// jump to the indirect handler, which is a __fastcall C++ function.
 	// [ecx is address, edx is data]
@@ -307,16 +306,16 @@ static void DynGen_IndirectTlbDispatcher( int mode, int bits, bool sign )
 		if (bits == 0)
 		{
 			if (sign)
-				xMOVSX(eax, al);
+				xMOVSX(eaxd, al);
 			else
-				xMOVZX(eax, al);
+				xMOVZX(eaxd, al);
 		}
 		else if (bits == 1)
 		{
 			if (sign)
-				xMOVSX(eax, ax);
+				xMOVSX(eaxd, ax);
 			else
-				xMOVZX(eax, ax);
+				xMOVZX(eaxd, ax);
 		}
 	}
 
@@ -356,9 +355,12 @@ void vtlb_dynarec_init()
 	Perf::any.map((uptr)m_IndirectDispatchers, __pagesize, "TLB Dispatcher");
 }
 
-static void vtlb_SetWriteback(u32 *writeback) {
+static void vtlb_SetWriteback(u32 *writeback)
+{
 	uptr val = (uptr)xGetPtr();
-	if (wordsize == 8) {
+	if (wordsize == 8)
+	{
+		pxAssertMsg(*((u8*)writeback - 2) == 0x8d, "Expected codegen to be an LEA");
 		val -= ((uptr)writeback + 4);
 	}
 	pxAssertMsg((sptr)val == (s32)val, "Writeback too far away!");
@@ -456,20 +458,20 @@ void vtlb_DynGenRead32_Const( u32 bits, bool sign, u32 addr_const )
 		{
 			case 8:
 				if( sign )
-					xMOVSX( eax, ptr8[(u8*)ppf] );
+					xMOVSX( eaxd, ptr8[(u8*)ppf] );
 				else
-					xMOVZX( eax, ptr8[(u8*)ppf] );
+					xMOVZX( eaxd, ptr8[(u8*)ppf] );
 			break;
 
 			case 16:
 				if( sign )
-					xMOVSX( eax, ptr16[(u16*)ppf] );
+					xMOVSX( eaxd, ptr16[(u16*)ppf] );
 				else
-					xMOVZX( eax, ptr16[(u16*)ppf] );
+					xMOVZX( eaxd, ptr16[(u16*)ppf] );
 			break;
 
 			case 32:
-				xMOV( eax, ptr32[(u32*)ppf] );
+				xMOV( eaxd, ptr32[(u32*)ppf] );
 			break;
 		}
 	}
@@ -489,7 +491,7 @@ void vtlb_DynGenRead32_Const( u32 bits, bool sign, u32 addr_const )
 		// Shortcut for the INTC_STAT register, which many games like to spin on heavily.
 		if( (bits == 32) && !EmuConfig.Speedhacks.IntcStat && (paddr == INTC_STAT) )
 		{
-			xMOV( eax, ptr[&psHu32( INTC_STAT )] );
+			xMOV( eaxd, ptr[&psHu32( INTC_STAT )] );
 		}
 		else
 		{
@@ -501,16 +503,16 @@ void vtlb_DynGenRead32_Const( u32 bits, bool sign, u32 addr_const )
 			if( bits==8 )
 			{
 				if( sign )
-					xMOVSX( eax, al );
+					xMOVSX( eaxd, al );
 				else
-					xMOVZX( eax, al );
+					xMOVZX( eaxd, al );
 			}
 			else if( bits==16 )
 			{
 				if( sign )
-					xMOVSX( eax, ax );
+					xMOVSX( eaxd, ax );
 				else
-					xMOVZX( eax, ax );
+					xMOVZX( eaxd, ax );
 			}
 		}
 	}
@@ -547,7 +549,7 @@ void vtlb_DynGenWrite_Const( u32 bits, u32 addr_const )
 		{
 			//8 , 16, 32 : data on arg2
 			case 8:
-				xMOV( edx, arg2regd );
+				xMOV( edxd, arg2regd );
 				xMOV( ptr[(void*)ppf], dl );
 			break;
 
@@ -594,14 +596,13 @@ void vtlb_DynGenWrite_Const( u32 bits, u32 addr_const )
 
 //   ecx - virtual address
 //   Returns physical address in eax.
-//   Clobbers edx
 void vtlb_DynV2P()
 {
-	xMOV(eax, ecx);
-	xAND(ecx, VTLB_PAGE_MASK); // vaddr & VTLB_PAGE_MASK
+	xMOV(eaxd, ecxd);
+	xAND(ecxd, VTLB_PAGE_MASK); // vaddr & VTLB_PAGE_MASK
 
-	xSHR(eax, VTLB_PAGE_BITS);
-	xMOV(eax, ptr[xComplexAddress(rdx, vtlbdata.ppmap, rax*4)]); //vtlbdata.ppmap[vaddr>>VTLB_PAGE_BITS];
+	xSHR(eaxd, VTLB_PAGE_BITS);
+	xMOV(eaxd, ptr[(eax*4) + vtlbdata.ppmap]); //vtlbdata.ppmap[vaddr>>VTLB_PAGE_BITS];
 
-	xOR(eax, ecx);
+	xOR(eaxd, ecxd);
 }
diff --git a/pcsx2/pcsx2/x86/microVU.cpp b/pcsx2/pcsx2/x86/microVU.cpp
index 23f39cf..4ac6fc2 100644
--- a/pcsx2/pcsx2/x86/microVU.cpp
+++ b/pcsx2/pcsx2/x86/microVU.cpp
@@ -36,10 +36,15 @@ void mVUreserveCache(microVU& mVU) {
 
 	mVU.cache_reserve = new RecompiledCodeReserve(pxsFmt("Micro VU%u Recompiler Cache", mVU.index), _16mb);
 	mVU.cache_reserve->SetProfilerName(pxsFmt("mVU%urec", mVU.index));
-	
+
+	uptr requestedSize = mVU.cacheSize * _1mb;
+	uptr actualSize = mVU.index ? sizeof(HostMemoryMap::mVU1rec) : sizeof(HostMemoryMap::mVU0rec);
+	pxAssert(requestedSize <= actualSize);
+	uptr sizeToUse = std::min(requestedSize, actualSize);
+
 	mVU.cache = mVU.index ?
-		(u8*)mVU.cache_reserve->Reserve(GetVmMemory().MainMemory(), HostMemoryMap::mVU1recOffset, mVU.cacheSize * _1mb):
-		(u8*)mVU.cache_reserve->Reserve(GetVmMemory().MainMemory(), HostMemoryMap::mVU0recOffset, mVU.cacheSize * _1mb);
+		(u8*)mVU.cache_reserve->Assign((void*)HostMemoryMap::mVU1rec, sizeToUse):
+		(u8*)mVU.cache_reserve->Assign((void*)HostMemoryMap::mVU0rec, sizeToUse);
 
 	mVU.cache_reserve->ThrowIfNotOk();
 }
diff --git a/pcsx2/pcsx2/x86/microVU_Alloc.inl b/pcsx2/pcsx2/x86/microVU_Alloc.inl
index 2c8a9d7..4d10bcf 100644
--- a/pcsx2/pcsx2/x86/microVU_Alloc.inl
+++ b/pcsx2/pcsx2/x86/microVU_Alloc.inl
@@ -72,19 +72,19 @@ __ri void mVUallocSFLAGc(const x32& reg, const x32& regT, int fInstance)
 
 // Denormalizes Status Flag
 __ri void mVUallocSFLAGd(u32* memAddr) {
-	xMOV(edx, ptr32[memAddr]);
-	xMOV(eax, edx);
-	xSHR(eax, 3);
-	xAND(eax, 0x18);
-
-	xMOV(ecx, edx);
-	xSHL(ecx, 11);
-	xAND(ecx, 0x1800);
-	xOR (eax, ecx);
-
-	xSHL(edx, 14);
-	xAND(edx, 0x3cf0000);
-	xOR (eax, edx);
+	xMOV(edxd, ptr32[memAddr]);
+	xMOV(eaxd, edxd);
+	xSHR(eaxd, 3);
+	xAND(eaxd, 0x18);
+
+	xMOV(ecxd, edxd);
+	xSHL(ecxd, 11);
+	xAND(ecxd, 0x1800);
+	xOR (eaxd, ecxd);
+
+	xSHL(edxd, 14);
+	xAND(edxd, 0x3cf0000);
+	xOR (eaxd, edxd);
 }
 
 __fi void mVUallocMFLAGa(mV, const x32& reg, int fInstance)
diff --git a/pcsx2/pcsx2/x86/microVU_Macro.inl b/pcsx2/pcsx2/x86/microVU_Macro.inl
index c59bb48..3f08390 100644
--- a/pcsx2/pcsx2/x86/microVU_Macro.inl
+++ b/pcsx2/pcsx2/x86/microVU_Macro.inl
@@ -255,10 +255,10 @@ void COP2_Interlock(bool mBitSync) {
 }
 
 void TEST_FBRST_RESET(FnType_Void* resetFunct, int vuIndex) {
-	xTEST(eax, (vuIndex) ? 0x200 : 0x002);
+	xTEST(eaxd, (vuIndex) ? 0x200 : 0x002);
 	xForwardJZ8 skip;
 		xFastCall((void*)resetFunct);
-		xMOV(eax, ptr32[&cpuRegs.GPR.r[_Rt_].UL[0]]);
+		xMOV(eaxd, ptr32[&cpuRegs.GPR.r[_Rt_].UL[0]]);
 	skip.SetTarget();
 }
 
@@ -272,9 +272,9 @@ static void recCFC2() {
 
 	if (_Rd_ == REG_STATUS_FLAG) { // Normalize Status Flag
 		xMOV(gprF0, ptr32[&vu0Regs.VI[REG_STATUS_FLAG].UL]);
-		mVUallocSFLAGc(eax, gprF0, 0);
+		mVUallocSFLAGc(eaxd, gprF0, 0);
 	}
-	else xMOV(eax, ptr32[&vu0Regs.VI[_Rd_].UL]);
+	else xMOV(eaxd, ptr32[&vu0Regs.VI[_Rd_].UL]);
 
 	if (_Rd_ == REG_TPC) { // Divide TPC register value by 8 during copying
 		// Ok, this deserves an explanation.
@@ -314,11 +314,11 @@ static void recCFC2() {
 	}
 
 	// FixMe: Should R-Reg have upper 9 bits 0?
-	xMOV(ptr32[&cpuRegs.GPR.r[_Rt_].UL[0]], eax);
+	xMOV(ptr32[&cpuRegs.GPR.r[_Rt_].UL[0]], eaxd);
 
 	if (_Rd_ >= 16) {
 		xCDQ(); // Sign Extend
-		xMOV(ptr32[&cpuRegs.GPR.r[_Rt_].UL[1]], edx);
+		xMOV(ptr32[&cpuRegs.GPR.r[_Rt_].UL[1]], edxd);
 	}
 	else xMOV(ptr32[&cpuRegs.GPR.r[_Rt_].UL[1]], 0);
 
@@ -337,23 +337,23 @@ static void recCTC2() {
 		case REG_MAC_FLAG: case REG_TPC:
 		case REG_VPU_STAT: break; // Read Only Regs
 		case REG_R:
-			xMOV(eax, ptr32[&cpuRegs.GPR.r[_Rt_].UL[0]]);
-			xOR (eax, 0x3f800000);
-			xMOV(ptr32[&vu0Regs.VI[REG_R].UL], eax);
+			xMOV(eaxd, ptr32[&cpuRegs.GPR.r[_Rt_].UL[0]]);
+			xOR (eaxd, 0x3f800000);
+			xMOV(ptr32[&vu0Regs.VI[REG_R].UL], eaxd);
 			break;
 		case REG_STATUS_FLAG:
 			if (_Rt_) { // Denormalizes flag into eax (gprT1)
 				mVUallocSFLAGd(&cpuRegs.GPR.r[_Rt_].UL[0]);
-				xMOV(ptr32[&vu0Regs.VI[_Rd_].UL], eax);
+				xMOV(ptr32[&vu0Regs.VI[_Rd_].UL], eaxd);
 			}
 			else xMOV(ptr32[&vu0Regs.VI[_Rd_].UL], 0);
 			break;
 		case REG_CMSAR1:	// Execute VU1 Micro SubRoutine
 			if (_Rt_) {
-				xMOV(ecx, ptr32[&cpuRegs.GPR.r[_Rt_].UL[0]]);
+				xMOV(ecxd, ptr32[&cpuRegs.GPR.r[_Rt_].UL[0]]);
 			}
-			else xXOR(ecx, ecx);
-			xFastCall((void*)vu1ExecMicro, ecx);
+			else xXOR(ecxd, ecxd);
+			xFastCall((void*)vu1ExecMicro, ecxd);
 			xFastCall((void*)vif1VUFinish);
 			break;
 		case REG_FBRST:
@@ -361,13 +361,13 @@ static void recCTC2() {
 				xMOV(ptr32[&vu0Regs.VI[REG_FBRST].UL], 0); 
 				return;
 			}
-			else xMOV(eax, ptr32[&cpuRegs.GPR.r[_Rt_].UL[0]]);
+			else xMOV(eaxd, ptr32[&cpuRegs.GPR.r[_Rt_].UL[0]]);
 
 			TEST_FBRST_RESET(vu0ResetRegs, 0);
 			TEST_FBRST_RESET(vu1ResetRegs, 1);
 
-			xAND(eax, 0x0C0C);
-			xMOV(ptr32[&vu0Regs.VI[REG_FBRST].UL], eax);
+			xAND(eaxd, 0x0C0C);
+			xMOV(ptr32[&vu0Regs.VI[REG_FBRST].UL], eaxd);
 			break;
 		default:
 			// Executing vu0 block here fixes the intro of Ratchet and Clank
diff --git a/pcsx2/pcsx2/x86/microVU_Misc.h b/pcsx2/pcsx2/x86/microVU_Misc.h
index 8297241..91ce5da 100644
--- a/pcsx2/pcsx2/x86/microVU_Misc.h
+++ b/pcsx2/pcsx2/x86/microVU_Misc.h
@@ -142,9 +142,9 @@ static const char branchSTR[16][8] = {
 #define xmmT7  xmm6 // Used for regAlloc
 #define xmmPQ  xmm7 // Holds the Value and Backup Values of P and Q regs
 
-#define gprT1  eax // eax - Temp Reg
-#define gprT2  ecx // ecx - Temp Reg
-#define gprT3  edx // edx - Temp Reg
+#define gprT1 eaxd // eax - Temp Reg
+#define gprT2 ecxd // ecx - Temp Reg
+#define gprT3 edxd // edx - Temp Reg
 #define gprT1q rax // eax - Temp Reg
 #define gprT2q rcx // ecx - Temp Reg
 #define gprT3q rdx // edx - Temp Reg
@@ -153,15 +153,15 @@ static const char branchSTR[16][8] = {
 #define gprT3b dx  // Low 16-bit of gprT3 (edx)
 
 #ifdef __M_X86_64
-#define gprF0  ebx // Status Flag 0
-#define gprF1 r12d // Status Flag 1
-#define gprF2 r13d // Status Flag 2
-#define gprF3 r14d // Status Flag 3
+#define gprF0  ebxd // Status Flag 0
+#define gprF1  r12d // Status Flag 1
+#define gprF2  r13d // Status Flag 2
+#define gprF3  r14d // Status Flag 3
 #else
-#define gprF0  ebx // Status Flag 0
-#define gprF1  ebp // Status Flag 1
-#define gprF2  esi // Status Flag 2
-#define gprF3  edi // Status Flag 3
+#define gprF0  ebxd // Status Flag 0
+#define gprF1  ebpd // Status Flag 1
+#define gprF2  esid // Status Flag 2
+#define gprF3  edid // Status Flag 3
 #endif
 
 // Function Params
diff --git a/pcsx2/pcsx2/x86/microVU_Misc.inl b/pcsx2/pcsx2/x86/microVU_Misc.inl
index 98a9451..ffcd1c1 100644
--- a/pcsx2/pcsx2/x86/microVU_Misc.inl
+++ b/pcsx2/pcsx2/x86/microVU_Misc.inl
@@ -405,18 +405,18 @@ void ADD_SS_Single_Guard_Bit(microVU& mVU, const xmm& to, const xmm& from, const
 {
 	const xmm& t1 = t1in.IsEmpty() ? mVU.regAlloc->allocReg() : t1in;
 
-	xMOVD(eax, to);
-	xMOVD(ecx, from);
-	xSHR (eax, 23);
-	xSHR (ecx, 23);
-	xAND (eax, 0xff);
-	xAND (ecx, 0xff);
-	xSUB (ecx, eax); // Exponent Difference
+	xMOVD(eaxd, to);
+	xMOVD(ecxd, from);
+	xSHR (eaxd, 23);
+	xSHR (ecxd, 23);
+	xAND (eaxd, 0xff);
+	xAND (ecxd, 0xff);
+	xSUB (ecxd, eaxd); // Exponent Difference
 
 	xForwardJL8 case_neg;
 	xForwardJE8 case_end1;
 
-	xCMP (ecx, 24);
+	xCMP (ecxd, 24);
 	xForwardJLE8 case_pos_small;
 
 	// case_pos_big:
@@ -424,15 +424,15 @@ void ADD_SS_Single_Guard_Bit(microVU& mVU, const xmm& to, const xmm& from, const
 	xForwardJump8 case_end2;
 
 	case_pos_small.SetTarget();
-	xDEC   (ecx);
-	xMOV   (eax, 0xffffffff);
-	xSHL   (eax, cl);
-	xMOVDZX(t1, eax);
+	xDEC   (ecxd);
+	xMOV   (eaxd, 0xffffffff);
+	xSHL   (eaxd, cl);
+	xMOVDZX(t1, eaxd);
 	xPAND  (to, t1);
 	xForwardJump8 case_end3;
 
 	case_neg.SetTarget();
-	xCMP (ecx, -24);
+	xCMP (ecxd, -24);
 	xForwardJGE8 case_neg_small;
 
 	// case_neg_big:
@@ -440,10 +440,10 @@ void ADD_SS_Single_Guard_Bit(microVU& mVU, const xmm& to, const xmm& from, const
 	xForwardJump8 case_end4;
 
 	case_neg_small.SetTarget();
-	xNOT   (ecx); // -ecx - 1
-	xMOV   (eax, 0xffffffff);
-	xSHL   (eax, cl);
-	xMOVDZX(t1, eax);
+	xNOT   (ecxd); // -ecx - 1
+	xMOV   (eaxd, 0xffffffff);
+	xSHL   (eaxd, cl);
+	xMOVDZX(t1, eaxd);
 	xPAND  (from, t1);
 
 	case_end1.SetTarget();
@@ -459,17 +459,17 @@ void ADD_SS_Single_Guard_Bit(microVU& mVU, const xmm& to, const xmm& from, const
 // Modifies from's lower vector
 void ADD_SS_TriAceHack(microVU& mVU, const xmm& to, const xmm& from)
 {
-	xMOVD(eax, to);
-	xMOVD(ecx, from);
-	xSHR (eax, 23);
-	xSHR (ecx, 23);
-	xAND (eax, 0xff);
-	xAND (ecx, 0xff);
-	xSUB (ecx, eax); // Exponent Difference
-
-	xCMP (ecx, -25);
+	xMOVD(eaxd, to);
+	xMOVD(ecxd, from);
+	xSHR (eaxd, 23);
+	xSHR (ecxd, 23);
+	xAND (eaxd, 0xff);
+	xAND (ecxd, 0xff);
+	xSUB (ecxd, eaxd); // Exponent Difference
+
+	xCMP (ecxd, -25);
 	xForwardJLE8 case_neg_big;
-	xCMP (ecx,  25);
+	xCMP (ecxd,  25);
 	xForwardJL8  case_end1;
 
 	// case_pos_big:
@@ -575,8 +575,8 @@ void mVUcustomSearch() {
 	xPCMP.EQD(xmm1, ptr32[arg2reg + 0x10]);
 	xPAND	 (xmm0, xmm1);
 
-	xMOVMSKPS(eax, xmm0);
-	xCMP	 (eax, 0xf);
+	xMOVMSKPS(eaxd, xmm0);
+	xCMP	 (eaxd, 0xf);
 	xForwardJL8 exitPoint;
 
 	xMOVAPS  (xmm0, ptr32[arg1reg + 0x20]);
@@ -606,7 +606,7 @@ void mVUcustomSearch() {
 	xPAND (xmm0, xmm2);
 	xPAND (xmm4, xmm6);
 	xPAND (xmm0, xmm4);
-	xMOVMSKPS(eax, xmm0);
+	xMOVMSKPS(eaxd, xmm0);
 
 	exitPoint.SetTarget();
 	xRET();
diff --git a/pcsx2/pcsx2/x86/newVif_Dynarec.cpp b/pcsx2/pcsx2/x86/newVif_Dynarec.cpp
index f442065..471ca93 100644
--- a/pcsx2/pcsx2/x86/newVif_Dynarec.cpp
+++ b/pcsx2/pcsx2/x86/newVif_Dynarec.cpp
@@ -34,8 +34,9 @@ void dVifReserve(int idx) {
 	if(!nVif[idx].recReserve)
 		nVif[idx].recReserve = new RecompiledCodeReserve(pxsFmt(L"VIF%u Unpack Recompiler Cache", idx), _8mb);
 
-	auto offset = idx ? HostMemoryMap::VIF1recOffset : HostMemoryMap::VIF0recOffset;
-	nVif[idx].recReserve->Reserve(GetVmMemory().MainMemory(), offset, 8 * _1mb);
+	auto offset = idx ? HostMemoryMap::VIF1rec : HostMemoryMap::VIF0rec;
+	auto size = idx ? sizeof(HostMemoryMap::VIF1rec) : sizeof(HostMemoryMap::VIF0rec);
+	nVif[idx].recReserve->Assign((void*)offset, size);
 }
 
 void dVifReset(int idx) {
diff --git a/pcsx2/pcsx2/x86/newVif_UnpackSSE.cpp b/pcsx2/pcsx2/x86/newVif_UnpackSSE.cpp
index 9aa1faa..23c8d51 100644
--- a/pcsx2/pcsx2/x86/newVif_UnpackSSE.cpp
+++ b/pcsx2/pcsx2/x86/newVif_UnpackSSE.cpp
@@ -33,6 +33,11 @@ static const __aligned16 u32 SSEXYZWMask[4][4] =
 //static __pagealigned u8 nVifUpkExec[__pagesize*4];
 static RecompiledCodeReserve* nVifUpkExec = NULL;
 
+void initNewVif_unpack()
+{
+    nVifUpkExec = NULL;
+}
+
 // Merges xmm vectors without modifying source reg
 void mergeVectors(xRegisterSSE dest, xRegisterSSE src, xRegisterSSE temp, int xyzw) {
 	if (x86caps.hasStreamingSIMD4Extensions  || (xyzw==15)
diff --git a/pcsx2/plugins/GSdx/GS.cpp b/pcsx2/plugins/GSdx/GS.cpp
index 8c6387a..5f73093 100644
--- a/pcsx2/plugins/GSdx/GS.cpp
+++ b/pcsx2/plugins/GSdx/GS.cpp
@@ -66,17 +66,17 @@ static const char *s_renderer_name = "";
 static const char *s_renderer_type = "";
 bool gsopen_done = false; // crash guard for GSgetTitleInfo2 and GSKeyEvent (replace with lock?)
 
-EXPORT_C_(uint32) PS2EgetLibType()
+uint32 PS2EgetLibType()
 {
 	return PS2E_LT_GS;
 }
 
-EXPORT_C_(const char*) PS2EgetLibName()
+const char* PS2EgetLibName()
 {
 	return GSUtil::GetLibName();
 }
 
-EXPORT_C_(uint32) PS2EgetLibVersion2(uint32 type)
+uint32 PS2EgetLibVersion2(uint32 type)
 {
 	const uint32 revision = 1;
 	const uint32 build = 2;
@@ -84,7 +84,7 @@ EXPORT_C_(uint32) PS2EgetLibVersion2(uint32 type)
 	return (build << 0) | (revision << 8) | (PS2E_GS_VERSION << 16) | (PLUGIN_VERSION << 24);
 }
 
-EXPORT_C_(uint32) PS2EgetCpuPlatform()
+uint32 PS2EgetCpuPlatform()
 {
 #ifdef _M_AMD64
 
@@ -97,7 +97,7 @@ EXPORT_C_(uint32) PS2EgetCpuPlatform()
 #endif
 }
 
-EXPORT_C GSsetBaseMem(uint8* mem)
+void GSsetBaseMem(uint8* mem)
 {
 	s_basemem = mem;
 
@@ -107,12 +107,12 @@ EXPORT_C GSsetBaseMem(uint8* mem)
 	}
 }
 
-EXPORT_C GSsetSettingsDir(const char* dir)
+void GSsetSettingsDir(const char* dir)
 {
 	theApp.SetConfigDir(dir);
 }
 
-EXPORT_C_(int) GSinit()
+int GSinit()
 {
 	if(!GSUtil::CheckSSE())
 	{
@@ -160,7 +160,7 @@ EXPORT_C_(int) GSinit()
 	return 0;
 }
 
-EXPORT_C GSshutdown()
+void GSshutdown()
 {
 	gsopen_done = false;
 
@@ -183,7 +183,7 @@ EXPORT_C GSshutdown()
 #endif
 }
 
-EXPORT_C GSclose()
+void GSclose()
 {
 	gsopen_done = false;
 
@@ -463,17 +463,17 @@ static int _GSopen(void** dsp, const char* title, GSRendererType renderer, int t
 	return 0;
 }
 
-EXPORT_C_(void) GSosdLog(const char *utf8, uint32 color)
+void GSosdLog(const char *utf8, uint32 color)
 {
 	if(s_gs && s_gs->m_dev) s_gs->m_dev->m_osd.Log(utf8);
 }
 
-EXPORT_C_(void) GSosdMonitor(const char *key, const char *value, uint32 color)
+void GSosdMonitor(const char *key, const char *value, uint32 color)
 {
 	if(s_gs && s_gs->m_dev) s_gs->m_dev->m_osd.Monitor(key, value);
 }
 
-EXPORT_C_(int) GSopen2(void** dsp, uint32 flags)
+int GSopen2(void** dsp, uint32 flags)
 {
 	static bool stored_toggle_state = false;
 	bool toggle_state = !!(flags & 4);
@@ -514,7 +514,7 @@ EXPORT_C_(int) GSopen2(void** dsp, uint32 flags)
 	return retval;
 }
 
-EXPORT_C_(int) GSopen(void** dsp, const char* title, int mt)
+int GSopen(void** dsp, const char* title, int mt)
 {
 	/*
 	if(!XInitThreads()) return -1;
@@ -563,7 +563,7 @@ EXPORT_C_(int) GSopen(void** dsp, const char* title, int mt)
 	return retval;
 }
 
-EXPORT_C GSreset()
+void GSreset()
 {
 	try
 	{
@@ -574,7 +574,7 @@ EXPORT_C GSreset()
 	}
 }
 
-EXPORT_C GSgifSoftReset(uint32 mask)
+void GSgifSoftReset(uint32 mask)
 {
 	try
 	{
@@ -585,7 +585,7 @@ EXPORT_C GSgifSoftReset(uint32 mask)
 	}
 }
 
-EXPORT_C GSwriteCSR(uint32 csr)
+void GSwriteCSR(uint32 csr)
 {
 	try
 	{
@@ -596,7 +596,7 @@ EXPORT_C GSwriteCSR(uint32 csr)
 	}
 }
 
-EXPORT_C GSinitReadFIFO(uint8* mem)
+void GSinitReadFIFO(uint8* mem)
 {
 	GL_PERF("Init Read FIFO1");
 	try
@@ -612,7 +612,7 @@ EXPORT_C GSinitReadFIFO(uint8* mem)
 	}
 }
 
-EXPORT_C GSreadFIFO(uint8* mem)
+void GSreadFIFO(uint8* mem)
 {
 	try
 	{
@@ -627,7 +627,7 @@ EXPORT_C GSreadFIFO(uint8* mem)
 	}
 }
 
-EXPORT_C GSinitReadFIFO2(uint8* mem, uint32 size)
+void GSinitReadFIFO2(uint8* mem, uint32 size)
 {
 	GL_PERF("Init Read FIFO2");
 	try
@@ -643,7 +643,7 @@ EXPORT_C GSinitReadFIFO2(uint8* mem, uint32 size)
 	}
 }
 
-EXPORT_C GSreadFIFO2(uint8* mem, uint32 size)
+void GSreadFIFO2(uint8* mem, uint32 size)
 {
 	try
 	{
@@ -658,7 +658,7 @@ EXPORT_C GSreadFIFO2(uint8* mem, uint32 size)
 	}
 }
 
-EXPORT_C GSgifTransfer(const uint8* mem, uint32 size)
+void GSgifTransfer(const uint8* mem, uint32 size)
 {
 	try
 	{
@@ -669,7 +669,7 @@ EXPORT_C GSgifTransfer(const uint8* mem, uint32 size)
 	}
 }
 
-EXPORT_C GSgifTransfer1(uint8* mem, uint32 addr)
+void GSgifTransfer1(uint8* mem, uint32 addr)
 {
 	try
 	{
@@ -680,7 +680,7 @@ EXPORT_C GSgifTransfer1(uint8* mem, uint32 addr)
 	}
 }
 
-EXPORT_C GSgifTransfer2(uint8* mem, uint32 size)
+void GSgifTransfer2(uint8* mem, uint32 size)
 {
 	try
 	{
@@ -691,7 +691,7 @@ EXPORT_C GSgifTransfer2(uint8* mem, uint32 size)
 	}
 }
 
-EXPORT_C GSgifTransfer3(uint8* mem, uint32 size)
+void GSgifTransfer3(uint8* mem, uint32 size)
 {
 	try
 	{
@@ -702,7 +702,7 @@ EXPORT_C GSgifTransfer3(uint8* mem, uint32 size)
 	}
 }
 
-EXPORT_C GSvsync(int field)
+void GSvsync(int field)
 {
 	try
 	{
@@ -734,7 +734,7 @@ EXPORT_C GSvsync(int field)
 	}
 }
 
-EXPORT_C_(uint32) GSmakeSnapshot(char* path)
+uint32 GSmakeSnapshot(char* path)
 {
 	try
 	{
@@ -753,7 +753,7 @@ EXPORT_C_(uint32) GSmakeSnapshot(char* path)
 	}
 }
 
-EXPORT_C GSkeyEvent(GSKeyEventData* e)
+void GSkeyEvent(GSKeyEventData* e)
 {
 	try
 	{
@@ -767,7 +767,7 @@ EXPORT_C GSkeyEvent(GSKeyEventData* e)
 	}
 }
 
-EXPORT_C_(int) GSfreeze(int mode, GSFreezeData* data)
+int GSfreeze(int mode, GSFreezeData* data)
 {
 	try
 	{
@@ -791,7 +791,7 @@ EXPORT_C_(int) GSfreeze(int mode, GSFreezeData* data)
 	return 0;
 }
 
-EXPORT_C GSconfigure()
+void GSconfigure()
 {
 	try
 	{
@@ -822,7 +822,7 @@ EXPORT_C GSconfigure()
 	}
 }
 
-EXPORT_C_(int) GStest()
+int GStest()
 {
 	if(!GSUtil::CheckSSE())
 	{
@@ -857,11 +857,11 @@ EXPORT_C_(int) GStest()
 	return 0;
 }
 
-EXPORT_C GSabout()
+void GSabout()
 {
 }
 
-EXPORT_C GSirqCallback(void (*irq)())
+void GSirqCallback(void (*irq)())
 {
 	s_irq = irq;
 
@@ -881,7 +881,7 @@ void pt(const char* str){
 	printf("%02i:%02i:%02i%s", current->tm_hour, current->tm_min, current->tm_sec, str);
 }
 
-EXPORT_C_(int) GSsetupRecording(int start, void* data)
+int GSsetupRecording(int start, void* data)
 {
 	if (s_gs == NULL) {
 		printf("GSdx: no s_gs for recording\n");
@@ -914,17 +914,17 @@ EXPORT_C_(int) GSsetupRecording(int start, void* data)
 	return 1;
 }
 
-EXPORT_C GSsetGameCRC(uint32 crc, int options)
+void GSsetGameCRC(uint32 crc, int options)
 {
 	s_gs->SetGameCRC(crc, options);
 }
 
-EXPORT_C GSgetLastTag(uint32* tag)
+void GSgetLastTag(uint32* tag)
 {
 	s_gs->GetLastTag(tag);
 }
 
-EXPORT_C GSgetTitleInfo2(char* dest, size_t length)
+void GSgetTitleInfo2(char* dest, size_t length)
 {
 	std::string s{"GSdx"};
 	s.append(s_renderer_name).append(s_renderer_type);
@@ -945,12 +945,12 @@ EXPORT_C GSgetTitleInfo2(char* dest, size_t length)
 	strcpy(dest, s.c_str());
 }
 
-EXPORT_C GSsetFrameSkip(int frameskip)
+void GSsetFrameSkip(int frameskip)
 {
 	s_gs->SetFrameSkip(frameskip);
 }
 
-EXPORT_C GSsetVsync(int vsync)
+void GSsetVsync(int vsync)
 {
 	s_vsync = vsync;
 
@@ -960,7 +960,7 @@ EXPORT_C GSsetVsync(int vsync)
 	}
 }
 
-EXPORT_C GSsetExclusive(int enabled)
+void GSsetExclusive(int enabled)
 {
 	s_exclusive = !!enabled;
 
@@ -1045,7 +1045,7 @@ public:
 //   First parameter is the renderer.
 //   Second parameter is the gs file to load and run.
 
-EXPORT_C GSReplay(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow)
+void GSReplay(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow)
 {
 	GSRendererType renderer = GSRendererType::Undefined;
 
@@ -1179,7 +1179,7 @@ EXPORT_C GSReplay(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow)
 	GSshutdown();
 }
 
-EXPORT_C GSBenchmark(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow)
+void GSBenchmark(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow)
 {
 	::SetPriorityClass(::GetCurrentProcess(), HIGH_PRIORITY_CLASS);
 
@@ -1394,7 +1394,7 @@ inline unsigned long timeGetTime()
 }
 
 // Note
-EXPORT_C GSReplay(char* lpszCmdLine, int renderer)
+void GSReplay(char* lpszCmdLine, int renderer)
 {
 	GLLoader::in_replayer = true;
 	// Required by multithread driver
diff --git a/pcsx2/plugins/GSdx/GS.h b/pcsx2/plugins/GSdx/GS.h
index ecb66fa..751c464 100644
--- a/pcsx2/plugins/GSdx/GS.h
+++ b/pcsx2/plugins/GSdx/GS.h
@@ -244,7 +244,7 @@ enum class GSRendererType : int8_t
 #else
 	// Use ogl renderer as default otherwise it crash at startup
 	// GSRenderOGL only GSDeviceOGL (not GSDeviceNULL)
-	Default = OGL_HW
+	Default = OGL_SW
 #endif
 
 };
diff --git a/pcsx2/plugins/GSdx/GSdx.cpp b/pcsx2/plugins/GSdx/GSdx.cpp
index 700330f..76127d7 100644
--- a/pcsx2/plugins/GSdx/GSdx.cpp
+++ b/pcsx2/plugins/GSdx/GSdx.cpp
@@ -94,6 +94,9 @@ bool GSdxApp::LoadResource(int id, std::vector<char>& buff, const char* type)
 		case IDR_TFX_CL:
 			path = "/GSdx/res/tfx.cl";
 			break;
+		case IDR_FONT_FREESERIF:
+			path = "/GSdx/res/freefont/FreeSerif.otf";
+			break;
 		default:
 			printf("LoadResource not implemented for id %d\n", id);
 			return false;
@@ -361,7 +364,11 @@ void GSdxApp::Init()
 #ifdef _WIN32
 	m_default_configuration["osd_fontname"]                               = "C:\\Windows\\Fonts\\tahoma.ttf";
 #else
+  #ifdef _ARCH_64
+    m_default_configuration["osd_fontname"]                               = "/usr/share/fonts/gnu-free/FreeSerif.otf";
+  #else
 	m_default_configuration["osd_fontname"]                               = "/usr/share/fonts/truetype/freefont/FreeSerif.ttf";
+  #endif
 #endif
 	m_default_configuration["osd_color_r"]                                = "0";
 	m_default_configuration["osd_color_g"]                                = "160";
diff --git a/pcsx2/plugins/GSdx/GSdx.rc b/pcsx2/plugins/GSdx/GSdx.rc
index acb1c54..d0ed32e 100644
--- a/pcsx2/plugins/GSdx/GSdx.rc
+++ b/pcsx2/plugins/GSdx/GSdx.rc
@@ -94,6 +94,8 @@ IDR_TFX_VGS_GLSL        RCDATA                  "res\\glsl\\tfx_vgs.glsl";
 
 IDR_TFX_FS_GLSL         RCDATA                  "res\\glsl\\tfx_fs.glsl";
 
+IDR_FONT_FREESERIF      RCDATA                  "res\\freefont\\FreeSerif.otf";
+
 /////////////////////////////////////////////////////////////////////////////
 //
 // Bitmap
diff --git a/pcsx2/plugins/GSdx/Renderers/Common/GSOsdManager.cpp b/pcsx2/plugins/GSdx/Renderers/Common/GSOsdManager.cpp
index 2ce09a7..1e2ba46 100644
--- a/pcsx2/plugins/GSdx/Renderers/Common/GSOsdManager.cpp
+++ b/pcsx2/plugins/GSdx/Renderers/Common/GSOsdManager.cpp
@@ -22,16 +22,25 @@
 #include "stdafx.h"
 #include "GSdx.h"
 #include "GSOsdManager.h"
+#ifdef _WIN32
+  #include "resource.h"
+#endif
 
+std::vector<char> buff;
 void GSOsdManager::LoadFont() {
 	FT_Error error = FT_New_Face(m_library, theApp.GetConfigS("osd_fontname").c_str(), 0, &m_face);
 	if (error) {
-		m_face = NULL;
-		fprintf(stderr, "Failed to init the freetype face\n");
-		if(error == FT_Err_Unknown_File_Format)
-			fprintf(stderr, "\tFreetype unknown file format\n");
-
-		return;
+		FT_Error error_load_res = 1;
+		if(theApp.LoadResource(IDR_FONT_FREESERIF, buff))
+			error_load_res = FT_New_Memory_Face(m_library, (const FT_Byte*)buff.data(), buff.size(), 0, &m_face);
+		
+		if (error_load_res) {
+			m_face = NULL;
+			fprintf(stderr, "Failed to init freetype face from external and internal resource\n");
+			if(error == FT_Err_Unknown_File_Format)
+				fprintf(stderr, "\tFreetype unknown file format for external file\n");
+			return;
+		}
 	}
 
 	LoadSize();
diff --git a/pcsx2/plugins/GSdx/Renderers/Common/GSRenderer.cpp b/pcsx2/plugins/GSdx/Renderers/Common/GSRenderer.cpp
index e2881bb..63412b9 100644
--- a/pcsx2/plugins/GSdx/Renderers/Common/GSRenderer.cpp
+++ b/pcsx2/plugins/GSdx/Renderers/Common/GSRenderer.cpp
@@ -567,9 +567,9 @@ void GSRenderer::KeyEvent(GSKeyEventData* e)
 		int step = m_shift_key ? -1 : 1;
 
 #if defined(__unix__)
-#define VK_F5 XK_F5
+#define VK_F1 XK_F1
 #define VK_F6 XK_F6
-#define VK_F7 XK_F7
+#define VK_F3 XK_F3
 #define VK_DELETE XK_Delete
 #define VK_INSERT XK_Insert
 #define VK_PRIOR XK_Prior
@@ -579,7 +579,7 @@ void GSRenderer::KeyEvent(GSKeyEventData* e)
 
 		switch(e->key)
 		{
-		case VK_F5:
+		case VK_F1:
 			m_interlace = (m_interlace + s_interlace_nb + step) % s_interlace_nb;
 			theApp.SetConfig("interlace", m_interlace);
 			printf("GSdx: Set deinterlace mode to %d (%s).\n", m_interlace, theApp.m_gs_interlace.at(m_interlace).name.c_str());
@@ -588,7 +588,7 @@ void GSRenderer::KeyEvent(GSKeyEventData* e)
 			if( m_wnd->IsManaged() )
 				m_aspectratio = (m_aspectratio + s_aspect_ratio_nb + step) % s_aspect_ratio_nb;
 			return;
-		case VK_F7:
+		case VK_F3:
 			m_shader = (m_shader + s_post_shader_nb + step) % s_post_shader_nb;
 			theApp.SetConfig("TVShader", m_shader);
 			printf("GSdx: Set shader to: %d.\n", m_shader);
diff --git a/pcsx2/plugins/GSdx/Window/GSSetting.h b/pcsx2/plugins/GSdx/Window/GSSetting.h
index 582464f..e21c983 100644
--- a/pcsx2/plugins/GSdx/Window/GSSetting.h
+++ b/pcsx2/plugins/GSdx/Window/GSSetting.h
@@ -98,5 +98,7 @@ enum {
 	IDR_TFX_VGS_GLSL,
 	IDR_TFX_FS_GLSL,
 	IDR_TFX_CL,
+	// fonts
+	IDR_FONT_FREESERIF,
 };
 #endif
diff --git a/pcsx2/plugins/GSdx/Window/GSWndOGL.cpp b/pcsx2/plugins/GSdx/Window/GSWndOGL.cpp
index 39d408e..d19ef8b 100644
--- a/pcsx2/plugins/GSdx/Window/GSWndOGL.cpp
+++ b/pcsx2/plugins/GSdx/Window/GSWndOGL.cpp
@@ -22,6 +22,10 @@
 #include "stdafx.h"
 #include "GSWndOGL.h"
 
+#include <SDL.h>
+#include <SDL_opengl.h>
+#include <SDL_syswm.h>
+
 #if defined(__unix__)
 GSWndOGL::GSWndOGL()
 	: m_NativeWindow(0), m_NativeDisplay(nullptr), m_context(0), m_has_late_vsync(false), m_swapinterval_ext(nullptr), m_swapinterval_mesa(nullptr)
@@ -34,7 +38,11 @@ static int  ctxErrorHandler(Display *dpy, XErrorEvent *ev)
 	ctxError = true;
 	return 0;
 }
-
+extern SDL_Window* gWindow;
+namespace GLLoader {
+	void check_gl_version(int major,int minor);
+}
+SDL_GLContext SDLcontext;
 void GSWndOGL::CreateContext(int major, int minor)
 {
 	if ( !m_NativeDisplay || !m_NativeWindow )
@@ -42,63 +50,18 @@ void GSWndOGL::CreateContext(int major, int minor)
 		fprintf( stderr, "Wrong X11 display/window\n" );
 		throw GSDXRecoverableError();
 	}
+    
+    SDL_GLContext SDLcontext = SDL_GL_CreateContext(gWindow);
+    #define immediate_updates 0
+    #define updates_synchronized 1
+    SDL_GL_SetSwapInterval(updates_synchronized);
 
-	// Get visual information
-	static int attrListDbl[] =
-	{
-		// GLX_X_RENDERABLE: If True is specified, then only frame buffer configurations that have associated X
-		// visuals (and can be used to render to Windows and/or GLX pixmaps) will be considered. The default value is GLX_DONT_CARE.
-		GLX_X_RENDERABLE    , True,
-		GLX_RED_SIZE        , 8,
-		GLX_GREEN_SIZE      , 8,
-		GLX_BLUE_SIZE       , 8,
-		GLX_DEPTH_SIZE      , 0,
-		GLX_DOUBLEBUFFER    , True,
-		None
-	};
-
-	PFNGLXCHOOSEFBCONFIGPROC glX_ChooseFBConfig = (PFNGLXCHOOSEFBCONFIGPROC) glXGetProcAddress((GLubyte *) "glXChooseFBConfig");
-	int fbcount = 0;
-	GLXFBConfig *fbc = glX_ChooseFBConfig(m_NativeDisplay, DefaultScreen(m_NativeDisplay), attrListDbl, &fbcount);
-	if (!fbc || fbcount < 1) {
-		throw GSDXRecoverableError();
-	}
-
-	PFNGLXCREATECONTEXTATTRIBSARBPROC glX_CreateContextAttribsARB = (PFNGLXCREATECONTEXTATTRIBSARBPROC)glXGetProcAddress((const GLubyte*) "glXCreateContextAttribsARB");
-	if (!glX_CreateContextAttribsARB) {
-		throw GSDXRecoverableError();
-	}
-
-	// Install a dummy handler to handle gracefully (aka not segfault) the support of GL version
-	int (*oldHandler)(Display*, XErrorEvent*) = XSetErrorHandler(&ctxErrorHandler);
-	// Be sure the handler is installed
-	XSync( m_NativeDisplay, false);
-
-	// Create a context
-	int context_attribs[] =
-	{
-		GLX_CONTEXT_MAJOR_VERSION_ARB, major,
-		GLX_CONTEXT_MINOR_VERSION_ARB, minor,
-#ifdef ENABLE_OGL_DEBUG
-		GLX_CONTEXT_FLAGS_ARB, GLX_CONTEXT_DEBUG_BIT_ARB,
-#else
-		// Open Source isn't happy with an unsupported flags...
-		//GLX_CONTEXT_FLAGS_ARB, GL_CONTEXT_FLAG_NO_ERROR_BIT_KHR,
-#endif
-		GLX_CONTEXT_PROFILE_MASK_ARB, GLX_CONTEXT_CORE_PROFILE_BIT_ARB,
-		None
-	};
-
-	m_context = glX_CreateContextAttribsARB(m_NativeDisplay, fbc[0], 0, true, context_attribs);
-	XFree(fbc);
-
-	// Don't forget to reinstall the older Handler
-	XSetErrorHandler(oldHandler);
+    m_context = glXGetCurrentContext();
 
 	// Get latest error
 	XSync( m_NativeDisplay, false);
 
-	if (!m_context || ctxError) {
+	if (!m_context) {
 		fprintf(stderr, "Failed to create the opengl context. Check your drivers support openGL %d.%d. Hint: opensource drivers don't\n", major, minor );
 		throw GSDXRecoverableError();
 	}
@@ -107,7 +70,6 @@ void GSWndOGL::CreateContext(int major, int minor)
 void GSWndOGL::AttachContext()
 {
 	if (!IsContextAttached()) {
-		//fprintf(stderr, "Attach the context\n");
 		glXMakeCurrent(m_NativeDisplay, m_NativeWindow, m_context);
 		m_ctx_attached = true;
 	}
@@ -116,8 +78,7 @@ void GSWndOGL::AttachContext()
 void GSWndOGL::DetachContext()
 {
 	if (IsContextAttached()) {
-		//fprintf(stderr, "Detach the context\n");
-		glXMakeCurrent(m_NativeDisplay, None, NULL);
+		//glXMakeCurrent(m_NativeDisplay, None, NULL);
 		m_ctx_attached = false;
 	}
 }
@@ -130,13 +91,13 @@ void GSWndOGL::PopulateWndGlFunction()
 	const char* ext = glXQueryExtensionsString(m_NativeDisplay, DefaultScreen(m_NativeDisplay));
 	m_has_late_vsync = m_swapinterval_ext && ext && strstr(ext, "GLX_EXT_swap_control");
 }
-
+extern Display* XDisplay;
 bool GSWndOGL::Attach(void* handle, bool managed)
 {
 	m_NativeWindow = *(Window*)handle;
 	m_managed = managed;
 
-	m_NativeDisplay = XOpenDisplay(NULL);
+	m_NativeDisplay = XDisplay;
 
 	FullContextInit();
 
@@ -146,14 +107,14 @@ bool GSWndOGL::Attach(void* handle, bool managed)
 void GSWndOGL::Detach()
 {
 	// Actually the destructor is not called when there is only a GSclose/GSshutdown
-	// The window still need to be closed
+	/*// The window still need to be closed
 	DetachContext();
 	if (m_context) glXDestroyContext(m_NativeDisplay, m_context);
 
 	if (m_NativeDisplay) {
 		XCloseDisplay(m_NativeDisplay);
 		m_NativeDisplay = NULL;
-	}
+	}*/
 }
 
 bool GSWndOGL::Create(const std::string& title, int w, int h)
@@ -200,7 +161,9 @@ void* GSWndOGL::GetDisplay()
 	// note this part must be only executed when replaying .gs debug file
 	return (void*)m_NativeDisplay;
 }
-
+extern SDL_Window* gWindow;
+extern Display* XDisplay;
+extern Window Xwindow;
 GSVector4i GSWndOGL::GetClientRect()
 {
 	unsigned int h = 480;
@@ -211,8 +174,7 @@ GSVector4i GSWndOGL::GetClientRect()
 	Window winDummy;
     int xDummy;
     int yDummy;
-
-	if (!m_NativeDisplay) m_NativeDisplay = XOpenDisplay(NULL);
+	
 	XGetGeometry(m_NativeDisplay, m_NativeWindow, &winDummy, &xDummy, &yDummy, &w, &h, &borderDummy, &depthDummy);
 
 	return GSVector4i(0, 0, (int)w, (int)h);
diff --git a/pcsx2/plugins/GSdx/config.h b/pcsx2/plugins/GSdx/config.h
index 877cd78..0f868f1 100644
--- a/pcsx2/plugins/GSdx/config.h
+++ b/pcsx2/plugins/GSdx/config.h
@@ -41,7 +41,7 @@
 
 
 #if !defined(NDEBUG) || defined(_DEBUG) || defined(_DEVEL)
-#define ENABLE_OGL_DEBUG   // Create a debug context and check opengl command status. Allow also to dump various textures/states.
+//#define ENABLE_OGL_DEBUG   // Create a debug context and check opengl command status. Allow also to dump various textures/states.
 //#define ENABLE_OGL_DEBUG_FENCE
 //#define ENABLE_OGL_DEBUG_MEM_BW // compute the quantity of data transfered (debug purpose)
 //#define ENABLE_TRACE_REG // print GS reg write
diff --git a/pcsx2/plugins/GSdx/res/gsdx-res.xml b/pcsx2/plugins/GSdx/res/gsdx-res.xml
index 5b8e663..6f73c86 100644
--- a/pcsx2/plugins/GSdx/res/gsdx-res.xml
+++ b/pcsx2/plugins/GSdx/res/gsdx-res.xml
@@ -30,4 +30,7 @@
     <gresource prefix="/GSdx/res/">
         <file>tfx.cl</file>
     </gresource>
+    <gresource prefix="/GSdx/res/">
+        <file>freefont/FreeSerif.otf</file>
+    </gresource>
 </gresources>
diff --git a/pcsx2/plugins/GSdx/resource.h b/pcsx2/plugins/GSdx/resource.h
index e96bf4a..5c1a9cb 100644
--- a/pcsx2/plugins/GSdx/resource.h
+++ b/pcsx2/plugins/GSdx/resource.h
@@ -156,13 +156,14 @@
 #define IDR_COMMON_GLSL                 10015
 #define IDR_TFX_VGS_GLSL                10016
 #define IDR_TFX_FS_GLSL                 10017
+#define IDR_FONT_FREESERIF              10018
 #define IDC_STATIC                      -1
 
 // Next default values for new objects
 // 
 #ifdef APSTUDIO_INVOKED
 #ifndef APSTUDIO_READONLY_SYMBOLS
-#define _APS_NEXT_RESOURCE_VALUE        10018
+#define _APS_NEXT_RESOURCE_VALUE        10019
 #define _APS_NEXT_COMMAND_VALUE         32771
 #define _APS_NEXT_CONTROL_VALUE         2194
 #define _APS_NEXT_SYMED_VALUE           5000
diff --git a/pcsx2/plugins/onepad/KeyStatus.cpp b/pcsx2/plugins/onepad/KeyStatus.cpp
index fa59fe4..d4d4f47 100644
--- a/pcsx2/plugins/onepad/KeyStatus.cpp
+++ b/pcsx2/plugins/onepad/KeyStatus.cpp
@@ -48,7 +48,8 @@ void KeyStatus::Init()
         m_internal_analog_joy[pad].ry = m_analog_released_val;
     }
 }
-
+void shutdownExternal();
+bool requestShutdown = false;
 void KeyStatus::press(u32 pad, u32 index, s32 value)
 {
     if (!IsAnalogKey(index)) {
@@ -57,6 +58,12 @@ void KeyStatus::press(u32 pad, u32 index, s32 value)
             clear_bit(m_internal_button_kbd[pad], index);
         else
             clear_bit(m_internal_button_joy[pad], index);
+            
+        if (index == PAD_GUIDE)
+        {
+            requestShutdown = true;
+        }
+            
     } else {
         // clamp value
         if (value > MAX_ANALOG_VALUE)
@@ -87,6 +94,10 @@ void KeyStatus::release(u32 pad, u32 index)
     } else {
         analog_set(pad, index, m_analog_released_val);
     }
+    if ((index == PAD_GUIDE) && requestShutdown)
+    {
+        shutdownExternal();
+    }
 }
 
 u16 KeyStatus::get(u32 pad)
diff --git a/pcsx2/plugins/onepad/SDL/joystick.cpp b/pcsx2/plugins/onepad/SDL/joystick.cpp
index 0204e9a..86b3c35 100644
--- a/pcsx2/plugins/onepad/SDL/joystick.cpp
+++ b/pcsx2/plugins/onepad/SDL/joystick.cpp
@@ -21,25 +21,25 @@
 
 #include "joystick.h"
 #include "resources.h"
+#include "../../../../include/controller.h"
 #include <signal.h> // sigaction
 
 //////////////////////////
 // Joystick definitions //
 //////////////////////////
 
-// opens handles to all possible joysticks
+// opens all joysticks
 void JoystickInfo::EnumerateJoysticks(std::vector<std::unique_ptr<GamePad>> &vjoysticks)
 {
     uint32_t flag = SDL_INIT_JOYSTICK | SDL_INIT_HAPTIC | SDL_INIT_EVENTS | SDL_INIT_GAMECONTROLLER;
 
     if ((SDL_WasInit(0) & flag) != flag) {
-        // Tell SDL to catch event even if the windows isn't focussed
+        // Tell SDL to catch event even if the window is not focussed
         SDL_SetHint(SDL_HINT_JOYSTICK_ALLOW_BACKGROUND_EVENTS, "1");
 
         if (SDL_Init(flag) < 0)
             return;
 
-        // WTF! Give me back the control of my system
         struct sigaction action = {};
         action.sa_handler = SIG_DFL;
         sigaction(SIGINT, &action, nullptr);
@@ -50,30 +50,22 @@ void JoystickInfo::EnumerateJoysticks(std::vector<std::unique_ptr<GamePad>> &vjo
         SDL_EventState(SDL_CONTROLLERDEVICEADDED, SDL_ENABLE);
         SDL_EventState(SDL_CONTROLLERDEVICEREMOVED, SDL_ENABLE);
 
-        { // Support as much Joystick as possible
-            GBytes *bytes = g_resource_lookup_data(onepad_res_get_resource(), "/onepad/res/game_controller_db.txt", G_RESOURCE_LOOKUP_FLAGS_NONE, nullptr);
-
-            size_t size = 0;
-            // SDL forget to add const for SDL_RWFromMem API...
-            void *data = const_cast<void *>(g_bytes_get_data(bytes, &size));
-
-            SDL_GameControllerAddMappingsFromRW(SDL_RWFromMem(data, size), 1);
-
-            g_bytes_unref(bytes);
-
-            // Add user mapping too
-            for (auto const &map : g_conf.sdl2_mapping)
-                SDL_GameControllerAddMapping(map.c_str());
-        }
     }
 
     vjoysticks.clear();
-
-    for (int i = 0; i < SDL_NumJoysticks(); ++i) {
-        vjoysticks.push_back(std::unique_ptr<GamePad>(new JoystickInfo(i)));
-        // Something goes wrong in the init, let's drop it
-        if (!vjoysticks.back()->IsProperlyInitialized())
-            vjoysticks.pop_back();
+    int slot = 0;
+    for (int i = 0; i < MAX_GAMEPADS; i++)
+    {
+        if (gDesignatedControllers[i].gameCtrl[0] != NULL)
+        {
+            vjoysticks.push_back(std::unique_ptr<GamePad>(new JoystickInfo(slot)));
+            // If something goes wrong in the init, let's drop it
+            if (!vjoysticks.back()->IsProperlyInitialized())
+            {
+                vjoysticks.pop_back();
+            }
+            slot++;
+        }
     }
 }
 
@@ -96,26 +88,9 @@ void JoystickInfo::Rumble(unsigned type, unsigned pad)
 
 JoystickInfo::~JoystickInfo()
 {
-    // Haptic must be closed before the joystick
-    if (m_haptic != nullptr) {
-        for (const auto &eid : m_effects_id) {
-            if (eid >= 0)
-                SDL_HapticDestroyEffect(m_haptic, eid);
-        }
-
-        SDL_HapticClose(m_haptic);
-    }
-
-    if (m_controller != nullptr) {
-#if SDL_MINOR_VERSION >= 4
-        // Version before 2.0.4 are bugged, JoystickClose crashes randomly
-        // Note: GameControllerClose calls JoystickClose)
-        SDL_GameControllerClose(m_controller);
-#endif
-    }
 }
 
-JoystickInfo::JoystickInfo(int id)
+JoystickInfo::JoystickInfo(int slot)
     : GamePad()
     , m_controller(nullptr)
     , m_haptic(nullptr)
@@ -148,23 +123,22 @@ JoystickInfo::JoystickInfo(int id)
     m_pad_to_sdl[PAD_R_RIGHT] = SDL_CONTROLLER_AXIS_RIGHTX;
     m_pad_to_sdl[PAD_R_DOWN] = SDL_CONTROLLER_AXIS_RIGHTY;
     m_pad_to_sdl[PAD_R_LEFT] = SDL_CONTROLLER_AXIS_RIGHTX;
+    m_pad_to_sdl[PAD_GUIDE] = SDL_CONTROLLER_BUTTON_GUIDE;
+
+    
+    m_controller = gDesignatedControllers[slot].gameCtrl[0];
+    joy = SDL_GameControllerGetJoystick(m_controller);
 
-    if (SDL_IsGameController(id)) {
-        m_controller = SDL_GameControllerOpen(id);
-        joy = SDL_GameControllerGetJoystick(m_controller);
-    } else {
-        joy = SDL_JoystickOpen(id);
-    }
 
     if (joy == nullptr) {
-        fprintf(stderr, "onepad:failed to open joystick %d\n", id);
+        fprintf(stderr, "onepad:failed to open joystick %d\n", slot);
         return;
     }
 
     // Collect Device Information
     char guid[64];
     SDL_JoystickGetGUIDString(SDL_JoystickGetGUID(joy), guid, 64);
-    const char *devname = SDL_JoystickNameForIndex(id);
+    const char *devname = SDL_JoystickNameForIndex(slot);
 
     if (m_controller == nullptr) {
         fprintf(stderr, "onepad: Joystick (%s,GUID:%s) isn't yet supported by the SDL2 game controller API\n"
@@ -173,9 +147,9 @@ JoystickInfo::JoystickInfo(int id)
                         "Please report it to us (https://github.com/PCSX2/pcsx2/issues) so we can add your joystick to our internal database.",
                 devname, guid);
 
-#if SDL_MINOR_VERSION >= 4 // Version before 2.0.4 are bugged, JoystickClose crashes randomly
-        SDL_JoystickClose(joy);
-#endif
+        #if SDL_MINOR_VERSION >= 4 // Version before 2.0.4 are bugged, JoystickClose crashes randomly
+            SDL_JoystickClose(joy);
+        #endif
 
         return;
     }
@@ -279,7 +253,7 @@ int JoystickInfo::GetInput(gamePadValues input)
         return (value > m_deadzone) ? value / 128 : 0;
     }
 
-    // Remain buttons
+    // Map buttons
     int value = SDL_GameControllerGetButton(m_controller, (SDL_GameControllerButton)m_pad_to_sdl[input]);
     return value ? 0xFF : 0; // Max pressure
 }
diff --git a/pcsx2/plugins/onepad/controller.h b/pcsx2/plugins/onepad/controller.h
index c0710c9..61db29b 100644
--- a/pcsx2/plugins/onepad/controller.h
+++ b/pcsx2/plugins/onepad/controller.h
@@ -21,7 +21,7 @@
 
 #pragma once
 #include <string.h> // for memset
-#define MAX_KEYS 24
+#define MAX_KEYS 25
 
 extern void set_keyboard_key(int pad, int keysym, int index);
 extern int get_keyboard_key(int pad, int keysym);
diff --git a/pcsx2/plugins/onepad/keyboard.cpp b/pcsx2/plugins/onepad/keyboard.cpp
index efc244c..4dc1837 100644
--- a/pcsx2/plugins/onepad/keyboard.cpp
+++ b/pcsx2/plugins/onepad/keyboard.cpp
@@ -45,6 +45,7 @@ char *KeysymToChar(int keysym)
 
 /// g_key_status.press but with proper handling for analog buttons
 static void PressButton(u32 pad, u32 button) {
+    
     // Analog controls.
     if (IsAnalogKey(button)) {
         switch (button) {
@@ -76,6 +77,7 @@ static void PressButton(u32 pad, u32 button) {
 // Mouse buttons use discriminator 1
 
 void UpdateKeyboardInput() {
+    
     for (int pad = 0; pad < GAMEPAD_NUMBER; pad++) {
         const auto& map = g_conf.keysym_map[pad];
         // If we loop over all keys press/release based on current state,
@@ -151,7 +153,6 @@ static void AnalyzeKeyEvent(keyEvent &evt)
                     XUngrabKeyboard(GSdsp, CurrentTime);
                 }
             }
-
             if (index!=-1)
             {
                 PressButton(pad, index);
diff --git a/pcsx2/plugins/onepad/onepad.cpp b/pcsx2/plugins/onepad/onepad.cpp
index 003157b..bd604a5 100644
--- a/pcsx2/plugins/onepad/onepad.cpp
+++ b/pcsx2/plugins/onepad/onepad.cpp
@@ -101,7 +101,7 @@ PS2EgetLibVersion2(u32 type)
     return (version << 16) | (revision << 8) | build;
 }
 
-void __Log(const char *fmt, ...)
+void __LogOP(const char *fmt, ...)
 {
     va_list list;
 
diff --git a/pcsx2/plugins/onepad/onepad.h b/pcsx2/plugins/onepad/onepad.h
index b20abd5..99cd546 100644
--- a/pcsx2/plugins/onepad/onepad.h
+++ b/pcsx2/plugins/onepad/onepad.h
@@ -98,7 +98,8 @@ enum gamePadValues {
     PAD_R_UP,     // Right joystick (Up) 
     PAD_R_RIGHT,  // Right joystick (Right) 
     PAD_R_DOWN,   // Right joystick (Down) 
-    PAD_R_LEFT    // Right joystick (Left) 
+    PAD_R_LEFT,   // Right joystick (Left) 
+    PAD_GUIDE     // Guide button
 };
 
 #if defined(__unix__) || defined(__APPLE__)
@@ -118,7 +119,7 @@ enum gamePadValues {
 extern FILE *padLog;
 extern void initLogging();
 
-#define PAD_LOG __Log
+#define PAD_LOG __LogOP
 //#define PAD_LOG __LogToConsole
 
 extern keyEvent event;
@@ -128,7 +129,7 @@ s32 _PADopen(void *pDsp);
 void _PADclose();
 void PADsetMode(int pad, int mode);
 
-void __Log(const char *fmt, ...);
+void __LogOP(const char *fmt, ...);
 void __LogToConsole(const char *fmt, ...);
 void LoadConfig();
 void SaveConfig();
